{"version":3,"sources":["../ts/index.ts"],"sourcesContent":["import type { CommandModule } from \"yargs\";\nimport { readFileSync, writeFileSync } from \"fs\";\nimport { execa } from \"execa\";\nimport chalk from \"chalk\";\nimport { table, getBorderCharacters } from \"table\";\nimport stripAnsi from \"strip-ansi\";\n\n/**\n * Print the gas report to the console, save it to a file and compare it to a previous gas report if provided.\n *\n * Requires foundry to be installed. Inherit from GasReporter and use startGasReport/endGasReport to measure gas used.\n *\n * ```solidity\n * contract MyContractTest is Test, GasReporter {\n *   function testBuffer() public pure {\n *     startGasReport(\"allocate a buffer\");\n *     Buffer buffer = Buffer_.allocate(32);\n *     endGasReport();\n *\n *     bytes32 value = keccak256(\"some data\");\n *\n *     startGasReport(\"append 32 bytes to a buffer\");\n *     buffer.append(value);\n *     endGasReport();\n *  }\n * }\n * ```\n */\n\ntype Options = {\n  path: string[];\n  save?: string;\n  compare?: string;\n};\n\ntype GasReportEntry = {\n  file: string;\n  test: string;\n  name: string;\n  gasUsed: number;\n  prevGasUsed?: number;\n};\n\ntype GasReport = GasReportEntry[];\n\nconst commandModule: CommandModule<Options, Options> = {\n  command: \"gas-report\",\n\n  describe: \"Create a gas report\",\n\n  builder(yargs) {\n    return yargs.options({\n      save: { type: \"string\", desc: \"Save the gas report to a file\" },\n      compare: { type: \"string\", desc: \"Compare to an existing gas report\" },\n    });\n  },\n\n  async handler({ save, compare }) {\n    let gasReport: GasReport;\n    try {\n      gasReport = await runGasReport();\n    } catch (error) {\n      console.error(error);\n      setTimeout(() => process.exit());\n      return;\n    }\n\n    // If this gas report should be compared to an existing one, load the existing one\n    if (compare) {\n      try {\n        const compareGasReport: GasReport = JSON.parse(readFileSync(compare, \"utf8\"));\n        // Merge the previous gas report with the new one\n        gasReport = gasReport.map((entry) => {\n          const prevEntry = compareGasReport.find((e) => e.file === entry.file && e.name === entry.name);\n          return { ...entry, prevGasUsed: prevEntry?.gasUsed };\n        });\n      } catch {\n        console.log(chalk.red(`Gas report to compare not found: ${compare}`));\n        compare = undefined;\n      }\n    }\n\n    // Print gas report\n    printGasReport(gasReport, compare);\n\n    // Save gas report to file if requested\n    if (save) saveGasReport(gasReport, save);\n\n    process.exit(0);\n  },\n};\n\nexport default commandModule;\n\nasync function runGasReport(): Promise<GasReport> {\n  console.log(\"Running gas report\");\n  const gasReport: GasReport = [];\n\n  // Extract the logs from the child process\n  let stdout: string;\n  try {\n    // Run the generated file using forge\n    const child = execa(\"forge\", [\"test\", \"-vvv\"], {\n      stdio: [\"inherit\", \"pipe\", \"inherit\"],\n      env: { GAS_REPORTER_ENABLED: \"true\" },\n    });\n    stdout = (await child).stdout;\n  } catch (error: any) {\n    console.log(error.stdout ?? error);\n    console.log(chalk.red(\"\\n-----------\\nError while running the gas report (see above)\"));\n    throw error;\n  }\n\n  // Extract the gas reports from the logs\n  const lines = stdout.split(\"\\n\").map(stripAnsi);\n  const gasReportPattern = /^\\s*GAS REPORT: (\\d+) (.*)$/;\n  const testFunctionPattern = /^\\[(?:PASS|FAIL).*\\] (\\w+)\\(\\)/;\n  const testFilePattern = /^Running \\d+ tests? for (.*):(.*)$/;\n\n  function nearestLine(pattern: RegExp, startIndex: number = lines.length - 1): number {\n    for (let i = startIndex; i >= 0; i--) {\n      const line = lines[i];\n      if (pattern.test(line)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  for (let i = 0; i < lines.length; i++) {\n    const matches = lines[i].match(gasReportPattern);\n    if (!matches) continue;\n\n    const gasUsed = parseInt(matches[1]);\n    const name = matches[2];\n\n    const testFunctionLineIndex = nearestLine(testFunctionPattern, i);\n    if (testFunctionLineIndex === -1) {\n      throw new Error(\"Could not find nearest test function, did `forge test` output change?\");\n    }\n    const testFileLineIndex = nearestLine(testFilePattern, testFunctionLineIndex);\n    if (testFileLineIndex === -1) {\n      throw new Error(\"Could not find nearest test filename, did `forge test` output change?\");\n    }\n\n    const functionMatches = lines[testFunctionLineIndex].match(testFunctionPattern);\n    if (!functionMatches) {\n      throw new Error(\"Could not parse test function name, did `forge test` output change?\");\n    }\n    const fileMatches = lines[testFileLineIndex].match(testFilePattern);\n    if (!fileMatches) {\n      throw new Error(\"Could not parse test filename, did `forge test` output change?\");\n    }\n\n    const test = functionMatches[1];\n    const file = fileMatches[1];\n\n    gasReport.push({ file, test, name, gasUsed });\n  }\n\n  gasReport.sort((a, b) => a.file.localeCompare(b.file));\n\n  return gasReport;\n}\n\nfunction printGasReport(gasReport: GasReport, compare?: string) {\n  if (compare) console.log(chalk.bold(`Gas report compared to ${compare}`));\n\n  const headers = [\n    chalk.bold(\"File\"),\n    chalk.bold(\"Test\"),\n    chalk.bold(\"Name\"),\n    chalk.bold(\"Gas used\"),\n    ...(compare ? [chalk.bold(\"Prev gas used\"), chalk.bold(\"Difference\")] : []),\n  ];\n\n  const values = gasReport.map((entry) => {\n    const diff = entry.prevGasUsed ? entry.gasUsed - entry.prevGasUsed : 0;\n    const diffEntry = diff > 0 ? chalk.red(`+${diff}`) : diff < 0 ? chalk.green(`${diff}`) : diff;\n    const compareColumns = compare ? [entry.prevGasUsed ?? \"n/a\", diffEntry] : [];\n    const gasUsedEntry = diff > 0 ? chalk.red(entry.gasUsed) : diff < 0 ? chalk.green(entry.gasUsed) : entry.gasUsed;\n    return [entry.file, entry.test, entry.name, gasUsedEntry, ...compareColumns];\n  });\n\n  const rows = [headers, ...values];\n\n  console.log(table(rows, { border: getBorderCharacters(\"norc\") }));\n}\n\nfunction saveGasReport(gasReport: GasReport, path: string) {\n  console.log(chalk.bold(`Saving gas report to ${path}`));\n  writeFileSync(path, `${JSON.stringify(gasReport, null, 2)}\\n`);\n}\n"],"mappings":"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","names":["readFileSync","writeFileSync","execa","chalk","table","getBorderCharacters","stripAnsi","commandModule","yargs","save","compare","gasReport","runGasReport","error","compareGasReport","entry","prevEntry","e","printGasReport","saveGasReport","ts_default","stdout","lines","gasReportPattern","testFunctionPattern","testFilePattern","nearestLine","pattern","startIndex","i","line","matches","gasUsed","name","testFunctionLineIndex","testFileLineIndex","functionMatches","fileMatches","test","file","a","b","headers","values","diff","diffEntry","compareColumns","gasUsedEntry","rows","path"]}