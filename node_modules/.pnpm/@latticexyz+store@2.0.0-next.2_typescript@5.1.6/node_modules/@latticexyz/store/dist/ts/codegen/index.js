import{renderArguments as T,renderCommonData as ee,renderWithStore as _}from"@latticexyz/common/codegen";function M(e){let r=e.storeArgument,{_typedTableId:t,_typedKeyArgs:n,_keyTupleDefinition:o}=ee(e),d="";for(let[a,s]of e.fields.entries()){let c=`${s.typeWithLocation} ${s.name}`;if(d+=_(r,(i,m,l)=>`
      /** Get ${s.name}${l} */
      function get${s.methodNameSuffix}(${T([i,t,n])}) internal view returns (${c}) {
        ${o}
        bytes memory _blob = ${m}.getField(_tableId, _keyTuple, ${a});
        return ${C(s)};
      }
    `),d+=_(r,(i,m,l)=>`
      /** Set ${s.name}${l} */
      function set${s.methodNameSuffix}(${T([i,t,n,c])}) internal {
        ${o}
        ${m}.setField(_tableId, _keyTuple, ${a}, ${R(s)});
      }
    `),s.isDynamic){let i=te(s);d+=_(r,(m,l,p)=>`
        /** Get the length of ${s.name}${p} */
        function length${s.methodNameSuffix}(${T([m,t,n])}) internal view returns (uint256) {
          ${o}
          uint256 _byteLength = ${l}.getFieldLength(_tableId, _keyTuple, ${a}, getSchema());
          return _byteLength / ${i.elementLength};
        }
      `),d+=_(r,(m,l,p)=>`
        /** Get an item of ${s.name}${p} (unchecked, returns invalid data if index overflows) */
        function getItem${s.methodNameSuffix}(${T([m,t,n,"uint256 _index"])}) internal view returns (${i.typeWithLocation}) {
          ${o}
          bytes memory _blob = ${l}.getFieldSlice(
            _tableId,
            _keyTuple,
            ${a},
            getSchema(),
            _index * ${i.elementLength},
            (_index + 1) * ${i.elementLength}
          );
          return ${i.decoded};
        }
      `),d+=_(r,(m,l,p)=>`
        /** Push ${i.title} to ${s.name}${p} */
        function push${s.methodNameSuffix}(${T([m,t,n,`${i.typeWithLocation} ${i.name}`])}) internal {
          ${o}
          ${l}.pushToField(_tableId, _keyTuple, ${a}, ${i.encoded});
        }
      `),d+=_(r,(m,l,p)=>`
        /** Pop ${i.title} from ${s.name}${p} */
        function pop${s.methodNameSuffix}(${T([m,t,n])}) internal {
          ${o}
          ${l}.popFromField(_tableId, _keyTuple, ${a}, ${i.elementLength});
        }
      `),d+=_(r,(m,l,p)=>`
        /** Update ${i.title} of ${s.name}${p} at \`_index\` */
        function update${s.methodNameSuffix}(${T([m,t,n,"uint256 _index",`${i.typeWithLocation} ${i.name}`])}) internal {
          ${o}
          ${l}.updateInField(
            _tableId,
            _keyTuple,
            ${a},
            _index * ${i.elementLength},
            ${i.encoded}
          );
        }
      `)}}return d}function R(e){let r;return e.arrayElement?r="EncodeArray.encode":e.isDynamic?r="bytes":r="abi.encodePacked",`${r}(${e.typeUnwrap}(${e.name}))`}function E(e,r){let{staticByteLength:t,internalTypeId:n}=e,o=`Bytes.slice${t}(_blob, ${r})`,d=t*8,a;if(n.match(/^uint\d{1,3}$/)||n==="address")a=`${n}(${o})`;else if(n.match(/^int\d{1,3}$/))a=`${n}(uint${d}(${o}))`;else if(n.match(/^bytes\d{1,2}$/))a=o;else if(n==="bool")a=`_toBool(uint8(${o}))`;else throw new Error(`Unknown value type id ${n}`);return`${e.typeWrap}(${a})`}function te(e){let r="";if(e.arrayElement){let t="_element",n={...e.arrayElement,arrayElement:void 0,name:t,methodNameSuffix:r};return{typeWithLocation:e.arrayElement.typeWithLocation,name:"_element",encoded:R(n),decoded:C(n),title:"an element",elementLength:e.arrayElement.staticByteLength}}else{let t="_slice",n={...e,name:t,methodNameSuffix:r};return{typeWithLocation:`${e.typeId} memory`,name:t,encoded:R(n),decoded:C(n),title:"a slice",elementLength:1}}}function C(e){let{isDynamic:r,arrayElement:t}=e;return t?`${e.typeWrap}(
      SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_${t.internalTypeId}()
    )`:r?`${e.typeWrap}(${e.internalTypeId}(_blob))`:E(e,0)}import{renderList as F,renderArguments as h,renderCommonData as re,renderWithStore as v}from"@latticexyz/common/codegen";function j(e){let{structName:r,storeArgument:t}=e,{_tableId:n,_typedTableId:o,_keyArgs:d,_typedKeyArgs:a,_keyTupleDefinition:s}=re(e),c=v(t,(i,m,l)=>`
    /** Get the full data${l} */
    function get(${h([i,o,a])}) internal view returns (${oe(e)}) {
      ${s}
      bytes memory _blob = ${m}.getRecord(_tableId, _keyTuple, getSchema());
      return decode(_blob);
    }
  `);return c+=v(t,(i,m,l)=>`
    /** Set the full data using individual values${l} */
    function set(${h([i,o,a,h(e.fields.map(({name:p,typeWithLocation:$})=>`${$} ${p}`))])}) internal {
      bytes memory _data = encode(${h(e.fields.map(({name:p})=>p))});

      ${s}

      ${m}.setRecord(_tableId, _keyTuple, _data);
    }
  `),r!==void 0&&(c+=v(t,(i,m,l,p)=>`
      /** Set the full data using the data struct${l} */
      function set(${h([i,o,a,`${r} memory _table`])}) internal {
        set(${h([p,n,d,h(e.fields.map(({name:$})=>`_table.${$}`))])});
      }
    `)),c+=ne(e),c}function ne({structName:e,fields:r,staticFields:t,dynamicFields:n}){let o=e?`${e} memory _table`:h(r.map(({name:c,typeWithLocation:i})=>`${i} ${c}`)),d=e?"_table.":"",a=t.map(()=>0),s=0;for(let[c,i]of t.entries())a[c]=s,s+=i.staticByteLength;if(n.length>0){let c=t.reduce((i,{staticByteLength:m})=>i+m,0);return`
    /** Decode the tightly packed blob using this table's schema */
    function decode(bytes memory _blob) internal pure returns (${o}) {
      // ${c} is the total byte length of static data
      PackedCounter _encodedLengths = PackedCounter.wrap(Bytes.slice32(_blob, ${c})); 

      ${F(t,(i,m)=>`
        ${d}${i.name} = ${E(i,a[m])};
        `)}
      // Store trims the blob if dynamic fields are all empty
      if (_blob.length > ${c}) {
        uint256 _start;
        // skip static data length + dynamic lengths word
        uint256 _end = ${c+32};
        ${F(n,(i,m)=>`
          _start = _end;
          _end += _encodedLengths.atIndex(${m});
          ${d}${i.name} = ${ie(i)};
          `)}
      }
    }
  `}else return`
    /** Decode the tightly packed blob using this table's schema */
    function decode(bytes memory _blob) internal pure returns (${o}) {
      ${F(t,(c,i)=>`
        ${d}${c.name} = ${E(c,a[i])};
        `)}
    }
    `}function oe({structName:e,fields:r}){return e?`${e} memory _table`:h(r.map(({name:t,typeWithLocation:n})=>`${n} ${t}`))}function ie(e){let{typeId:r,arrayElement:t,typeWrap:n}=e;return t?`${n}(
      SliceLib.getSubslice(_blob, _start, _end).decodeArray_${t.typeId}()
    )`:`${n}(
      ${r}(
        SliceLib.getSubslice(_blob, _start, _end).toBytes()
      )
    )`}import{renderArguments as g,renderCommonData as de,renderList as L,renderedSolidityHeader as se,renderRelativeImports as me,renderTableId as ce,renderValueTypeToBytes32 as le,renderWithStore as O,renderTypeHelpers as pe}from"@latticexyz/common/codegen";import{renderArguments as x,renderCommonData as ae,renderWithStore as U}from"@latticexyz/common/codegen";function G(e){let{structName:r,storeArgument:t}=e,{_tableId:n,_typedTableId:o,_keyArgs:d,_typedKeyArgs:a,_keyTupleDefinition:s}=ae(e),c=U(t,(i,m,l)=>`
    /** Emit the ephemeral event using individual values${l} */
    function emitEphemeral(${x([i,o,a,x(e.fields.map(({name:p,typeWithLocation:$})=>`${$} ${p}`))])}) internal {
      bytes memory _data = encode(${x(e.fields.map(({name:p})=>p))});

      ${s}

      ${m}.emitEphemeralRecord(_tableId, _keyTuple, _data);
    }
  `);return r!==void 0&&(c+=U(t,(i,m,l,p)=>`
      /** Emit the ephemeral event using the data struct${l} */
      function emitEphemeral(${x([i,o,a,`${r} memory _table`])}) internal {
        emitEphemeral(${x([p,n,d,x(e.fields.map(({name:$})=>`_table.${$}`))])});
      }
    `)),c}function K(e){let{imports:r,libraryName:t,structName:n,staticResourceData:o,storeImportPath:d,fields:a,staticFields:s,dynamicFields:c,withFieldMethods:i,withRecordMethods:m,withEphemeralMethods:l,storeArgument:p,keyTuple:$}=e,{_typedTableId:f,_typedKeyArgs:b,_keyTupleDefinition:S}=de(e),I=!l;return`${se}

// Import schema type
import { SchemaType } from "@latticexyz/schema-type/src/solidity/SchemaType.sol";

// Import store internals
import { IStore } from "${d}IStore.sol";
import { StoreSwitch } from "${d}StoreSwitch.sol";
import { StoreCore } from "${d}StoreCore.sol";
import { Bytes } from "${d}Bytes.sol";
import { Memory } from "${d}Memory.sol";
import { SliceLib } from "${d}Slice.sol";
import { EncodeArray } from "${d}tightcoder/EncodeArray.sol";
import { Schema, SchemaLib } from "${d}Schema.sol";
import { PackedCounter, PackedCounterLib } from "${d}PackedCounter.sol";

${r.length>0?`
      // Import user types
      ${me(r)}
    `:""}

${o?ce(o).tableIdDefinition:""}

${n?`
      struct ${n} {
        ${L(a,({name:u,typeId:y})=>`${y} ${u};`)}
      }
`:""}

library ${t} {
  /** Get the table's schema */
  function getSchema() internal pure returns (Schema) {
    SchemaType[] memory _schema = new SchemaType[](${a.length});
    ${L(a,({enumName:u},y)=>`_schema[${y}] = SchemaType.${u};`)}

    return SchemaLib.encode(_schema);
  }

  function getKeySchema() internal pure returns (Schema) {
    SchemaType[] memory _schema = new SchemaType[](${$.length});
    ${L($,({enumName:u},y)=>`_schema[${y}] = SchemaType.${u};`)}

    return SchemaLib.encode(_schema);
  }

  /** Get the table's metadata */
  function getMetadata() internal pure returns (string memory, string[] memory) {
    string[] memory _fieldNames = new string[](${a.length});
    ${L(a,(u,y)=>`_fieldNames[${y}] = "${u.name}";`)}
    return ("${t}", _fieldNames);
  }

  ${O(p,(u,y,A)=>`
    /** Register the table's schema${A} */
    function registerSchema(${g([u,f])}) internal {
      ${y}.registerSchema(_tableId, getSchema(), getKeySchema());
    }
  `)}
  ${O(p,(u,y,A)=>`
    /** Set the table's metadata${A} */
    function setMetadata(${g([u,f])}) internal {
      (string memory _tableName, string[] memory _fieldNames) = getMetadata();
      ${y}.setMetadata(_tableId, _tableName, _fieldNames);
    }
  `)}

  ${i?M(e):""}

  ${m?j(e):""}

  ${l?G(e):""}

  /** Tightly pack full data using this table's schema */
  function encode(${g(e.fields.map(({name:u,typeWithLocation:y})=>`${y} ${u}`))}) internal pure returns (bytes memory) {
    ${ue(c)}
    return abi.encodePacked(${g([g(s.map(({name:u})=>u)),...c.length===0?[]:["_encodedLengths.unwrap()",g(c.map(u=>R(u)))]])});
  }
  
  /** Encode keys as a bytes32 array using this table's schema */
  function encodeKeyTuple(${g([b])}) internal pure returns (bytes32[] memory _keyTuple) {
    _keyTuple = new bytes32[](${$.length});
    ${L($,(u,y)=>`_keyTuple[${y}] = ${le(u.name,u)};`)}
  }

  ${I?O(p,(u,y,A)=>`
    /* Delete all data for given keys${A} */
    function deleteRecord(${g([u,f,b])}) internal {
      ${S}
      ${y}.deleteRecord(_tableId, _keyTuple);
    }
  `):""}
}

${pe(e)}

`}function ue(e){return e.length>0?`
    uint40[] memory _counters = new uint40[](${e.length});
    ${L(e,({name:r,arrayElement:t},n)=>t?`_counters[${n}] = uint40(${r}.length * ${t.staticByteLength});`:`_counters[${n}] = uint40(bytes(${r}).length);`)}
    PackedCounter _encodedLengths = PackedCounterLib.pack(_counters);
    `:""}import{renderEnums as ye}from"@latticexyz/common/codegen";function q(e){let r=Object.keys(e.enums).map(t=>({name:t,memberNames:e.enums[t]}));return ye(r)}import k from"path";import{formatAndWriteSolidity as B}from"@latticexyz/common/codegen";import he from"path";import{SchemaTypeArrayToElement as be}from"@latticexyz/schema-type/deprecated";import{AbiTypeToSchemaType as D,getStaticByteLength as H,SchemaType as w,SchemaTypeToAbiType as V}from"@latticexyz/schema-type/deprecated";import{parseStaticArray as z}from"@latticexyz/config";function P(e,r){if(e in D){let n=D[e];return{schemaType:n,renderType:W(n)}}let t=z(e);if(t){if(t.elementType in D)return $e(e,t.elementType,t.staticLength);throw new Error("Static arrays of user types are not supported")}return fe(e,r)}function N(e,r,t){if(!(e in D||z(e)))return{symbol:e,fromPath:t.userTypesPath+".sol",usedInPath:r}}function W(e){let r=H(e),t=r===0,n=V[e];return{typeId:n,typeWithLocation:t?n+" memory":n,enumName:w[e],staticByteLength:r,isDynamic:t,typeWrap:"",typeUnwrap:"",internalTypeId:n}}function fe(e,r){if(e in r.enums){let t=w.UINT8,n=H(t),o=n===0,d=e;return{schemaType:t,renderType:{typeId:d,typeWithLocation:d,enumName:w[t],staticByteLength:n,isDynamic:o,typeWrap:`${e}`,typeUnwrap:"uint8",internalTypeId:`${V[t]}`}}}throw new Error(`User type "${e}" does not exist`)}function $e(e,r,t){let n=r+"[]",o=D[n];return{schemaType:o,renderType:{typeId:e,typeWithLocation:`${e} memory`,enumName:w[o],staticByteLength:0,isDynamic:!0,typeWrap:`toStaticArray_${r}_${t}`,typeUnwrap:`fromStaticArray_${r}_${t}`,typeWrappingData:{kind:"staticArray",elementType:r,staticLength:t},internalTypeId:n}}}function J(e){let r=e.storeImportPath,t=[];for(let n of Object.keys(e.tables)){let o=e.tables[n],d=o.dataStruct,a=d||Object.keys(o.schema).length>1,s=!a&&Object.keys(o.schema).length===1,c=[],i=Object.keys(o.keySchema).map(f=>{let b=o.keySchema[f],{renderType:S}=P(b,e),I=N(b,o.directory,e);if(I&&c.push(I),S.isDynamic)throw new Error(`Parsing error: found dynamic key ${f} in table ${n}`);return{...S,name:f,isDynamic:!1}}),m=Object.keys(o.schema).map(f=>{let b=o.schema[f],{renderType:S,schemaType:I}=P(b,e),u=N(b,o.directory,e);u&&c.push(u);let y=be[I];return{...S,arrayElement:y!==void 0?W(y):void 0,name:f,methodNameSuffix:s?"":`${f[0].toUpperCase()}${f.slice(1)}`}}),l=m.filter(({isDynamic:f})=>!f),p=m.filter(({isDynamic:f})=>f),$=(()=>{if(!o.tableIdArgument)return{tableIdName:n+"TableId",namespace:e.namespace,name:o.name}})();t.push({outputPath:he.join(o.directory,`${n}.sol`),tableName:n,renderOptions:{imports:c,libraryName:n,structName:d?n+"Data":void 0,staticResourceData:$,storeImportPath:r,keyTuple:i,fields:m,staticFields:l,dynamicFields:p,withFieldMethods:!o.ephemeral,withRecordMethods:a&&!o.ephemeral,withEphemeralMethods:o.ephemeral,storeArgument:o.storeArgument}})}return t}import{posixPath as ge,renderList as Te,renderedSolidityHeader as _e}from"@latticexyz/common/codegen";function Q(e){return`${_e}

${Te(e,({outputPath:r,tableName:t,renderOptions:{structName:n,staticResourceData:o}})=>{let d=[t];return n&&d.push(n),o&&d.push(`${t}TableId`),`import { ${d.join(", ")} } from "./${ge(r)}";`})}
`}import{rmSync as Se}from"fs";async function pt(e,r){let t=J(e),n=new Set(t.map(({outputPath:a})=>k.dirname(a)));for(let a of n)Se(k.join(r,a),{recursive:!0,force:!0});for(let{outputPath:a,renderOptions:s}of t){let c=k.join(r,a),i=K(s);await B(i,c,"Generated table")}if(Object.keys(e.enums).length>0){let a=k.join(r,`${e.userTypesPath}.sol`),s=q(e);await B(s,a,"Generated types file")}let o=k.join(r,"Tables.sol"),d=Q(t);await B(d,o,"Generated table index")}import{renderedSolidityHeader as Ie}from"@latticexyz/common/codegen";import{staticAbiTypeToByteLength as Ae,staticAbiTypes as xe}from"@latticexyz/schema-type";import{getLeftPaddingBits as X}from"@latticexyz/common/codegen";function Y(e){return`
    function decodeArray_${e.internalTypeId}(
      Slice _input
    ) internal pure returns (
      ${e.internalTypeId}[] memory _output
    ) {
      bytes32[] memory _genericArray = TightCoder.decode(
        _input,
        ${e.staticByteLength},
        ${X(e)}
      );
      assembly {
        _output := _genericArray
      }
    }
  `.trim()}function Z(e){return`
    function encode(${e.internalTypeId}[] memory _input) internal pure returns (bytes memory) {
      bytes32[] memory _genericArray;
      assembly {
        _genericArray := _input
      }
      return TightCoder.encode(
        _genericArray,
        ${e.staticByteLength},
        ${X(e)}
      );
    }
  `.trim()}function gt(){let e=`${Ie}
    import { TightCoder } from "./TightCoder.sol";
    import { Slice } from "../Slice.sol";
    library DecodeSlice {
  `;for(let r of xe){let t=Ae[r];e+=Y({internalTypeId:r,staticByteLength:t})}return e+=`
    }
  `,e}import{renderedSolidityHeader as Le}from"@latticexyz/common/codegen";import{staticAbiTypeToByteLength as Re,staticAbiTypes as De}from"@latticexyz/schema-type";function At(){let e=`${Le}
    import { TightCoder } from "./TightCoder.sol";
    library EncodeArray {
  `;for(let r of De){let t=Re[r];e+=Z({internalTypeId:r,staticByteLength:t})}return e+=`
    }
  `,e}import{renderedSolidityHeader as ke}from"@latticexyz/common/codegen";import{staticAbiTypes as Ee}from"@latticexyz/schema-type";function we({typeId:e}){return`
    function testEncodeDecodeArray_${e}(
      ${e} val0,
      ${e} val1,
      ${e} val2
    ) public {
      ${e}[] memory input = new ${e}[](3);
      input[0] = val0;
      input[1] = val1;
      input[2] = val2;

      bytes memory encoded = EncodeArray.encode(input);
      assertEq(encoded, abi.encodePacked(val0, val1, val2));

      ${e}[] memory decoded = SliceLib.fromBytes(encoded).decodeArray_${e}();
      assertEq(decoded.length, 3);
      assertEq(decoded[0], val0);
      assertEq(decoded[1], val1);
      assertEq(decoded[2], val2);
    }
  `.trim()}function Dt(){let e=`${ke}

    import { Test } from "forge-std/Test.sol";
    import { EncodeArray } from "../../src/tightcoder/EncodeArray.sol";
    import { SliceLib } from "../../src/Slice.sol";

    contract TightCoderAutoTest is Test {
  `;for(let r of Ee)e+=we({typeId:r});return e+=`
    }
  `,e}export{W as getSchemaTypeInfo,J as getTableOptions,fe as getUserTypeInfo,N as importForAbiOrUserType,gt as renderDecodeSlice,E as renderDecodeValueType,At as renderEncodeArray,R as renderEncodeFieldSingle,M as renderFieldMethods,j as renderRecordMethods,K as renderTable,Dt as renderTightCoderAutoTest,we as renderTightCoderAutoTestFunction,Y as renderTightCoderDecode,Z as renderTightCoderEncode,q as renderTypesFromConfig,P as resolveAbiOrUserType,pt as tablegen};
//# sourceMappingURL=index.js.map