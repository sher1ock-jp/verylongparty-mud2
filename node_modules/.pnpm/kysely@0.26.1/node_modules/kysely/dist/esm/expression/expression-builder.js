/// <reference types="./expression-builder.d.ts" />
import { SelectQueryBuilder } from '../query-builder/select-query-builder.js';
import { SelectQueryNode } from '../operation-node/select-query-node.js';
import { parseTableExpressionOrList, } from '../parser/table-parser.js';
import { WithSchemaPlugin } from '../plugin/with-schema/with-schema-plugin.js';
import { createQueryId } from '../util/query-id.js';
import { createFunctionModule, } from '../query-builder/function-module.js';
import { parseJSONReference, parseReferenceExpression, parseStringReference, } from '../parser/reference-parser.js';
import { parseValueBinaryOperation, parseValueBinaryOperationOrExpression, } from '../parser/binary-operation-parser.js';
import { AndNode } from '../operation-node/and-node.js';
import { OrNode } from '../operation-node/or-node.js';
import { ParensNode } from '../operation-node/parens-node.js';
import { ExpressionWrapper } from './expression-wrapper.js';
import { parseUnaryOperation } from '../parser/unary-operation-parser.js';
import { parseValueExpressionOrList, } from '../parser/value-parser.js';
import { NOOP_QUERY_EXECUTOR } from '../query-executor/noop-query-executor.js';
import { ValueNode } from '../operation-node/value-node.js';
import { CaseBuilder } from '../query-builder/case-builder.js';
import { CaseNode } from '../operation-node/case-node.js';
import { isUndefined } from '../util/object-utils.js';
import { JSONPathBuilder } from '../query-builder/json-path-builder.js';
export function createExpressionBuilder(executor = NOOP_QUERY_EXECUTOR) {
    function binary(lhs, op, rhs) {
        return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
    }
    function unary(op, expr) {
        return new ExpressionWrapper(parseUnaryOperation(op, expr));
    }
    const eb = Object.assign(binary, {
        fn: undefined,
        eb: undefined,
        selectFrom(table) {
            return new SelectQueryBuilder({
                queryId: createQueryId(),
                executor: executor,
                queryNode: SelectQueryNode.create(parseTableExpressionOrList(table)),
            });
        },
        case(reference) {
            return new CaseBuilder({
                node: CaseNode.create(isUndefined(reference)
                    ? undefined
                    : parseReferenceExpression(reference)),
            });
        },
        ref(reference, op) {
            if (isUndefined(op)) {
                return new ExpressionWrapper(parseStringReference(reference));
            }
            return new JSONPathBuilder(parseJSONReference(reference, op));
        },
        val(value) {
            return new ExpressionWrapper(parseValueExpressionOrList(value));
        },
        // @deprecated
        cmpr(lhs, op, rhs) {
            return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
        },
        // @deprecated
        bxp(lhs, op, rhs) {
            return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
        },
        unary,
        not(expr) {
            return unary('not', expr);
        },
        exists(expr) {
            return unary('exists', expr);
        },
        neg(expr) {
            return unary('-', expr);
        },
        and(exprs) {
            if (exprs.length === 0) {
                return new ExpressionWrapper(ValueNode.createImmediate(true));
            }
            else if (exprs.length === 1) {
                return new ExpressionWrapper(exprs[0].toOperationNode());
            }
            let node = AndNode.create(exprs[0].toOperationNode(), exprs[1].toOperationNode());
            for (let i = 2; i < exprs.length; ++i) {
                node = AndNode.create(node, exprs[i].toOperationNode());
            }
            return new ExpressionWrapper(ParensNode.create(node));
        },
        or(exprs) {
            if (exprs.length === 0) {
                return new ExpressionWrapper(ValueNode.createImmediate(false));
            }
            else if (exprs.length === 1) {
                return new ExpressionWrapper(exprs[0].toOperationNode());
            }
            let node = OrNode.create(exprs[0].toOperationNode(), exprs[1].toOperationNode());
            for (let i = 2; i < exprs.length; ++i) {
                node = OrNode.create(node, exprs[i].toOperationNode());
            }
            return new ExpressionWrapper(ParensNode.create(node));
        },
        parens(...args) {
            const node = parseValueBinaryOperationOrExpression(args);
            if (ParensNode.is(node)) {
                // No double wrapping.
                return new ExpressionWrapper(node);
            }
            else {
                return new ExpressionWrapper(ParensNode.create(node));
            }
        },
        withSchema(schema) {
            return createExpressionBuilder(executor.withPluginAtFront(new WithSchemaPlugin(schema)));
        },
    });
    eb.fn = createFunctionModule();
    eb.eb = eb;
    return eb;
}
export function expressionBuilder(_) {
    return createExpressionBuilder();
}
