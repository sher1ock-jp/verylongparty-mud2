/// <reference types="./binary-operation-parser.d.ts" />
import { BinaryOperationNode } from '../operation-node/binary-operation-node.js';
import { isBoolean, isFunction, isNull, isString, } from '../util/object-utils.js';
import { isOperationNodeSource } from '../operation-node/operation-node-source.js';
import { OperatorNode, isComparisonOperator, isBinaryOperator, OPERATORS, } from '../operation-node/operator-node.js';
import { parseReferenceExpression, } from './reference-parser.js';
import { parseValueExpressionOrList, } from './value-parser.js';
import { ValueNode } from '../operation-node/value-node.js';
import { isExpression } from '../expression/expression.js';
import { createExpressionBuilder } from '../expression/expression-builder.js';
export function parseFilter(args) {
    if (args.length > 1 && !isComparisonOperatorExpression(args[1])) {
        throw new Error(`invalid comparison operator ${JSON.stringify(args[1])}`);
    }
    return parseValueBinaryOperationOrExpression(args);
}
export function parseValueBinaryOperationOrExpression(args) {
    if (args.length === 3) {
        return parseValueBinaryOperation(args[0], args[1], args[2]);
    }
    else if (args.length === 1) {
        return parseExpressionOrFactory(args[0]);
    }
    throw new Error(`invalid arguments: ${JSON.stringify(args)}`);
}
export function parseValueBinaryOperation(leftOperand, operator, rightOperand) {
    if (!isBinaryOperatorExpression(operator)) {
        throw new Error(`invalid binary operator ${JSON.stringify(operator)}`);
    }
    if (isIsOperator(operator) && isNullOrBoolean(rightOperand)) {
        return parseIs(leftOperand, operator, rightOperand);
    }
    return BinaryOperationNode.create(parseReferenceExpression(leftOperand), parseOperator(operator), parseValueExpressionOrList(rightOperand));
}
export function parseReferentialComparison(leftOperand, operator, rightOperand) {
    if (!isComparisonOperatorExpression(operator)) {
        throw new Error(`invalid comparison operator ${JSON.stringify(operator)}`);
    }
    return parseReferentialBinaryOperation(leftOperand, operator, rightOperand);
}
export function parseReferentialBinaryOperation(leftOperand, operator, rightOperand) {
    if (!isBinaryOperatorExpression(operator)) {
        throw new Error(`invalid binary operator ${JSON.stringify(operator)}`);
    }
    return BinaryOperationNode.create(parseReferenceExpression(leftOperand), parseOperator(operator), parseReferenceExpression(rightOperand));
}
function isBinaryOperatorExpression(expr) {
    return isBinaryOperator(expr) || isExpression(expr);
}
function isComparisonOperatorExpression(expr) {
    return isComparisonOperator(expr) || isExpression(expr);
}
function isIsOperator(operator) {
    return operator === 'is' || operator === 'is not';
}
function isNullOrBoolean(value) {
    return isNull(value) || isBoolean(value);
}
function parseIs(leftOperand, operator, rightOperand) {
    return BinaryOperationNode.create(parseReferenceExpression(leftOperand), parseOperator(operator), ValueNode.createImmediate(rightOperand));
}
function parseOperator(operator) {
    if (isString(operator) && OPERATORS.includes(operator)) {
        return OperatorNode.create(operator);
    }
    if (isOperationNodeSource(operator)) {
        return operator.toOperationNode();
    }
    throw new Error(`invalid operator ${JSON.stringify(operator)}`);
}
function parseExpressionOrFactory(arg) {
    if (isFunction(arg)) {
        return arg(createExpressionBuilder()).toOperationNode();
    }
    else if (isOperationNodeSource(arg)) {
        return arg.toOperationNode();
    }
    return ValueNode.create(arg);
}
