{"version":3,"sources":["../src/components/DevHighlight.ts","../src/components/NumberComponent.ts","../src/components/BoolComponent.ts","../src/components/CoordComponent.ts","../src/components/StringComponent.ts","../src/components/ActionComponent.ts","../src/components/VoxelCoordComponent.ts","../src/utils.ts","../src/hooks.ts","../src/systems/ActionSystem/createActionSystem.ts","../src/systems/ActionSystem/constants.ts","../src/systems/ActionSystem/utils/waitForActionCompletion.ts","../src/setup/setupMUDV2Network.ts","../src/setup/utils.ts","../src/getBurnerWallet.ts"],"sourcesContent":["import { defineComponent, Type, World } from \"@latticexyz/recs\";\n\n/**\n * DevHighlight is for use during development to highlight the positions of\n * entities that you are interacting with.\n * Example: Highlight the Entities that you are currently editing in the ComponentBrowser.\n */\nexport function defineDevHighlightComponent(world: World) {\n  return defineComponent(world, { value: Type.OptionalNumber }, { id: \"DevHighlight\" });\n}\n","import { defineComponent, Metadata, Type, World } from \"@latticexyz/recs\";\n\nexport function defineNumberComponent<M extends Metadata>(\n  world: World,\n  options?: { id?: string; metadata?: M; indexed?: boolean }\n) {\n  return defineComponent<{ value: Type.Number }, M>(world, { value: Type.Number }, options);\n}\n","import { defineComponent, Metadata, Type, World } from \"@latticexyz/recs\";\n\nexport function defineBoolComponent<M extends Metadata>(\n  world: World,\n  options?: { id?: string; metadata?: M; indexed?: boolean }\n) {\n  return defineComponent<{ value: Type.Boolean }, M>(world, { value: Type.Boolean }, options);\n}\n","import { defineComponent, Metadata, Type, World } from \"@latticexyz/recs\";\n\nexport function defineCoordComponent<M extends Metadata>(\n  world: World,\n  options?: { id?: string; metadata?: M; indexed?: boolean }\n) {\n  return defineComponent<{ x: Type.Number; y: Type.Number }, M>(world, { x: Type.Number, y: Type.Number }, options);\n}\n","import { defineComponent, Metadata, Type, World } from \"@latticexyz/recs\";\n\nexport function defineStringComponent<M extends Metadata>(\n  world: World,\n  options?: { id?: string; metadata?: M; indexed?: boolean }\n) {\n  return defineComponent<{ value: Type.String }, M>(world, { value: Type.String }, options);\n}\n","import { defineComponent, World, Type, Component, Metadata, SchemaOf } from \"@latticexyz/recs\";\n\nexport function defineActionComponent<T = unknown>(world: World) {\n  const Action = defineComponent(\n    world,\n    {\n      state: Type.Number,\n      on: Type.OptionalEntity,\n      metadata: Type.OptionalT,\n      overrides: Type.OptionalStringArray,\n      txHash: Type.OptionalString,\n    },\n    { id: \"Action\" }\n  );\n  return Action as Component<SchemaOf<typeof Action>, Metadata, T>;\n}\n","import { defineComponent, Metadata, Type, World } from \"@latticexyz/recs\";\n\nexport function defineVoxelCoordComponent<M extends Metadata>(\n  world: World,\n  options?: { id?: string; metadata?: M; indexed?: boolean }\n) {\n  return defineComponent<{ x: Type.Number; y: Type.Number; z: Type.Number }, M>(\n    world,\n    { x: Type.Number, y: Type.Number, z: Type.Number },\n    options\n  );\n}\n","import {\n  Component,\n  getComponentValue,\n  getComponentValueStrict,\n  Has,\n  hasComponent,\n  HasValue,\n  runQuery,\n  Type,\n  Schema,\n  ComponentValue,\n  componentValueEquals,\n  Metadata,\n  Entity,\n} from \"@latticexyz/recs\";\nimport { Coord, keccak256 } from \"@latticexyz/utils\";\nimport { BigNumber } from \"ethers\";\nimport { Clock, SingletonID } from \"@latticexyz/network\";\nimport { deferred } from \"@latticexyz/utils\";\nimport { filter } from \"rxjs\";\n\nexport function getCurrentTurn(\n  gameConfigComponent: Component<{\n    startTime: Type.String;\n    turnLength: Type.String;\n    actionCooldownLength: Type.String;\n  }>,\n  clock: Clock\n) {\n  return getTurnAtTime(gameConfigComponent, clock.currentTime / 1000);\n}\n\nexport function getTurnAtTime(\n  gameConfigComponent: Component<{\n    startTime: Type.String;\n    turnLength: Type.String;\n    actionCooldownLength: Type.String;\n  }>,\n  time: number\n) {\n  const gameConfig = getGameConfig(gameConfigComponent);\n  if (!gameConfig) return -1;\n\n  const startTime = BigNumber.from(gameConfig.startTime);\n  const turnLength = BigNumber.from(gameConfig.turnLength);\n\n  return BigNumber.from(Math.floor(time)).sub(startTime).div(turnLength).toNumber();\n}\n\nexport function getGameConfig(\n  gameConfigComponent: Component<{ startTime: Type.String; turnLength: Type.String; actionCooldownLength: Type.String }>\n) {\n  return getComponentValue(gameConfigComponent, SingletonID);\n}\n\nexport function isUntraversable(\n  untraversableComponent: Component<{ value: Type.Boolean }>,\n  positionComponent: Component<{ x: Type.Number; y: Type.Number }>,\n  targetPosition: Coord\n): boolean {\n  const untraversableEntitiesAtPosition = runQuery([\n    HasValue(positionComponent, targetPosition),\n    Has(untraversableComponent),\n  ]);\n  return untraversableEntitiesAtPosition.size > 0;\n}\n\nexport function getPlayerEntity(\n  address: string | undefined,\n  Player: Component<{ value: Type.Boolean }>\n): Entity | undefined {\n  if (!address) return;\n\n  const playerEntity = address as Entity;\n  if (playerEntity == null || !hasComponent(Player, playerEntity)) return;\n\n  return playerEntity;\n}\n\n/**\n * Starting with the given entity, traverse the relationship chain until the end is reached.\n * @param relationshipComponent The component that will be used to traverse the relationship chain.\n * @param entity Starting entity\n * @returns The last entity in the relationship chain or undefined if the relationship chain is broken.\n */\nexport function resolveRelationshipChain(\n  relationshipComponent: Component<{ value: Type.Entity }>,\n  entity: Entity\n): Entity | undefined {\n  while (hasComponent(relationshipComponent, entity)) {\n    const entityValue = getComponentValueStrict(relationshipComponent, entity).value;\n    if (!entityValue) return;\n    entity = entityValue;\n  }\n  return entity;\n}\n\n/**\n * Starting with the given entity, traverse the relationship chain until you find an entity that has the given component.\n * @param relationshipComponent The component that will be used to traverse the relationship chain.\n * @param entity Starting entity\n * @param searchComponent The component to search for.\n * @returns The first entity in the relationship chain that has the given component or undefined if the relationship chain is broken.\n */\nexport function findEntityWithComponentInRelationshipChain(\n  relationshipComponent: Component<{ value: Type.Entity }>,\n  entity: Entity,\n  searchComponent: Component\n): Entity | undefined {\n  if (hasComponent(searchComponent, entity)) return entity;\n\n  while (hasComponent(relationshipComponent, entity)) {\n    const entityValue = getComponentValueStrict(relationshipComponent, entity).value;\n    if (entityValue == null) return;\n    entity = entityValue;\n\n    if (hasComponent(searchComponent, entity)) return entity;\n  }\n\n  return;\n}\n\n/**\n * Find a specific entity in a relationship chain.\n * @param entity Starting entity\n * @param searchEntity Entity to search for\n * @param relationshipComponent The component that will be used to traverse the relationship chain.\n * @returns True if the entity is found in the relationship chain, false otherwise.\n */\nexport function findInRelationshipChain(\n  relationshipComponent: Component<{ value: Type.Entity }>,\n  entity: Entity,\n  searchEntity: Entity\n): boolean {\n  if (entity === searchEntity) return true;\n\n  while (hasComponent(relationshipComponent, entity)) {\n    const entityValue = getComponentValueStrict(relationshipComponent, entity).value;\n    if (entityValue == null) return false;\n    entity = entityValue;\n\n    if (entity === searchEntity) return true;\n  }\n\n  return false;\n}\n\n/**\n * Generate a random color based on the given id.\n * @param id Any string\n * @returns A color in the range 0x000000 - 0xFFFFFF\n */\nexport function randomColor(id: string): number {\n  const randSeed = new Array(4); // Xorshift: [x, y, z, w] 32 bit values\n  function seedRand(seed: string) {\n    for (let i = 0; i < randSeed.length; i++) {\n      randSeed[i] = 0;\n    }\n    for (let i = 0; i < seed.length; i++) {\n      randSeed[i % 4] = (randSeed[i % 4] << 5) - randSeed[i % 4] + seed.charCodeAt(i);\n    }\n  }\n\n  function rand() {\n    const t = randSeed[0] ^ (randSeed[0] << 11);\n    randSeed[0] = randSeed[1];\n    randSeed[1] = randSeed[2];\n    randSeed[2] = randSeed[3];\n    randSeed[3] = randSeed[3] ^ (randSeed[3] >> 19) ^ t ^ (t >> 8);\n    return (randSeed[3] >>> 0) / ((1 << 31) >>> 0);\n  }\n\n  function createColor(): [number, number, number] {\n    // hue is the whole color spectrum\n    const h = Math.floor(rand() * 360) / 360;\n    //saturation goes from 40 to 100, it avoids greyish colors\n    // --> Multiply by 0.75 to limit saturation\n    // const s = ((rand() * 60 + 40) / 100) * 0.75;\n    const s = 80 / 100;\n    // lightness can be anything from 0 to 100, but probabilities are a bell curve around 50%\n    // --> Multiply by 0.65 to shift\n    // const l = (((rand() + rand() + rand() + rand()) * 25) / 100) * 0.65;\n    const l = 70 / 100;\n    return [h, s, l];\n  }\n\n  function RgbToHex(red: number, green: number, blue: number): number {\n    return (red << 16) | (green << 8) | blue;\n  }\n\n  function hue2rgb(p: number, q: number, t: number) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n  }\n\n  function HSLToRGB(h: number, s: number, l: number): [number, number, number] {\n    let r: number;\n    let g: number;\n    let b: number;\n\n    if (s === 0) {\n      r = g = b = l; // achromatic\n    } else {\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return [r * 255, g * 255, b * 255];\n  }\n\n  seedRand(id);\n\n  return RgbToHex(...HSLToRGB(...createColor()));\n}\n\nexport function getStringColor(address: string) {\n  return randomColor(keccak256(address).substring(2));\n}\n\nexport function waitForComponentValueIn<S extends Schema, T>(\n  component: Component<S, Metadata, T>,\n  entity: Entity,\n  values: Partial<ComponentValue<S>>[]\n): Promise<void> {\n  const [resolve, , promise] = deferred<void>();\n\n  let dispose = resolve;\n  const subscription = component.update$\n    .pipe(\n      filter((e) => e.entity === entity && Boolean(values.find((value) => componentValueEquals(value, e.value[0]))))\n    )\n    .subscribe(() => {\n      resolve();\n      dispose();\n    });\n\n  dispose = () => subscription?.unsubscribe();\n\n  return promise;\n}\n\nexport async function waitForComponentValue<S extends Schema>(\n  component: Component<S>,\n  entity: Entity,\n  value: Partial<ComponentValue<S>>\n): Promise<void> {\n  await waitForComponentValueIn(component, entity, [value]);\n}\n","import { Component, defineQuery, Entity, EntityQueryFragment, Schema, toUpdate } from \"@latticexyz/recs\";\nimport { ObservableSet } from \"mobx\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { filter, Observable } from \"rxjs\";\n\n/** @deprecated Use hooks exported from @latticexyz/react package instead. */\nexport function useStream<T>(stream: Observable<T>, defaultValue?: T) {\n  const [state, setState] = useState<T | undefined>(defaultValue);\n\n  useEffect(() => {\n    const sub = stream.subscribe((newState) => setState(newState));\n    return () => sub?.unsubscribe();\n  }, []);\n\n  return state;\n}\n\n/** @deprecated Use hooks exported from @latticexyz/react package instead. */\nexport function useComponentValueStream<T extends Schema>(component: Component<T>, entity?: Entity) {\n  const stream = useMemo(() => {\n    if (entity != null) return component.update$.pipe(filter((update) => update.entity === entity));\n    return component.update$.asObservable();\n  }, [component, entity]);\n\n  const update = useStream(stream, entity != null ? toUpdate(entity, component) : undefined);\n  if (!update) return null;\n  return update.value[0];\n}\n\n/**\n * Handles subscribing and unsubscribing to a queries update stream to keep the matching set up to date\n * @param queryFragments Query fragments\n * @returns Mobx ObservablesSet with entities currently matching the query\n * @deprecated Use hooks exported from @latticexyz/react package instead.\n */\nexport function useQuery(queryFragments: EntityQueryFragment[]) {\n  const [matching, setMatching] = useState<ObservableSet<Entity>>();\n\n  useEffect(() => {\n    const queryResult = defineQuery(queryFragments, { runOnInit: true });\n    const subscription = queryResult.update$.subscribe();\n    setMatching(queryResult.matching);\n    return () => subscription?.unsubscribe();\n  }, []);\n\n  return matching;\n}\n","import {\n  Components,\n  World,\n  createEntity,\n  getComponentValue,\n  OverridableComponent,\n  Schema,\n  overridableComponent,\n  updateComponent,\n  Component,\n  setComponent,\n  Metadata,\n  Entity,\n} from \"@latticexyz/recs\";\nimport { mapObject, awaitStreamValue, uuid } from \"@latticexyz/utils\";\nimport { ActionState } from \"./constants\";\nimport { ActionData, ActionRequest } from \"./types\";\nimport { defineActionComponent } from \"../../components\";\nimport { merge, Observable } from \"rxjs\";\n\nexport type ActionSystem = ReturnType<typeof createActionSystem>;\n\nexport function createActionSystem<M = unknown>(world: World, txReduced$: Observable<string>) {\n  // Action component\n  const Action = defineActionComponent<M>(world);\n\n  // Components that scheduled actions depend on including pending updates\n  const componentsWithOptimisticUpdates: { [id: string]: OverridableComponent<Schema> } = {};\n\n  // ActionData contains requirements and execute logic of scheduled actions.\n  // We also store the relevant subset of all componentsWithOptimisticUpdates in the action data,\n  // to recheck requirements only if relevant components updated.\n  const actionData = new Map<string, ActionData>();\n\n  // Disposers of requirement check autoruns for all pending actions\n  const disposer = new Map<string, { dispose: () => void }>();\n  world.registerDisposer(() => {\n    for (const { dispose } of disposer.values()) dispose();\n  });\n\n  /**\n   * Maps all components in a given components map to the respective components including pending updates\n   * @param component Component to be mapped to components including pending updates\n   * @returns Components including pending updates\n   */\n  function withOptimisticUpdates<S extends Schema, M extends Metadata, T>(\n    component: Component<S, M, T>\n  ): OverridableComponent<S, M, T> {\n    const optimisticComponent = componentsWithOptimisticUpdates[component.id] || overridableComponent(component);\n\n    // If the component is not tracked yet, add it to the map of overridable components\n    if (!componentsWithOptimisticUpdates[component.id]) {\n      componentsWithOptimisticUpdates[component.id] = optimisticComponent;\n    }\n\n    // Typescript can't know that the optimistic component with this id has the same type as C\n    return optimisticComponent as OverridableComponent<S, M, T>;\n  }\n\n  /**\n   * Schedules an action. The action will be executed once its requirement is fulfilled.\n   * Note: the requirement will only be rechecked automatically if the requirement is based on components\n   * (or other mobx-observable values).\n   * @param actionRequest Action to be scheduled\n   * @returns index of the entity created for the action\n   */\n  function add<C extends Components, T>(actionRequest: ActionRequest<C, T, M>): Entity {\n    // Prevent the same actions from being scheduled multiple times\n    const existingAction = world.hasEntity(actionRequest.id as Entity);\n    if (existingAction) {\n      console.warn(`Action with id ${actionRequest.id} is already requested.`);\n      return actionRequest.id as Entity;\n    }\n\n    // Set the action component\n    const entity = createEntity(world, undefined, {\n      id: actionRequest.id,\n    });\n\n    setComponent(Action, entity, {\n      state: ActionState.Requested,\n      on: actionRequest.on,\n      metadata: actionRequest.metadata,\n      overrides: undefined,\n      txHash: undefined,\n    });\n\n    // Add components that are not tracked yet to internal overridable component map.\n    // Pending updates will be applied to internal overridable components.\n    for (const [key, component] of Object.entries(actionRequest.components)) {\n      if (!componentsWithOptimisticUpdates[key]) componentsWithOptimisticUpdates[key] = overridableComponent(component);\n    }\n\n    // Store relevant components with pending updates along the action's requirement and execution logic\n    const action = {\n      ...actionRequest,\n      entity,\n      componentsWithOptimisticUpdates: mapObject(actionRequest.components, (c) => withOptimisticUpdates(c)),\n    } as unknown as ActionData;\n    actionData.set(action.id, action);\n\n    // This subscriotion makes sure the action requirement is checked again every time\n    // one of the referenced components changes or the pending updates map changes\n    const subscription = merge(\n      ...Object.values(action.componentsWithOptimisticUpdates).map((c) => c.update$)\n    ).subscribe(() => checkRequirement(action));\n    checkRequirement(action);\n    disposer.set(action.id, { dispose: () => subscription?.unsubscribe() });\n\n    return entity;\n  }\n\n  /**\n   * Checks the requirement of a given action and executes the action if the requirement is fulfilled\n   * @param action Action to check the requirement of\n   * @returns void\n   */\n  function checkRequirement(action: ActionData) {\n    // Only check requirements of requested actions\n    if (getComponentValue(Action, action.entity)?.state !== ActionState.Requested) return;\n\n    // Check requirement on components including pending updates\n    const requirementResult = action.requirement(action.componentsWithOptimisticUpdates);\n\n    // Execute the action if the requirements are met\n    if (requirementResult) executeAction(action, requirementResult);\n  }\n\n  /**\n   * Executes the given action and sets the corresponding Action component\n   * @param action ActionData of the action to be executed\n   * @param requirementResult Result of the action's requirement function\n   * @returns void\n   */\n  async function executeAction<T>(action: ActionData, requirementResult: T) {\n    // Only execute actions that were requested before\n    if (getComponentValue(Action, action.entity)?.state !== ActionState.Requested) return;\n\n    // Update the action state\n    updateComponent(Action, action.entity, { state: ActionState.Executing });\n\n    // Compute overrides\n    const overrides = action\n      .updates(action.componentsWithOptimisticUpdates, requirementResult)\n      .map((o) => ({ ...o, id: uuid() }));\n\n    // Store overrides on Action component to be able to remove when action is done\n    updateComponent(Action, action.entity, { overrides: overrides.map((o) => `${o.id}/${o.component}`) });\n\n    // Set all pending updates of this action\n    for (const { component, value, entity, id } of overrides) {\n      componentsWithOptimisticUpdates[component as string].addOverride(id, { entity, value });\n    }\n\n    try {\n      // Execute the action\n      const tx = await action.execute(requirementResult);\n\n      // If the result includes a hash key (single tx) or hashes (multiple tx) key, wait for the transactions to complete before removing the pending actions\n      if (tx) {\n        // Wait for all tx events to be reduced\n        updateComponent(Action, action.entity, { state: ActionState.WaitingForTxEvents, txHash: tx.hash });\n        const txConfirmed = tx.wait().catch((e) => handleError(e, action)); // Also catch the error if not awaiting\n        await awaitStreamValue(txReduced$, (v) => v === tx.hash);\n        updateComponent(Action, action.entity, { state: ActionState.TxReduced });\n        if (action.awaitConfirmation) await txConfirmed;\n      }\n\n      updateComponent(Action, action.entity, { state: ActionState.Complete });\n    } catch (e) {\n      handleError(e, action);\n    }\n\n    // After the action is done executing (failed or completed), remove its actionData and remove the Action component\n    remove(action.id);\n  }\n\n  // Set the action's state to ActionState.Failed\n  function handleError(e: unknown, action: ActionData) {\n    console.error(e);\n    updateComponent(Action, action.entity, { state: ActionState.Failed });\n    remove(action.id);\n  }\n\n  /**\n   * Cancels the action with the given ID if it is in the \"Requested\" state.\n   * @param actionId ID of the action to be cancelled\n   * @returns void\n   */\n  function cancel(actionId: string): boolean {\n    const action = actionData.get(actionId);\n    if (!action || getComponentValue(Action, action.entity)?.state !== ActionState.Requested) {\n      console.warn(`Action ${actionId} was not found or is not in the \"Requested\" state.`);\n      return false;\n    }\n    updateComponent(Action, action.entity, { state: ActionState.Cancelled });\n    remove(actionId);\n    return true;\n  }\n\n  /**\n   * Removes actionData disposer of the action with the given ID and removes its pending updates.\n   * @param actionId ID of the action to be removed\n   */\n  function remove(actionId: string) {\n    const action = actionData.get(actionId);\n    if (!action) {\n      console.warn(`Trying to remove action ${actionId} that does not exist.`);\n      return;\n    }\n\n    // Remove this action's pending updates\n    const actionEntity = actionId as Entity;\n    const overrides = (actionEntity != null && getComponentValue(Action, actionEntity)?.overrides) || [];\n    for (const override of overrides) {\n      const [id, componentKey] = override.split(\"/\");\n      const component = componentsWithOptimisticUpdates[componentKey];\n      component.removeOverride(id);\n    }\n\n    // Remove this action's autorun and corresponding disposer\n    disposer.get(actionId)?.dispose();\n    disposer.delete(actionId);\n\n    // Remove the action data\n    actionData.delete(actionId);\n\n    // Remove the action entity after some time\n    actionEntity != null && setTimeout(() => world.deleteEntity(actionEntity), 5000);\n  }\n\n  return { add, cancel, withOptimisticUpdates, Action };\n}\n","export enum ActionState {\n  Requested,\n  Executing,\n  WaitingForTxEvents,\n  Complete,\n  Failed,\n  Cancelled,\n  TxReduced,\n}\n\nexport const ActionStateString = {\n  [ActionState.TxReduced]: \"TxReduced\",\n  [ActionState.Requested]: \"Requested\",\n  [ActionState.Executing]: \"Executing\",\n  [ActionState.WaitingForTxEvents]: \"WaitingForTxEvents\",\n  [ActionState.Complete]: \"Complete\",\n  [ActionState.Failed]: \"Failed\",\n  [ActionState.Cancelled]: \"Cancelled\",\n};\n","import { Entity } from \"@latticexyz/recs\";\nimport { defineActionComponent } from \"../../../components\";\nimport { waitForComponentValueIn } from \"../../../utils\";\nimport { ActionState } from \"../constants\";\n\nexport async function waitForActionCompletion(\n  Action: ReturnType<typeof defineActionComponent>,\n  entity: Entity\n): Promise<void> {\n  return waitForComponentValueIn(Action, entity, [\n    { state: ActionState.Cancelled },\n    { state: ActionState.Failed },\n    { state: ActionState.Complete },\n  ]);\n}\n","import {\n  createNetwork,\n  createContracts,\n  Mappings,\n  createTxQueue,\n  createSyncWorker,\n  Ack,\n  InputType,\n  SingletonID,\n  RawTableRecord,\n  keyTupleToEntityID,\n} from \"@latticexyz/network\";\nimport { BehaviorSubject, concatMap, from, Subject } from \"rxjs\";\nimport { Components, defineComponent, Type, World } from \"@latticexyz/recs\";\nimport { computed } from \"mobx\";\nimport { keccak256 } from \"@latticexyz/utils\";\nimport { TableId } from \"@latticexyz/common/deprecated\";\nimport { World as WorldContract } from \"@latticexyz/world/types/ethers-contracts/World\";\nimport { IWorldKernel__factory } from \"@latticexyz/world/types/ethers-contracts/factories/IWorldKernel.sol/IWorldKernel__factory\";\nimport { defineStringComponent } from \"../components\";\nimport { ContractComponent, ContractComponents, SetupContractConfig } from \"./types\";\nimport { applyNetworkUpdates, createEncoders } from \"./utils\";\nimport * as devObservables from \"../dev/observables\";\nimport { Abi } from \"abitype\";\nimport { createDatabase, createDatabaseClient } from \"@latticexyz/store-cache\";\nimport { StoreConfig } from \"@latticexyz/store\";\n\ntype SetupMUDV2NetworkOptions<C extends ContractComponents, S extends StoreConfig> = {\n  networkConfig: SetupContractConfig;\n  world: World;\n  contractComponents: C;\n  initialGasPrice?: number;\n  fetchSystemCalls?: boolean;\n  syncThread?: \"main\" | \"worker\";\n  syncStoreCache?: boolean;\n  storeConfig: S;\n  worldAbi: Abi; // TODO: should this extend IWorldKernel ABI or a subset of?\n};\n\nexport async function setupMUDV2Network<C extends ContractComponents, S extends StoreConfig>({\n  networkConfig,\n  world,\n  contractComponents,\n  initialGasPrice,\n  fetchSystemCalls,\n  syncThread,\n  storeConfig,\n  syncStoreCache = true,\n  worldAbi = IWorldKernel__factory.abi,\n}: SetupMUDV2NetworkOptions<C, S>) {\n  devObservables.worldAbi$.next(worldAbi);\n\n  const SystemsRegistry = defineStringComponent(world, {\n    id: \"SystemsRegistry\",\n    metadata: { contractId: \"world.component.systems\" },\n  });\n  const ComponentsRegistry = defineStringComponent(world, {\n    id: \"ComponentsRegistry\",\n    metadata: { contractId: \"world.component.components\" },\n  });\n\n  // used by SyncWorker to notify client of sync progress\n  const LoadingState = defineComponent(\n    world,\n    {\n      state: Type.Number,\n      msg: Type.String,\n      percentage: Type.Number,\n    },\n    {\n      id: \"LoadingState\",\n      metadata: { contractId: \"component.LoadingState\" },\n    }\n  );\n\n  const storeSchemaTableId = new TableId(\"mudstore\", \"schema\");\n  const storeSchemaComponent = defineComponent(\n    world,\n    { valueSchema: Type.String, keySchema: Type.String },\n    {\n      metadata: {\n        contractId: storeSchemaTableId.toHex(),\n        tableId: storeSchemaTableId.toString(),\n      },\n    }\n  );\n\n  const components = {\n    // v2 components\n    storeSchemaComponent,\n    ...contractComponents,\n    // v1 components\n    SystemsRegistry,\n    ComponentsRegistry,\n    LoadingState,\n  } satisfies Components;\n\n  // Mapping from component contract id to key in components object\n  const mappings: Mappings<typeof components> = {};\n\n  // Function to register new components in mappings object\n  function registerComponent(key: string, component: ContractComponent) {\n    if (typeof component.metadata?.tableId === \"string\") {\n      mappings[component.metadata.tableId] = key;\n    } else {\n      mappings[\n        keccak256(typeof component.metadata?.contractId === \"string\" ? component.metadata.contractId : component.id)\n      ] = key;\n    }\n  }\n\n  // Register initial components in mappings object\n  for (const key of Object.keys(components)) {\n    registerComponent(key, components[key]);\n  }\n\n  const network = await createNetwork(networkConfig);\n  world.registerDisposer(network.dispose);\n\n  const signerOrProvider = computed(() => network.signer.get() || network.providers.get().json);\n\n  const { contracts, config: contractsConfig } = await createContracts<{ World: WorldContract }>({\n    config: { World: { abi: IWorldKernel__factory.abi, address: networkConfig.worldAddress } },\n    signerOrProvider,\n  });\n\n  const gasPriceInput$ = new BehaviorSubject<number>(\n    // If no initial gas price is provided, check the gas price once and add a 30% buffer\n    initialGasPrice || Math.ceil((await signerOrProvider.get().getGasPrice()).toNumber() * 1.3)\n  );\n\n  // TODO: replace this with `fastTxExecutor`\n  const { txQueue, dispose: disposeTxQueue } = createTxQueue(contracts, network, gasPriceInput$, {\n    devMode: networkConfig.devMode,\n  });\n  world.registerDisposer(disposeTxQueue);\n\n  // For LoadingState updates\n  const singletonEntity = world.registerEntity({ id: SingletonID });\n  // Register player entity\n  const address = network.connectedAddress.get();\n  const playerEntity = address ? world.registerEntity({ id: keyTupleToEntityID([address]) }) : undefined;\n\n  // Create sync worker\n  const ack$ = new Subject<Ack>();\n  // Avoid passing externalProvider to sync worker (too complex to copy)\n  const {\n    provider: { externalProvider: _, ...providerConfig },\n    ...syncWorkerConfig\n  } = networkConfig;\n  const { ecsEvents$, input$, dispose } = createSyncWorker<typeof components>(ack$, { thread: syncThread });\n  world.registerDisposer(dispose);\n\n  function startSync(initialRecords?: RawTableRecord[], initialBlockNumber?: number) {\n    input$.next({\n      type: InputType.Config,\n      data: {\n        ...syncWorkerConfig,\n        provider: providerConfig,\n        worldContract: contractsConfig.World,\n        initialBlockNumber: initialBlockNumber ?? networkConfig.initialBlockNumber,\n        disableCache: networkConfig.disableCache || [31337, 1337].includes(networkConfig.chainId), // Disable cache on local networks (hardhat / anvil)\n        fetchSystemCalls,\n        initialRecords,\n      },\n    });\n  }\n\n  const db = createDatabase();\n  const storeCache = createDatabaseClient(db, storeConfig);\n\n  const { txReduced$ } = applyNetworkUpdates(\n    world,\n    components,\n    ecsEvents$,\n    mappings,\n    ack$,\n    syncStoreCache ? storeConfig : undefined,\n    syncStoreCache ? storeCache : undefined\n  );\n\n  const encoders = networkConfig.encoders\n    ? createEncoders(world, ComponentsRegistry, signerOrProvider)\n    : new Promise((resolve) => resolve({}));\n\n  return {\n    txQueue,\n    txReduced$,\n    encoders,\n    network,\n    startSync,\n    gasPriceInput$,\n    ecsEvent$: ecsEvents$.pipe(concatMap((updates) => from(updates))),\n    mappings,\n    registerComponent,\n    networkConfig,\n    world,\n    components,\n    singletonEntityId: SingletonID,\n    singletonEntity,\n    playerEntity,\n    storeCache,\n  };\n}\n","import {\n  Ack,\n  ack,\n  createEncoder,\n  isNetworkComponentUpdateEvent,\n  isSystemCallEvent,\n  Mappings,\n  NetworkComponentUpdate,\n  NetworkEvent,\n  SystemCall,\n} from \"@latticexyz/network\";\nimport {\n  Components,\n  World,\n  Schema,\n  Type,\n  getComponentValue,\n  removeComponent,\n  setComponent,\n  getComponentEntities,\n  getComponentValueStrict,\n  Component,\n  updateComponent,\n  Entity,\n} from \"@latticexyz/recs\";\nimport { isDefined } from \"@latticexyz/common/utils\";\nimport { toEthAddress } from \"@latticexyz/utils\";\nimport { Component as SolecsComponent } from \"@latticexyz/solecs\";\nimport ComponentAbi from \"@latticexyz/solecs/abi/Component.sol/Component.json\";\nimport { Contract, BigNumber, Signer } from \"ethers\";\nimport { JsonRpcProvider } from \"@ethersproject/providers\";\nimport { IComputedValue } from \"mobx\";\nimport { filter, map, Observable, Subject, timer } from \"rxjs\";\nimport { DecodedNetworkComponentUpdate, DecodedSystemCall } from \"./types\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { createDatabaseClient } from \"@latticexyz/store-cache\";\n\nexport function createDecodeNetworkComponentUpdate<C extends Components>(\n  world: World,\n  components: C,\n  mappings: Mappings<C>\n): (update: NetworkComponentUpdate) => DecodedNetworkComponentUpdate | undefined {\n  return (update: NetworkComponentUpdate) => {\n    const entity = update.entity ?? world.registerEntity({ id: update.entity });\n    const componentKey = mappings[update.component];\n    const component = components[componentKey] as Component<Schema>;\n\n    if (!componentKey) {\n      console.error(`Component mapping not found for component ID ${update.component} ${JSON.stringify(update.value)}`);\n      return undefined;\n    }\n\n    return {\n      ...update,\n      entity,\n      component,\n    };\n  };\n}\n\nexport function createSystemCallStreams<C extends Components, SystemTypes extends { [key: string]: Contract }>(\n  world: World,\n  systemNames: string[],\n  systemsRegistry: Component<{ value: Type.String }>,\n  getSystemContract: (systemId: string) => { name: string; contract: Contract },\n  decodeNetworkComponentUpdate: ReturnType<typeof createDecodeNetworkComponentUpdate>\n) {\n  const systemCallStreams = systemNames.reduce(\n    (streams, systemId) => ({ ...streams, [systemId]: new Subject<DecodedSystemCall<SystemTypes>>() }),\n    {} as Record<string, Subject<DecodedSystemCall<SystemTypes, C>>>\n  );\n\n  return {\n    systemCallStreams,\n    decodeAndEmitSystemCall: (systemCall: SystemCall<C>) => {\n      const { tx } = systemCall;\n\n      const systemEntity = BigNumber.from(tx.to).toHexString().toLowerCase() as Entity;\n      if (!systemEntity) return;\n\n      const hashedSystemId = getComponentValue(systemsRegistry, systemEntity)?.value;\n      if (!hashedSystemId) return;\n\n      const { name, contract } = getSystemContract(hashedSystemId);\n\n      const decodedTx = contract.interface.parseTransaction({ data: tx.data, value: tx.value });\n\n      // If this is a newly registered System make a new Subject\n      if (!systemCallStreams[name]) {\n        systemCallStreams[name] = new Subject<DecodedSystemCall<SystemTypes>>();\n      }\n\n      systemCallStreams[name].next({\n        ...systemCall,\n        updates: systemCall.updates.map(decodeNetworkComponentUpdate).filter(isDefined),\n        systemId: name,\n        args: decodedTx.args,\n      });\n    },\n  };\n}\n\nexport async function createEncoders(\n  world: World,\n  components: Component<{ value: Type.String }>,\n  signerOrProvider: IComputedValue<JsonRpcProvider | Signer>\n) {\n  const encoders = {} as Record<string, ReturnType<typeof createEncoder>>;\n\n  async function fetchAndCreateEncoder(entity: Entity) {\n    const componentAddress = toEthAddress(entity);\n    const componentId = getComponentValueStrict(components, entity).value;\n    console.info(\"[SyncUtils] Creating encoder for \" + componentAddress);\n    const componentContract = new Contract(\n      componentAddress,\n      ComponentAbi.abi,\n      signerOrProvider.get()\n    ) as SolecsComponent;\n    const [componentSchemaPropNames, componentSchemaTypes] = await componentContract.getSchema();\n    encoders[componentId] = createEncoder(componentSchemaPropNames, componentSchemaTypes);\n  }\n\n  // Initial setup\n  for (const entity of getComponentEntities(components)) fetchAndCreateEncoder(entity);\n\n  // Keep up to date\n  const subscription = components.update$.subscribe((update) => fetchAndCreateEncoder(update.entity));\n  world.registerDisposer(() => subscription?.unsubscribe());\n\n  return encoders;\n}\n\n/**\n * Sets up synchronization between contract components and client components\n */\nexport function applyNetworkUpdates<C extends Components, S extends StoreConfig>(\n  world: World,\n  components: C,\n  ecsEvents$: Observable<NetworkEvent<C>[]>,\n  mappings: Mappings<C>,\n  ack$: Subject<Ack>,\n  storeConfig?: S,\n  storeCache?: ReturnType<typeof createDatabaseClient<S>>,\n  decodeAndEmitSystemCall?: (event: SystemCall<C>) => void\n) {\n  const txReduced$ = new Subject<string>();\n\n  // Send \"ack\" to tell the sync worker we're ready to receive events while not processing\n  let processing = false;\n  const ackSub = timer(0, 100)\n    .pipe(\n      filter(() => !processing),\n      map(() => ack)\n    )\n    .subscribe(ack$);\n\n  const delayQueueSub = ecsEvents$.subscribe((updates) => {\n    processing = true;\n    for (const update of updates) {\n      if (isNetworkComponentUpdateEvent<C>(update)) {\n        if (update.lastEventInTx) txReduced$.next(update.txHash);\n\n        if (storeCache && storeConfig) {\n          // Apply network updates to store cache\n          const { namespace, table, key } = update;\n\n          const tableConfig = storeConfig.tables[table];\n\n          // Apply network updates to cache store\n          if (!tableConfig || namespace !== storeConfig.namespace) {\n            // console.warn(\"Ignoring table config outside own mud config\", update, storeConfig.namespace);\n          } else {\n            // TODO: key names are not yet part of the on-chain table metadata, so we have to\n            // load them from the local mud.config (and have to ignore all tables that are not\n            // defined in the local mud config)\n            // (see https://github.com/latticexyz/mud/issues/824)\n\n            // `Object.getOwnPropertyNames` guarantees key order, `Object.keys` does not\n            const namedKey = nameKeys(key, Object.getOwnPropertyNames(tableConfig.keySchema));\n\n            // StoreCache handles setting partial value and initializing with default values\n            const value = update.value ?? update.partialValue;\n            if (value) {\n              const namedValue = nameKeys(value, Object.getOwnPropertyNames(tableConfig.schema));\n              storeCache.set(namespace, table, namedKey as any, namedValue as any);\n            } else {\n              storeCache.remove(namespace, table, namedKey as any);\n            }\n          }\n        }\n\n        const entity = update.entity ?? world.registerEntity({ id: update.entity });\n        const componentKey = mappings[update.component];\n        if (!componentKey) {\n          console.warn(\"Unknown component:\", update);\n          continue;\n        }\n        const component = components[componentKey] as Component<Schema>;\n\n        // keep this logic aligned with CacheStore's storeEvent\n        if (update.partialValue !== undefined) {\n          updateComponent(component, entity, update.partialValue, update.initialValue);\n        } else if (update.value === undefined) {\n          // undefined value means component removed\n          removeComponent(component, entity);\n        } else {\n          setComponent(component, entity, update.value);\n        }\n      } else if (decodeAndEmitSystemCall && isSystemCallEvent(update)) {\n        decodeAndEmitSystemCall(update);\n      }\n    }\n    // Send \"ack\" after every processed batch of events to process faster than ever 100ms\n    ack$.next(ack);\n    processing = false;\n  });\n\n  world.registerDisposer(() => {\n    delayQueueSub?.unsubscribe();\n    ackSub?.unsubscribe();\n  });\n  return { txReduced$: txReduced$.asObservable() };\n}\n\nfunction nameKeys(indexedRecord: Record<number, unknown>, keyNames: string[]) {\n  const namedRecord: Record<string, unknown> = {};\n  keyNames.forEach((key, index) => {\n    if (index in indexedRecord) {\n      namedRecord[key] = indexedRecord[index];\n    }\n  });\n  return namedRecord;\n}\n","import { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { isHex, Hex } from \"viem\";\nimport { BehaviorSubject } from \"rxjs\";\n\nfunction assertPrivateKey(privateKey: string, cacheKey: string): asserts privateKey is Hex {\n  if (!isHex(privateKey)) {\n    console.error(\"Private key found in cache is not valid hex\", { privateKey, cacheKey });\n    throw new Error(`Private key found in cache (${cacheKey}) is not valid hex`);\n  }\n  // ensure we can extract address from private key\n  // this should throw on bad private keys\n  privateKeyToAccount(privateKey);\n}\n\nexport function getBurnerWallet(cacheKey = \"mud:burnerWallet\"): BehaviorSubject<Hex> {\n  const cachedPrivateKey = localStorage.getItem(cacheKey);\n\n  if (cachedPrivateKey != null) {\n    assertPrivateKey(cachedPrivateKey, cacheKey);\n  }\n\n  const subject =\n    cachedPrivateKey != null\n      ? new BehaviorSubject(cachedPrivateKey)\n      : (() => {\n          const privateKey = generatePrivateKey();\n          console.log(\"New burner wallet created:\", privateKeyToAccount(privateKey));\n          localStorage.setItem(cacheKey, privateKey);\n          return new BehaviorSubject(privateKey);\n        })();\n\n  window.addEventListener(\"storage\", function listener(event) {\n    // Clean up\n    if (subject.closed) {\n      window.removeEventListener(\"storage\", listener);\n      return;\n    }\n\n    if (event.key !== cacheKey) return;\n    if (event.storageArea !== localStorage) return;\n\n    if (!event.newValue) {\n      // We'll intentionally not create a new burner wallet here to avoid potential infinite\n      // loop issues, and just warn the user. A refresh will go through the logic above to\n      // create a new burner wallet.\n      console.warn(\"Burner wallet removed from cache! You may need to reload to create a new wallet.\");\n      return;\n    }\n\n    assertPrivateKey(event.newValue, cacheKey);\n    subject.next(event.newValue);\n  });\n\n  return subject;\n}\n"],"mappings":"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","names":["defineComponent","Type","defineDevHighlightComponent","world","defineComponent","Type","defineNumberComponent","world","options","defineComponent","Type","defineBoolComponent","world","options","defineComponent","Type","defineCoordComponent","world","options","defineComponent","Type","defineStringComponent","world","options","defineComponent","Type","defineActionComponent","world","defineComponent","Type","defineVoxelCoordComponent","world","options","getComponentValue","getComponentValueStrict","Has","hasComponent","HasValue","runQuery","componentValueEquals","keccak256","BigNumber","SingletonID","deferred","filter","getCurrentTurn","gameConfigComponent","clock","getTurnAtTime","time","gameConfig","getGameConfig","startTime","turnLength","isUntraversable","untraversableComponent","positionComponent","targetPosition","getPlayerEntity","address","Player","playerEntity","resolveRelationshipChain","relationshipComponent","entity","entityValue","findEntityWithComponentInRelationshipChain","searchComponent","findInRelationshipChain","searchEntity","randomColor","id","randSeed","seedRand","seed","i","rand","t","createColor","h","l","RgbToHex","red","green","blue","hue2rgb","p","q","HSLToRGB","r","b","getStringColor","waitForComponentValueIn","component","values","resolve","promise","dispose","subscription","e","value","waitForComponentValue","defineQuery","toUpdate","useEffect","useMemo","useState","filter","useStream","stream","defaultValue","state","setState","sub","newState","useComponentValueStream","component","entity","update","useQuery","queryFragments","matching","setMatching","queryResult","subscription","createEntity","getComponentValue","overridableComponent","updateComponent","setComponent","mapObject","awaitStreamValue","uuid","ActionState","ActionStateString","merge","createActionSystem","world","txReduced$","Action","defineActionComponent","componentsWithOptimisticUpdates","actionData","disposer","dispose","withOptimisticUpdates","component","optimisticComponent","overridableComponent","add","actionRequest","entity","createEntity","setComponent","key","action","mapObject","c","subscription","checkRequirement","getComponentValue","requirementResult","executeAction","updateComponent","overrides","o","uuid","value","id","tx","txConfirmed","e","handleError","awaitStreamValue","v","remove","cancel","actionId","actionEntity","override","componentKey","waitForActionCompletion","Action","entity","waitForComponentValueIn","createNetwork","createContracts","createTxQueue","createSyncWorker","InputType","SingletonID","keyTupleToEntityID","BehaviorSubject","concatMap","from","Subject","defineComponent","Type","computed","keccak256","TableId","IWorldKernel__factory","ack","createEncoder","isNetworkComponentUpdateEvent","isSystemCallEvent","getComponentValue","removeComponent","setComponent","getComponentEntities","getComponentValueStrict","updateComponent","isDefined","toEthAddress","ComponentAbi","Contract","BigNumber","filter","map","Subject","timer","createDecodeNetworkComponentUpdate","world","components","mappings","update","entity","componentKey","component","createSystemCallStreams","systemNames","systemsRegistry","getSystemContract","decodeNetworkComponentUpdate","systemCallStreams","streams","systemId","systemCall","tx","systemEntity","hashedSystemId","name","contract","decodedTx","createEncoders","signerOrProvider","encoders","fetchAndCreateEncoder","componentAddress","componentId","componentContract","componentSchemaPropNames","componentSchemaTypes","subscription","applyNetworkUpdates","ecsEvents$","ack$","storeConfig","storeCache","decodeAndEmitSystemCall","txReduced$","processing","ackSub","delayQueueSub","updates","namespace","table","key","tableConfig","namedKey","nameKeys","value","namedValue","indexedRecord","keyNames","namedRecord","index","createDatabase","createDatabaseClient","setupMUDV2Network","networkConfig","world","contractComponents","initialGasPrice","fetchSystemCalls","syncThread","storeConfig","syncStoreCache","worldAbi","IWorldKernel__factory","worldAbi$","SystemsRegistry","defineStringComponent","ComponentsRegistry","LoadingState","defineComponent","Type","storeSchemaTableId","TableId","components","mappings","registerComponent","key","component","keccak256","network","createNetwork","signerOrProvider","computed","contracts","contractsConfig","createContracts","gasPriceInput$","BehaviorSubject","txQueue","disposeTxQueue","createTxQueue","singletonEntity","SingletonID","address","playerEntity","keyTupleToEntityID","ack$","Subject","_","providerConfig","syncWorkerConfig","ecsEvents$","input$","dispose","createSyncWorker","startSync","initialRecords","initialBlockNumber","InputType","db","storeCache","txReduced$","applyNetworkUpdates","encoders","createEncoders","resolve","concatMap","updates","from","generatePrivateKey","privateKeyToAccount","isHex","BehaviorSubject","assertPrivateKey","privateKey","cacheKey","getBurnerWallet","cachedPrivateKey","subject","listener","event"]}