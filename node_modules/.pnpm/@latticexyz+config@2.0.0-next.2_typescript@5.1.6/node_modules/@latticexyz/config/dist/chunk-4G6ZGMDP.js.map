{"version":3,"sources":["../src/library/commonSchemas.ts","../src/library/validation.ts","../src/library/context.ts","../src/library/core.ts","../src/library/dynamicResolution.ts"],"sourcesContent":["import { z } from \"zod\";\nimport {\n  validateBaseRoute,\n  validateCapitalizedName,\n  validateEthereumAddress,\n  validateEnum,\n  validateName,\n  validateRoute,\n  validateSingleLevelRoute,\n  validateUncapitalizedName,\n  validateSelector,\n} from \"./validation\";\n\n/** Capitalized names of objects, like tables and systems */\nexport const zObjectName = z.string().superRefine(validateCapitalizedName);\n/** Uncapitalized names of values, like keys and columns */\nexport const zValueName = z.string().superRefine(validateUncapitalizedName);\n/** Name that can start with any case */\nexport const zAnyCaseName = z.string().superRefine(validateName);\n/** List of unique enum member names and 0 < length < 256 */\nexport const zUserEnum = z.array(zObjectName).superRefine(validateEnum);\n\n/** Ordinary routes */\nexport const zOrdinaryRoute = z.string().superRefine(validateRoute);\n/** Routes with exactly 1 non-empty level */\nexport const zSingleLevelRoute = z.string().superRefine(validateSingleLevelRoute);\n/** Base routes (can be an empty string) */\nexport const zBaseRoute = z.string().superRefine(validateBaseRoute);\n\n/** A valid Ethereum address */\nexport const zEthereumAddress = z.string().superRefine(validateEthereumAddress);\n\n/** A selector for namespace/file/resource */\nexport const zSelector = z.string().superRefine(validateSelector);\n","import { utils } from \"ethers\";\nimport { ZodIssueCode, RefinementCtx } from \"zod\";\n\nexport const STORE_SELECTOR_MAX_LENGTH = 16;\n\nexport function validateName(name: string, ctx: RefinementCtx) {\n  if (!/^\\w+$/.test(name)) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Name must contain only alphanumeric & underscore characters`,\n    });\n  }\n}\n\nexport function validateCapitalizedName(name: string, ctx: RefinementCtx) {\n  validateName(name, ctx);\n\n  if (!/^[A-Z]/.test(name)) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Name must start with a capital letter`,\n    });\n  }\n}\n\nexport function validateUncapitalizedName(name: string, ctx: RefinementCtx) {\n  validateName(name, ctx);\n\n  if (!/^[a-z]/.test(name)) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Name must start with a lowercase letter`,\n    });\n  }\n}\n\n// validates only the enum array, not the names of enum members\nexport function validateEnum(members: string[], ctx: RefinementCtx) {\n  if (members.length === 0) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Enum must not be empty`,\n    });\n  }\n  if (members.length >= 256) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Length of enum must be < 256`,\n    });\n  }\n\n  const duplicates = getDuplicates(members);\n  if (duplicates.length > 0) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Enum must not have duplicate names for: ${duplicates.join(\", \")}`,\n    });\n  }\n}\n\nfunction _factoryForValidateRoute(requireNonEmpty: boolean, requireSingleLevel: boolean) {\n  return (route: string, ctx: RefinementCtx) => {\n    if (route === \"\") {\n      if (requireNonEmpty) {\n        ctx.addIssue({\n          code: ZodIssueCode.custom,\n          message: `Route must not be empty`,\n        });\n      }\n      // we can skip further validation for empty routes\n      return;\n    }\n\n    if (route[0] !== \"/\") {\n      ctx.addIssue({\n        code: ZodIssueCode.custom,\n        message: `Route must start with \"/\"`,\n      });\n    }\n\n    if (route[route.length - 1] === \"/\") {\n      ctx.addIssue({\n        code: ZodIssueCode.custom,\n        message: `Route must not end with \"/\"`,\n      });\n    }\n\n    const parts = route.split(\"/\");\n    if (requireSingleLevel && parts.length > 2) {\n      ctx.addIssue({\n        code: ZodIssueCode.custom,\n        message: `Route must only have one level (e.g. \"/foo\")`,\n      });\n    }\n\n    // start at 1 to skip the first empty part\n    for (let i = 1; i < parts.length; i++) {\n      if (parts[i] === \"\") {\n        ctx.addIssue({\n          code: ZodIssueCode.custom,\n          message: `Route must not contain empty route fragments (e.g. \"//\")`,\n        });\n      }\n\n      if (!/^\\w+$/.test(parts[i])) {\n        ctx.addIssue({\n          code: ZodIssueCode.custom,\n          message: `Route must contain only alphanumeric & underscore characters`,\n        });\n      }\n    }\n  };\n}\n\nexport const validateRoute = _factoryForValidateRoute(true, false);\n\nexport const validateBaseRoute = _factoryForValidateRoute(false, false);\n\nexport const validateSingleLevelRoute = _factoryForValidateRoute(true, true);\n\nexport function validateEthereumAddress(address: string, ctx: RefinementCtx) {\n  if (!utils.isAddress(address)) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Address must be a valid Ethereum address`,\n    });\n  }\n}\n\nexport function getDuplicates<T>(array: T[]) {\n  const checked = new Set<T>();\n  const duplicates = new Set<T>();\n  for (const element of array) {\n    if (checked.has(element)) {\n      duplicates.add(element);\n    }\n    checked.add(element);\n  }\n  return [...duplicates];\n}\n\nexport function validateSelector(name: string, ctx: RefinementCtx) {\n  if (name.length > STORE_SELECTOR_MAX_LENGTH) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Selector must be <= ${STORE_SELECTOR_MAX_LENGTH} characters`,\n    });\n  }\n  if (!/^\\w*$/.test(name)) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Selector must contain only alphanumeric & underscore characters`,\n    });\n  }\n}\n\n/** Returns null if the type does not look like a static array, otherwise element and length data */\nexport function parseStaticArray(abiType: string) {\n  const matches = abiType.match(/^(\\w+)\\[(\\d+)\\]$/);\n  if (!matches) return null;\n  return {\n    elementType: matches[1],\n    staticLength: Number.parseInt(matches[2]),\n  };\n}\n","import { MUDConfigExtender } from \"./core\";\nimport { MUDContextAlreadyCreatedError, MUDContextNotCreatedError } from \"./errors\";\n\nexport type GlobalWithMUDCoreContext = typeof global & {\n  __mudCoreContext: MUDCoreContext;\n};\n\nexport class MUDCoreContext {\n  static _global = typeof global === \"undefined\" ? window.global ?? {} : global;\n\n  public static isCreated(): boolean {\n    const globalWithMUDCoreContext = this._global as GlobalWithMUDCoreContext;\n    return globalWithMUDCoreContext.__mudCoreContext !== undefined;\n  }\n\n  public static createContext(): MUDCoreContext {\n    if (this.isCreated()) {\n      throw new MUDContextAlreadyCreatedError();\n    }\n    const globalWithMUDCoreContext = this._global as GlobalWithMUDCoreContext;\n    const context = new MUDCoreContext();\n    globalWithMUDCoreContext.__mudCoreContext = context;\n    return context;\n  }\n\n  public static getContext(): MUDCoreContext {\n    const globalWithMUDCoreContext = this._global as GlobalWithMUDCoreContext;\n    const context = globalWithMUDCoreContext.__mudCoreContext;\n    if (context === undefined) {\n      throw new MUDContextNotCreatedError();\n    }\n    return context;\n  }\n\n  public readonly configExtenders: MUDConfigExtender[] = [];\n}\n","import { MUDCoreContext } from \"./context\";\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MUDCoreUserConfig {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MUDCoreConfig {}\n\nexport type MUDConfigExtender = (config: MUDCoreConfig) => Record<string, unknown>;\n\n/** Resolver that sequentially passes the config through all the plugins */\nexport function mudCoreConfig(config: MUDCoreUserConfig): MUDCoreConfig {\n  // config types can change with plugins, `any` helps avoid errors when typechecking dependencies\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let configAsAny = config as any;\n  const context = MUDCoreContext.getContext();\n  for (const extender of context.configExtenders) {\n    configAsAny = extender(configAsAny);\n  }\n  return configAsAny;\n}\n\n/** Utility for plugin developers to extend the core config */\nexport function extendMUDCoreConfig(extender: MUDConfigExtender) {\n  const context = MUDCoreContext.getContext();\n  context.configExtenders.push(extender);\n}\n","import { MUDError } from \"@latticexyz/common/errors\";\n\nexport enum DynamicResolutionType {\n  TABLE_ID,\n  SYSTEM_ADDRESS,\n}\n\nexport type DynamicResolution = {\n  type: DynamicResolutionType;\n  input: string;\n};\n\nexport type ValueWithType = {\n  value: string | number | Uint8Array;\n  type: string;\n};\n\n/**\n * Dynamically resolve a table name to a table id at deploy time\n */\nexport function resolveTableId(tableName: string) {\n  return {\n    type: DynamicResolutionType.TABLE_ID,\n    input: tableName,\n  };\n}\n\n/** Type guard for DynamicResolution */\nexport function isDynamicResolution(value: unknown): value is DynamicResolution {\n  return typeof value === \"object\" && value !== null && \"type\" in value && \"input\" in value;\n}\n\n/**\n * Turn a DynamicResolution object into a ValueWithType based on the provided context\n */\nexport async function resolveWithContext(\n  unresolved: any,\n  context: { systemAddresses?: Record<string, Promise<string>>; tableIds?: Record<string, Uint8Array> }\n): Promise<ValueWithType> {\n  if (!isDynamicResolution(unresolved)) return unresolved;\n  let resolved: ValueWithType | undefined = undefined;\n\n  if (unresolved.type === DynamicResolutionType.TABLE_ID) {\n    const tableId = context.tableIds?.[unresolved.input];\n    resolved = tableId && { value: tableId, type: \"bytes32\" };\n  }\n\n  if (resolved === undefined) {\n    throw new MUDError(`Could not resolve dynamic resolution: \\n${JSON.stringify(unresolved, null, 2)}`);\n  }\n\n  return resolved;\n}\n"],"mappings":"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","names":["z","utils","ZodIssueCode","STORE_SELECTOR_MAX_LENGTH","validateName","name","ctx","validateCapitalizedName","validateUncapitalizedName","validateEnum","members","duplicates","getDuplicates","_factoryForValidateRoute","requireNonEmpty","requireSingleLevel","route","parts","i","validateRoute","validateBaseRoute","validateSingleLevelRoute","validateEthereumAddress","address","array","checked","element","validateSelector","parseStaticArray","abiType","matches","zObjectName","z","validateCapitalizedName","zValueName","validateUncapitalizedName","zAnyCaseName","validateName","zUserEnum","validateEnum","zOrdinaryRoute","validateRoute","zSingleLevelRoute","validateSingleLevelRoute","zBaseRoute","validateBaseRoute","zEthereumAddress","validateEthereumAddress","zSelector","validateSelector","_MUDCoreContext","MUDContextAlreadyCreatedError","globalWithMUDCoreContext","context","MUDContextNotCreatedError","MUDCoreContext","__publicField","mudCoreConfig","config","configAsAny","context","MUDCoreContext","extender","extendMUDCoreConfig","MUDError","DynamicResolutionType","resolveTableId","tableName","isDynamicResolution","value","resolveWithContext","unresolved","context","resolved","tableId"]}