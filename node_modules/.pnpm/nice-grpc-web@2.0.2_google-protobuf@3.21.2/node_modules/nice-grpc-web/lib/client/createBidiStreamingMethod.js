"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBidiStreamingMethod = void 0;
const nice_grpc_common_1 = require("nice-grpc-common");
const grpc_web_1 = require("@improbable-eng/grpc-web");
const abort_controller_x_1 = require("abort-controller-x");
const AsyncSink_1 = require("../utils/AsyncSink");
const service_definitions_1 = require("../service-definitions");
const isAsyncIterable_1 = require("../utils/isAsyncIterable");
const convertMetadata_1 = require("../utils/convertMetadata");
/** @internal */
function createBidiStreamingMethod(definition, channel, middleware, defaultOptions) {
    const grpcMethodDefinition = (0, service_definitions_1.toGrpcWebMethodDefinition)(definition);
    const methodDescriptor = {
        path: definition.path,
        requestStream: definition.requestStream,
        responseStream: definition.responseStream,
        options: definition.options,
    };
    async function* bidiStreamingMethod(request, options) {
        if (!(0, isAsyncIterable_1.isAsyncIterable)(request)) {
            throw new Error('A middleware passed invalid request to next(): expected a single message for bidirectional streaming method');
        }
        const { metadata = (0, nice_grpc_common_1.Metadata)(), signal = new AbortController().signal, onHeader, onTrailer, } = options;
        const pipeAbortController = new AbortController();
        const sink = new AsyncSink_1.AsyncSink();
        const client = grpc_web_1.grpc.client(grpcMethodDefinition, {
            host: channel.address,
            transport: channel.transport,
        });
        client.onHeaders(headers => {
            onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1.convertMetadataFromGrpcWeb)(headers));
        });
        client.onMessage(message => {
            sink.write(message);
        });
        client.onEnd((code, message, trailers) => {
            onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1.convertMetadataFromGrpcWeb)(trailers));
            if (code === grpc_web_1.grpc.Code.OK) {
                sink.end();
            }
            else {
                sink.error(new nice_grpc_common_1.ClientError(definition.path, +code, message));
            }
        });
        client.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(metadata));
        let pipeError;
        pipeRequest(pipeAbortController.signal, request, client, definition).then(() => {
            client.finishSend();
        }, err => {
            if (!(0, abort_controller_x_1.isAbortError)(err)) {
                pipeError = err;
                client.close();
                sink.end();
            }
        });
        const abortListener = () => {
            sink.error(new abort_controller_x_1.AbortError());
            pipeAbortController.abort();
            client.close();
        };
        signal.addEventListener('abort', abortListener);
        try {
            yield* sink;
        }
        finally {
            pipeAbortController.abort();
            signal.removeEventListener('abort', abortListener);
            (0, abort_controller_x_1.throwIfAborted)(signal);
            if (pipeError) {
                throw pipeError;
            }
        }
    }
    const method = middleware == null
        ? bidiStreamingMethod
        : (request, options) => middleware({
            method: methodDescriptor,
            requestStream: true,
            request,
            responseStream: true,
            next: bidiStreamingMethod,
        }, options);
    return (request, options) => {
        const iterable = method(request, {
            ...defaultOptions,
            ...options,
        });
        const iterator = iterable[Symbol.asyncIterator]();
        return {
            [Symbol.asyncIterator]() {
                return {
                    async next() {
                        const result = await iterator.next();
                        if (result.done && result.value != null) {
                            return await iterator.throw(new Error('A middleware returned a message, but expected to return void for bidirectional streaming method'));
                        }
                        return result;
                    },
                    return() {
                        return iterator.return();
                    },
                    throw(err) {
                        return iterator.throw(err);
                    },
                };
            },
        };
    };
}
exports.createBidiStreamingMethod = createBidiStreamingMethod;
async function pipeRequest(signal, request, client, definition) {
    for await (const item of request) {
        (0, abort_controller_x_1.throwIfAborted)(signal);
        client.send({
            serializeBinary: () => definition.requestSerialize(item),
        });
    }
}
//# sourceMappingURL=createBidiStreamingMethod.js.map