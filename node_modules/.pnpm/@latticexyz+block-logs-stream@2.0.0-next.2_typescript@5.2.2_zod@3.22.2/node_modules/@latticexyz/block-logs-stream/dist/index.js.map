{"version":3,"sources":["../src/blockRangeToLogs.ts","../src/fetchLogs.ts","../src/debug.ts","../src/createBlockStream.ts","../src/groupLogsByBlockNumber.ts"],"sourcesContent":["import { EMPTY, OperatorFunction, concatMap, from, pipe, tap } from \"rxjs\";\nimport { FetchLogsResult, fetchLogs } from \"./fetchLogs\";\nimport { AbiEvent } from \"abitype\";\nimport { Address, BlockNumber, PublicClient } from \"viem\";\n\nexport type BlockRangeToLogsOptions<TAbiEvents extends readonly AbiEvent[]> = {\n  /**\n   * [viem `PublicClient`][0] used for fetching logs from the RPC.\n   *\n   * [0]: https://viem.sh/docs/clients/public.html\n   */\n  publicClient: PublicClient;\n  /**\n   * Optional contract address(es) to fetch logs for.\n   */\n  address?: Address | Address[];\n  /**\n   * Events to fetch logs for.\n   */\n  events: TAbiEvents;\n  /**\n   * Optional maximum block range, if your RPC limits the amount of blocks fetched at a time.\n   */\n  maxBlockRange?: bigint;\n};\n\nexport type BlockRangeToLogsResult<TAbiEvents extends readonly AbiEvent[]> = OperatorFunction<\n  { startBlock: BlockNumber; endBlock: BlockNumber },\n  FetchLogsResult<TAbiEvents>\n>;\n\n/**\n * Takes in an observable of `Observable<{ startBlock: bigint, endBlock: bigint }>` and uses a viem `publicClient` to get logs for the contract `address` and matching `events` and emits the logs as they are fetched.\n *\n * @param {BlockRangeToLogsOptions<AbiEvent[]>} options See `BlockRangeToLogsOptions`.\n * @returns {BlockRangeToLogsResult<AbiEvent[]>} An operator function that transforms a stream of block ranges into a stream of fetched logs.\n */\nexport function blockRangeToLogs<TAbiEvents extends readonly AbiEvent[]>({\n  publicClient,\n  address,\n  events,\n  maxBlockRange,\n}: BlockRangeToLogsOptions<TAbiEvents>): BlockRangeToLogsResult<TAbiEvents> {\n  let fromBlock: bigint;\n  let toBlock: bigint;\n\n  return pipe(\n    tap(({ endBlock, startBlock }) => {\n      fromBlock ??= startBlock;\n      toBlock = endBlock;\n    }),\n    // concatMap only processes the next emission once the inner observable completes,\n    // so it always uses the latest`toBlock` value.\n    concatMap(() => {\n      if (fromBlock > toBlock) return EMPTY;\n      return from(\n        fetchLogs({\n          publicClient,\n          address,\n          events,\n          fromBlock,\n          toBlock,\n          maxBlockRange,\n        })\n      ).pipe(\n        tap(({ toBlock }) => {\n          fromBlock = toBlock + 1n;\n        })\n      );\n    })\n  );\n}\n","import { AbiEvent } from \"abitype\";\nimport { Address, PublicClient, BlockNumber, GetLogsReturnType } from \"viem\";\nimport { bigIntMin, wait } from \"@latticexyz/common/utils\";\nimport { debug } from \"./debug\";\n\nexport type FetchLogsOptions<TAbiEvents extends readonly AbiEvent[]> = {\n  /**\n   * [viem `PublicClient`][0] used for fetching logs from the RPC.\n   *\n   * [0]: https://viem.sh/docs/clients/public.html\n   */\n  publicClient: PublicClient;\n  /**\n   * Optional contract address(es) to fetch logs for.\n   */\n  address?: Address | Address[];\n  /**\n   * Events to fetch logs for.\n   */\n  events: TAbiEvents;\n  /**\n   * The block number to start fetching logs from (inclusive).\n   */\n  fromBlock: BlockNumber;\n  /**\n   * The block number to stop fetching logs at (inclusive).\n   */\n  toBlock: BlockNumber;\n  /**\n   * Optional maximum block range, if your RPC limits the amount of blocks fetched at a time. Defaults to 1000n.\n   */\n  maxBlockRange?: bigint;\n  /**\n   * Optional maximum amount of retries if the RPC returns a rate limit error. Defaults to 3.\n   */\n  maxRetryCount?: number;\n};\n\nexport type FetchLogsResult<TAbiEvents extends readonly AbiEvent[]> = {\n  fromBlock: BlockNumber;\n  toBlock: BlockNumber;\n  logs: GetLogsReturnType<undefined, TAbiEvents, true, BlockNumber, BlockNumber>;\n};\n\n/**\n * An asynchronous generator function that fetches logs from the blockchain in a range of blocks.\n *\n * @remarks\n * The function will fetch logs according to the given options.\n * It will iteratively move forward in the block range, yielding fetched logs as they become available.\n * If the function encounters rate limits, it will retry until `maxRetryCount` is reached.\n * If the function encounters a block range that is too large, it will half the block range and retry, until the block range can't be halved anymore.\n *\n * @param {FetchLogsOptions<AbiEvent[]>} options See `FetchLogsOptions`.\n *\n * @yields The result of the fetched logs for each block range in the given range.\n *\n * @throws Will throw an error if the block range can't be reduced any further.\n */\nexport async function* fetchLogs<TAbiEvents extends readonly AbiEvent[]>({\n  maxBlockRange = 1000n,\n  maxRetryCount = 3,\n  publicClient,\n  ...getLogsOpts\n}: FetchLogsOptions<TAbiEvents>): AsyncGenerator<FetchLogsResult<TAbiEvents>> {\n  let fromBlock = getLogsOpts.fromBlock;\n  let blockRange = bigIntMin(maxBlockRange, getLogsOpts.toBlock - fromBlock);\n  let retryCount = 0;\n\n  while (fromBlock <= getLogsOpts.toBlock) {\n    try {\n      const toBlock = fromBlock + blockRange;\n      const logs = await publicClient.getLogs({ ...getLogsOpts, fromBlock, toBlock, strict: true });\n      yield { fromBlock, toBlock, logs };\n      fromBlock = toBlock + 1n;\n      blockRange = bigIntMin(maxBlockRange, getLogsOpts.toBlock - fromBlock);\n    } catch (error: unknown) {\n      if (!(error instanceof Error)) throw error;\n\n      // TODO: figure out actual rate limit message for RPCs\n      if (error.message.includes(\"rate limit exceeded\") && retryCount < maxRetryCount) {\n        const seconds = 2 * retryCount;\n        debug(`too many requests, retrying in ${seconds}s`, error);\n        await wait(1000 * seconds);\n        retryCount += 1;\n        continue;\n      }\n\n      // TODO: figure out actual block range exceeded message for RPCs\n      if (error.message.includes(\"block range exceeded\")) {\n        blockRange /= 2n;\n        if (blockRange <= 0n) {\n          throw new Error(\"can't reduce block range any further\");\n        }\n        debug(\"block range exceeded, trying a smaller block range\", error);\n        // TODO: adjust maxBlockRange down if we consistently hit this for a given block range size\n        continue;\n      }\n\n      throw error;\n    }\n  }\n}\n","import createDebug from \"debug\";\n\nexport const debug = createDebug(\"mud:block-events-stream\");\n","import { Observable } from \"rxjs\";\nimport type { Block, BlockTag, PublicClient } from \"viem\";\n\nexport type CreateBlockStreamOptions<TBlockTag extends BlockTag> = {\n  publicClient: PublicClient;\n  blockTag: TBlockTag;\n};\n\nexport type CreateBlockStreamResult<TBlockTag extends BlockTag> = Observable<Block<bigint, false, TBlockTag>>;\n\nexport function createBlockStream<TBlockTag extends BlockTag>({\n  publicClient,\n  blockTag,\n}: CreateBlockStreamOptions<TBlockTag>): CreateBlockStreamResult<TBlockTag> {\n  return new Observable(function subscribe(subscriber) {\n    return publicClient.watchBlocks({\n      blockTag,\n      emitOnBegin: true,\n      onBlock: (block) => subscriber.next(block),\n      onError: (error) => subscriber.error(error),\n    });\n  });\n}\n","import { BlockNumber } from \"viem\";\nimport { bigIntSort, isDefined } from \"@latticexyz/common/utils\";\n\ntype PartialLog = { blockNumber: bigint; logIndex: number };\n\nexport type GroupLogsByBlockNumberResult<TLog extends PartialLog> = {\n  blockNumber: BlockNumber;\n  logs: TLog[];\n}[];\n\n/**\n * Groups logs by their block number.\n *\n * @remarks\n * This function takes an array of logs and returns a new array where each item corresponds to a distinct block number.\n * Each item in the output array includes the block number, the block hash, and an array of all logs for that block.\n * Pending logs are filtered out before processing, as they don't have block numbers.\n *\n * @param logs The logs to group by block number.\n * @param toBlock If specified, always include this block number at the end, even if there are no logs.\n *\n * @returns An array of objects where each object represents a distinct block and includes the block number,\n * the block hash, and an array of logs for that block.\n */\nexport function groupLogsByBlockNumber<TLog extends PartialLog>(\n  logs: readonly TLog[],\n  toBlock?: BlockNumber\n): GroupLogsByBlockNumberResult<TLog> {\n  const blockNumbers = Array.from(new Set(logs.map((log) => log.blockNumber)));\n  blockNumbers.sort(bigIntSort);\n\n  const groupedBlocks = blockNumbers\n    .map((blockNumber) => {\n      const blockLogs = logs.filter((log) => log.blockNumber === blockNumber);\n      if (!blockLogs.length) return;\n      blockLogs.sort((a, b) => (a.logIndex < b.logIndex ? -1 : a.logIndex > b.logIndex ? 1 : 0));\n\n      if (!blockLogs.length) return;\n\n      return {\n        blockNumber,\n        logs: blockLogs,\n      };\n    })\n    .filter(isDefined);\n\n  const lastBlockNumber = blockNumbers.length > 0 ? blockNumbers[blockNumbers.length - 1] : null;\n\n  if (toBlock != null && (lastBlockNumber == null || toBlock > lastBlockNumber)) {\n    groupedBlocks.push({\n      blockNumber: toBlock,\n      logs: [],\n    });\n  }\n\n  return groupedBlocks;\n}\n"],"mappings":"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","names":["EMPTY","concatMap","from","pipe","tap","bigIntMin","wait","createDebug","debug","fetchLogs","maxBlockRange","maxRetryCount","publicClient","getLogsOpts","fromBlock","blockRange","bigIntMin","retryCount","toBlock","logs","error","seconds","debug","wait","blockRangeToLogs","publicClient","address","events","maxBlockRange","fromBlock","toBlock","pipe","tap","endBlock","startBlock","concatMap","EMPTY","from","fetchLogs","Observable","createBlockStream","publicClient","blockTag","subscriber","block","error","bigIntSort","isDefined","groupLogsByBlockNumber","logs","toBlock","blockNumbers","log","groupedBlocks","blockNumber","blockLogs","a","b","lastBlockNumber"]}