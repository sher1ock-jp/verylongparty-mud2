import{EMPTY as p,concatMap as B,from as d,pipe as f,tap as m}from"rxjs";import{bigIntMin as b,wait as k}from"@latticexyz/common/utils";import g from"debug";var u=g("mud:block-events-stream");async function*a({maxBlockRange:c=1000n,maxRetryCount:i=3,publicClient:l,...t}){let e=t.fromBlock,r=b(c,t.toBlock-e),n=0;for(;e<=t.toBlock;)try{let o=e+r,s=await l.getLogs({...t,fromBlock:e,toBlock:o,strict:!0});yield{fromBlock:e,toBlock:o,logs:s},e=o+1n,r=b(c,t.toBlock-e)}catch(o){if(!(o instanceof Error))throw o;if(o.message.includes("rate limit exceeded")&&n<i){let s=2*n;u(`too many requests, retrying in ${s}s`,o),await k(1e3*s),n+=1;continue}if(o.message.includes("block range exceeded")){if(r/=2n,r<=0n)throw new Error("can't reduce block range any further");u("block range exceeded, trying a smaller block range",o);continue}throw o}}function P({publicClient:c,address:i,events:l,maxBlockRange:t}){let e,r;return f(m(({endBlock:n,startBlock:o})=>{e??=o,r=n}),B(()=>e>r?p:d(a({publicClient:c,address:i,events:l,fromBlock:e,toBlock:r,maxBlockRange:t})).pipe(m(({toBlock:n})=>{e=n+1n}))))}import{Observable as T}from"rxjs";function O({publicClient:c,blockTag:i}){return new T(function(t){return c.watchBlocks({blockTag:i,emitOnBegin:!0,onBlock:e=>t.next(e),onError:e=>t.error(e)})})}import{bigIntSort as x,isDefined as y}from"@latticexyz/common/utils";function M(c,i){let l=Array.from(new Set(c.map(r=>r.blockNumber)));l.sort(x);let t=l.map(r=>{let n=c.filter(o=>o.blockNumber===r);if(n.length&&(n.sort((o,s)=>o.logIndex<s.logIndex?-1:o.logIndex>s.logIndex?1:0),!!n.length))return{blockNumber:r,logs:n}}).filter(y),e=l.length>0?l[l.length-1]:null;return i!=null&&(e==null||i>e)&&t.push({blockNumber:i,logs:[]}),t}export{P as blockRangeToLogs,O as createBlockStream,a as fetchLogs,M as groupLogsByBlockNumber};
//# sourceMappingURL=index.js.map