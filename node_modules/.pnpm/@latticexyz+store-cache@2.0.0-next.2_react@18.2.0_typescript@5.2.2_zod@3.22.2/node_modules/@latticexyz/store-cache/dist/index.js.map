{"version":3,"sources":["../src/createDatabase.ts","../src/createDatabaseClient.ts","../src/utils.ts"],"sourcesContent":["import { InMemoryTupleStorage, AsyncTupleStorageApi, AsyncTupleDatabase } from \"tuple-database\";\n\nexport type CreateDatabaseOptions = {\n  storage?: AsyncTupleStorageApi;\n};\n\n/**\n * Create a new in-memory tuple database\n */\nexport function createDatabase(opts: CreateDatabaseOptions = {}): AsyncTupleDatabase {\n  const storage = opts.storage ?? new InMemoryTupleStorage();\n  return new AsyncTupleDatabase(storage);\n}\n","import { AsyncTupleDatabase, AsyncTupleDatabaseClient } from \"tuple-database\";\nimport { DatabaseClient, Key, SetOptions, SubscriptionCallback, FilterOptions, Value } from \"./types\";\nimport { set, get, remove, getDefaultValue, subscribe, scan } from \"./utils\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { curry } from \"@latticexyz/common/utils\";\n\n/**\n * Create a typed database client from a tuple database and a store config\n */\nexport function createDatabaseClient<C extends StoreConfig>(\n  database: AsyncTupleDatabase,\n  config: C\n): DatabaseClient<C> {\n  const _tupleDatabaseClient = new AsyncTupleDatabaseClient(database);\n  const { namespace } = config;\n  const tables: Record<string, unknown> = {};\n\n  // Create utils with client argument prefilled\n  const utilsWithClient = {\n    set: curry(set<C>, config, _tupleDatabaseClient),\n    get: curry(get<C>, config, _tupleDatabaseClient),\n    remove: curry(remove<C>, config, _tupleDatabaseClient),\n    subscribe: curry(subscribe<C>, config, _tupleDatabaseClient),\n    scan: curry(scan<C>, config, _tupleDatabaseClient),\n  };\n\n  // Create utils with client, namespace and table argument prefilled\n  for (const table in config.tables) {\n    tables[table] = {\n      set: (key: Key<C, typeof table>, value: Value<C, typeof table>, options: SetOptions) =>\n        utilsWithClient.set(namespace, table, key, value, {\n          defaultValue: getDefaultValue(config.tables?.[table].schema),\n          ...options,\n        }),\n      get: curry(utilsWithClient.get, namespace, table),\n      remove: curry(utilsWithClient.remove, namespace, table),\n      subscribe: (\n        callback: SubscriptionCallback<C, typeof table>,\n        filter?: Omit<FilterOptions<C, typeof table>, \"table\" | \"namespace\">\n      ) => subscribe(config, _tupleDatabaseClient, callback, { namespace, table, ...filter }),\n      scan: (filter?: Omit<FilterOptions<C, typeof table>, \"table\" | \"namespace\">) =>\n        scan(config, _tupleDatabaseClient, { namespace, table, ...filter }),\n    };\n  }\n\n  return { tables, _tupleDatabaseClient, ...utilsWithClient } as DatabaseClient<C>;\n}\n","import { ScanArgs, Tuple, AsyncTupleDatabaseClient, Unsubscribe } from \"tuple-database\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport {\n  Key,\n  RemoveOptions,\n  SchemaToPrimitives,\n  SetOptions,\n  SubscriptionCallback,\n  FilterOptions,\n  Update,\n  Value,\n  KeyValue,\n  ScanResult,\n} from \"./types\";\nimport { getAbiTypeDefaultValue } from \"@latticexyz/schema-type/deprecated\";\nimport { StaticPrimitiveType } from \"@latticexyz/schema-type\";\n\n/**\n * Set the value for the given key\n * @param client AsyncTupleDatabaseClient\n * @param table Table to set the given key in\n * @param key Key to identify the record to set in the table\n * @param value Value to set for the given key\n * @param options {\n *  transaction?: Append to an existing transaction, do not commit\n *  defaultValue?: Default value to use if the key does not exist\n * }\n * @returns Transaction\n */\nexport async function set<C extends StoreConfig, T extends keyof C[\"tables\"] = keyof C[\"tables\"]>(\n  config: C,\n  client: AsyncTupleDatabaseClient,\n  namespace: C[\"namespace\"],\n  table: T & string,\n  key: Key<C, T>,\n  value: Partial<Value<C, T>>,\n  options?: SetOptions\n): Promise<void> {\n  const keyTuple = databaseKey<C, T>(config, namespace, table, key);\n  const currentValue = (await client.get(keyTuple)) ?? options?.defaultValue;\n  const tx = options?.transaction ?? client.transact();\n  tx.set(keyTuple, { ...currentValue, ...value });\n  if (!options?.transaction) await tx.commit();\n}\n\n/**\n * Get the value for the given key\n * @param client AsyncTupleDatabaseClient\n * @param table Table to get the given key from\n * @param key Key to identify the record to get from the table\n * @returns Value for the given key\n */\nexport async function get<C extends StoreConfig, T extends keyof C[\"tables\"] = keyof C[\"tables\"]>(\n  config: C,\n  client: AsyncTupleDatabaseClient,\n  namespace: C[\"namespace\"],\n  table: T & string,\n  key: Key<C, T>\n): Promise<Value<C, T>> {\n  return client.get(databaseKey<C, T>(config, namespace, table, key));\n}\n\n/**\n * Remove the value for the given key\n * @param client AsyncTupleDatabaseClient\n * @param table Table to remove the given key from\n * @param key Key to identify the record to remove from the table\n * @param options {\n *  transaction?: Append to an existing transaction, do not commit\n *  defaultValue?: Default value to use if the key does not exist\n * }\n * @returns Transaction\n */\nexport async function remove<C extends StoreConfig, T extends keyof C[\"tables\"] = keyof C[\"tables\"]>(\n  config: C,\n  client: AsyncTupleDatabaseClient,\n  namespace: C[\"namespace\"],\n  table: T & string,\n  key: Key<C, T>,\n  options?: RemoveOptions\n): Promise<void> {\n  const tx = options?.transaction ?? client.transact();\n  tx.remove(databaseKey<C, T>(config, namespace, table, key));\n  if (!options?.transaction) await tx.commit();\n}\n\nexport async function scan<C extends StoreConfig = StoreConfig, T extends keyof C[\"tables\"] = keyof C[\"tables\"]>(\n  config: C,\n  client: AsyncTupleDatabaseClient,\n  filter?: FilterOptions<C, T>\n): Promise<ScanResult<C, T>> {\n  const scanArgs = getScanArgsFromFilter(config, filter);\n  const results = await client.scan(scanArgs);\n\n  return results.map(\n    ({ key, value }) =>\n      ({ namespace: key[0], table: key[1], key: tupleToRecord(key), value } as KeyValue<C, T> & {\n        namespace: C[\"namespace\"];\n        table: T;\n      })\n  );\n}\n\n/**\n * Subscribe to changes in the database\n * @param client AsyncTupleDatabaseClient\n * @param callback Callback to be called when a change occurs\n * @param filter {\n *  table?: Table to subscribe to. If none is given, all tables are subscribed to\n *  key?: Filters to determine key to subscribe to. If none is given, all keys are subscribed to\n * }\n * @returns Function to unsubscribe\n */\nexport async function subscribe<C extends StoreConfig = StoreConfig, T extends keyof C[\"tables\"] = keyof C[\"tables\"]>(\n  config: C,\n  client: AsyncTupleDatabaseClient,\n  callback: SubscriptionCallback<C, T>,\n  filter?: FilterOptions<C, T>\n): Promise<Unsubscribe> {\n  const scanArgs = getScanArgsFromFilter(config, filter);\n\n  return client.subscribe(scanArgs, (write) => {\n    const updates: Record<string, Update> = {};\n\n    // Transform the writes into the expected format\n    for (const update of write.set ?? []) {\n      // The first tuple element is always the table name\n      const [namespace, table] = update.key;\n      if (typeof namespace !== \"string\" || typeof table !== \"string\") {\n        console.warn(\n          \"store-cache: Expected first tuple elements to be namespace and table, ignoring set operation:\",\n          update\n        );\n        continue;\n      }\n\n      // Add the set event to the updates for this table\n      updates[toSelector(namespace, table)] ??= { namespace, table, set: [], remove: [] } satisfies Update;\n      updates[toSelector(namespace, table)].set.push({ key: tupleToRecord(update.key), value: update.value });\n    }\n\n    for (const removedKey of write.remove ?? []) {\n      // The first tuple element is always the table name\n      const [namespace, table] = removedKey;\n      if (typeof namespace !== \"string\" || typeof table !== \"string\") {\n        console.warn(\n          \"store-cache: Expected first tuple elements to be namespace and table, ignoring remove operation:\",\n          removedKey\n        );\n        continue;\n      }\n\n      // Add the remove event to the updates for this table\n      updates[toSelector(namespace, table)] ??= { namespace, table, set: [], remove: [] } satisfies Update;\n      updates[toSelector(namespace, table)].remove.push({ key: tupleToRecord(removedKey) });\n    }\n\n    callback(Object.values(updates) as Update<C, T>[]);\n  });\n}\n\n/**\n * Map a table schema to the corresponding default value\n */\nexport function getDefaultValue<Schema extends Record<string, string>>(schema: Schema): SchemaToPrimitives<Schema> {\n  // Map schema to its default values\n  const defaultValue: Record<string, unknown> = {};\n  for (const key in schema) {\n    defaultValue[key] = getAbiTypeDefaultValue(schema[key]);\n  }\n\n  return defaultValue as SchemaToPrimitives<Schema>;\n}\n\nfunction getScanArgsFromFilter<C extends StoreConfig, T extends keyof C[\"tables\"] = keyof C[\"tables\"]>(\n  config: C,\n  filter?: FilterOptions<C, T>\n): ScanArgs<Tuple, Tuple> {\n  const { table, key } = filter || {};\n  // Default to the config namespace if a filter without namespace is provided\n  const namespace = filter ? filter.namespace ?? config.namespace : undefined;\n\n  const prefix = table != null && namespace != null ? [namespace, table] : undefined;\n  const scanArgs: ScanArgs<Tuple, Tuple> = {};\n\n  // Transform scan args\n  if (table) {\n    scanArgs.gte =\n      key?.gte && recordToTuple(key.gte as Record<string, StaticPrimitiveType>, getKeyOrder(config, table));\n    scanArgs.gt = key?.gt && recordToTuple(key.gt as Record<string, StaticPrimitiveType>, getKeyOrder(config, table));\n    scanArgs.lte =\n      key?.lte && recordToTuple(key.lte as Record<string, StaticPrimitiveType>, getKeyOrder(config, table));\n    scanArgs.lt = key?.lt && recordToTuple(key.lt as Record<string, StaticPrimitiveType>, getKeyOrder(config, table));\n\n    // Override gte and lte if eq is set\n    if (key?.eq) {\n      scanArgs.gte = recordToTuple(key.eq as Record<string, StaticPrimitiveType>, getKeyOrder(config, table));\n      scanArgs.lte = recordToTuple(key.eq as Record<string, StaticPrimitiveType>, getKeyOrder(config, table));\n    }\n  }\n\n  return { prefix, ...scanArgs };\n}\n\n/**\n * Convert a table and key into the corresponding tuple expected by tuple-database\n */\nfunction databaseKey<C extends StoreConfig, T extends keyof C[\"tables\"] = keyof C[\"tables\"]>(\n  config: C,\n  namespace: C[\"namespace\"],\n  table: T & string,\n  key: Key<C, T>\n): Tuple {\n  return [\n    namespace,\n    table,\n    ...recordToTuple(key as Record<string, StaticPrimitiveType>, getKeyOrder(config, table)),\n  ] satisfies Tuple;\n}\n\n/**\n * Get an array corresponding to the keys of the table's key schema\n */\nfunction getKeyOrder(config: StoreConfig, table: string): string[] | undefined {\n  const tableConfig = config.tables[table];\n  return tableConfig ? Object.getOwnPropertyNames(tableConfig.keySchema) : undefined;\n}\n\n/**\n * Convert a record like `{ a: string, b: number }` to a record tuple like `[{ a: string }, { b: number }]`,\n * and sort it based on config's key order, as expected for keys in tuple-database\n */\nfunction recordToTuple(record: Record<string, StaticPrimitiveType>, keyOrder?: string[]): Tuple {\n  const tuple = [];\n  for (const key of keyOrder ?? Object.keys(record)) {\n    tuple.push({ [key]: serializeKey(record[key]) });\n  }\n  return tuple;\n}\n\n/**\n * Convert a record tuple like `[{ a: string }, { b: number }]` to a record like `{ a: string, b: number }`,\n */\nfunction tupleToRecord(tuple: Tuple): Record<string, any> {\n  const record: Record<string, unknown> = {};\n\n  for (const entry of tuple) {\n    // Ignore all non-object tuple values\n    if (entry === null || Array.isArray(entry) || typeof entry !== \"object\") continue;\n    for (const [key, value] of Object.entries(entry)) {\n      record[key] = deserializeKey(value);\n    }\n  }\n\n  return record;\n}\n\n/**\n * Helper to serialize values that are not natively supported in keys by tuple-database.\n * (see https://github.com/ccorcos/tuple-database/issues/25)\n * For now only `bigint` needs serialization.\n */\nfunction serializeKey(key: string | number | bigint | boolean): string | number | boolean {\n  if (typeof key === \"bigint\") return `${key.toString()}n`;\n  return key;\n}\n\n/**\n * Helper to deserialize values that were serialized by `serializeKey` (because they are not natively supported in keys by tuple-database).\n * (see https://github.com/ccorcos/tuple-database/issues/25)\n * For now only `bigint` is serialized and need to be deserialized here.\n */\nfunction deserializeKey(key: string): string | bigint {\n  // Check whether the key matches the mattern `${number}n`\n  // (serialization of bigint in `serializeKey`)\n  // and turn it back into a bigint\n  if (typeof key === \"string\" && /^-?\\d+n$/.test(key)) {\n    return BigInt(key.slice(0, -1));\n  }\n  return key;\n}\n\n/**\n * Helper to concat namespace and table with a separator\n */\nfunction toSelector(namespace: string, table: string): string {\n  return namespace + \"/\" + table;\n}\n"],"mappings":"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","names":["InMemoryTupleStorage","AsyncTupleDatabase","createDatabase","opts","storage","AsyncTupleDatabaseClient","getAbiTypeDefaultValue","set","config","client","namespace","table","key","value","options","keyTuple","databaseKey","currentValue","tx","get","remove","scan","filter","scanArgs","getScanArgsFromFilter","tupleToRecord","subscribe","callback","write","updates","update","toSelector","removedKey","getDefaultValue","schema","defaultValue","prefix","recordToTuple","getKeyOrder","tableConfig","record","keyOrder","tuple","serializeKey","entry","deserializeKey","curry","createDatabaseClient","database","config","_tupleDatabaseClient","AsyncTupleDatabaseClient","namespace","tables","utilsWithClient","set","get","remove","subscribe","scan","table","key","value","options","getDefaultValue","callback","filter"]}