{"version":3,"sources":["../src/abiTypesToSchema.ts","../src/decodeDynamicField.ts","../src/decodeStaticField.ts","../src/errors.ts","../src/decodeField.ts","../src/decodeKeyTuple.ts","../src/decodeRecord.ts","../src/hexToPackedCounter.ts","../src/staticDataLength.ts","../src/encodeField.ts","../src/encodeKeyTuple.ts","../src/encodeRecord.ts","../src/hexToSchema.ts","../src/hexToTableSchema.ts","../src/schemaIndexToAbiType.ts","../src/schemaToHex.ts"],"sourcesContent":["import { DynamicAbiType, SchemaAbiType, StaticAbiType, isDynamicAbiType } from \"@latticexyz/schema-type\";\nimport { Schema } from \"./common\";\n\nexport function abiTypesToSchema(abiTypes: SchemaAbiType[]): Schema {\n  const staticFields: StaticAbiType[] = [];\n  const dynamicFields: DynamicAbiType[] = [];\n  for (const abiType of abiTypes) {\n    if (isDynamicAbiType(abiType)) dynamicFields.push(abiType);\n    else staticFields.push(abiType);\n  }\n  return { staticFields, dynamicFields };\n}\n","import { Hex, hexToString, sliceHex } from \"viem\";\nimport { assertExhaustive } from \"@latticexyz/common/utils\";\nimport {\n  DynamicAbiType,\n  DynamicAbiTypeToPrimitiveType,\n  arrayAbiTypeToStaticAbiType,\n  staticAbiTypeToByteLength,\n} from \"@latticexyz/schema-type\";\nimport { decodeStaticField } from \"./decodeStaticField\";\nimport { InvalidHexLengthError, InvalidHexLengthForArrayFieldError } from \"./errors\";\n\n// TODO: require size/length for dynamic fields, because hex might be longer (sometimes we just move the length pointer of arrays without updating the value)\n//       this means the error should probably change from \"invalid length\" to \"too short\", which viem has that we could reuse?\n\nexport function decodeDynamicField<\n  TAbiType extends DynamicAbiType,\n  TPrimitiveType extends DynamicAbiTypeToPrimitiveType<TAbiType>\n>(abiType: TAbiType, data: Hex): TPrimitiveType {\n  if (abiType === \"bytes\") {\n    return data as TPrimitiveType;\n  }\n  if (abiType === \"string\") {\n    return hexToString(data) as TPrimitiveType;\n  }\n\n  if (data.length > 3 && data.length % 2 !== 0) {\n    throw new InvalidHexLengthError(data);\n  }\n\n  const dataSize = (data.length - 2) / 2;\n\n  switch (abiType) {\n    case \"uint8[]\":\n    case \"uint16[]\":\n    case \"uint24[]\":\n    case \"uint32[]\":\n    case \"uint40[]\":\n    case \"uint48[]\":\n    case \"uint56[]\":\n    case \"uint64[]\":\n    case \"uint72[]\":\n    case \"uint80[]\":\n    case \"uint88[]\":\n    case \"uint96[]\":\n    case \"uint104[]\":\n    case \"uint112[]\":\n    case \"uint120[]\":\n    case \"uint128[]\":\n    case \"uint136[]\":\n    case \"uint144[]\":\n    case \"uint152[]\":\n    case \"uint160[]\":\n    case \"uint168[]\":\n    case \"uint176[]\":\n    case \"uint184[]\":\n    case \"uint192[]\":\n    case \"uint200[]\":\n    case \"uint208[]\":\n    case \"uint216[]\":\n    case \"uint224[]\":\n    case \"uint232[]\":\n    case \"uint240[]\":\n    case \"uint248[]\":\n    case \"uint256[]\":\n    case \"int8[]\":\n    case \"int16[]\":\n    case \"int24[]\":\n    case \"int32[]\":\n    case \"int40[]\":\n    case \"int48[]\":\n    case \"int56[]\":\n    case \"int64[]\":\n    case \"int72[]\":\n    case \"int80[]\":\n    case \"int88[]\":\n    case \"int96[]\":\n    case \"int104[]\":\n    case \"int112[]\":\n    case \"int120[]\":\n    case \"int128[]\":\n    case \"int136[]\":\n    case \"int144[]\":\n    case \"int152[]\":\n    case \"int160[]\":\n    case \"int168[]\":\n    case \"int176[]\":\n    case \"int184[]\":\n    case \"int192[]\":\n    case \"int200[]\":\n    case \"int208[]\":\n    case \"int216[]\":\n    case \"int224[]\":\n    case \"int232[]\":\n    case \"int240[]\":\n    case \"int248[]\":\n    case \"int256[]\":\n    case \"bytes1[]\":\n    case \"bytes2[]\":\n    case \"bytes3[]\":\n    case \"bytes4[]\":\n    case \"bytes5[]\":\n    case \"bytes6[]\":\n    case \"bytes7[]\":\n    case \"bytes8[]\":\n    case \"bytes9[]\":\n    case \"bytes10[]\":\n    case \"bytes11[]\":\n    case \"bytes12[]\":\n    case \"bytes13[]\":\n    case \"bytes14[]\":\n    case \"bytes15[]\":\n    case \"bytes16[]\":\n    case \"bytes17[]\":\n    case \"bytes18[]\":\n    case \"bytes19[]\":\n    case \"bytes20[]\":\n    case \"bytes21[]\":\n    case \"bytes22[]\":\n    case \"bytes23[]\":\n    case \"bytes24[]\":\n    case \"bytes25[]\":\n    case \"bytes26[]\":\n    case \"bytes27[]\":\n    case \"bytes28[]\":\n    case \"bytes29[]\":\n    case \"bytes30[]\":\n    case \"bytes31[]\":\n    case \"bytes32[]\":\n    case \"bool[]\":\n    case \"address[]\": {\n      const staticAbiType = arrayAbiTypeToStaticAbiType(abiType);\n      const itemByteLength = staticAbiTypeToByteLength[staticAbiType];\n      if (dataSize % itemByteLength !== 0) {\n        throw new InvalidHexLengthForArrayFieldError(staticAbiType, data);\n      }\n      const items = new Array(dataSize / itemByteLength).fill(undefined).map((_, i) => {\n        const itemData = sliceHex(data, i * itemByteLength, (i + 1) * itemByteLength);\n        return decodeStaticField(staticAbiType, itemData);\n      });\n      return items as TPrimitiveType;\n    }\n  }\n\n  return assertExhaustive(abiType, `Unsupported dynamic ABI type: ${abiType}`);\n}\n","import { Hex, getAddress, hexToBigInt, hexToBool } from \"viem\";\nimport { assertExhaustive } from \"@latticexyz/common/utils\";\nimport {\n  StaticAbiType,\n  StaticAbiTypeToPrimitiveType,\n  staticAbiTypeToByteLength,\n  staticAbiTypeToDefaultValue,\n} from \"@latticexyz/schema-type\";\nimport { InvalidHexLengthError, InvalidHexLengthForStaticFieldError } from \"./errors\";\n\nexport function decodeStaticField<\n  TAbiType extends StaticAbiType,\n  TPrimitiveType extends StaticAbiTypeToPrimitiveType<TAbiType>\n>(abiType: TAbiType, data: Hex): TPrimitiveType {\n  if (data.length > 3 && data.length % 2 !== 0) {\n    throw new InvalidHexLengthError(data);\n  }\n\n  const dataSize = (data.length - 2) / 2;\n  if (dataSize !== staticAbiTypeToByteLength[abiType]) {\n    throw new InvalidHexLengthForStaticFieldError(abiType, data);\n  }\n\n  switch (abiType) {\n    case \"uint8\":\n    case \"uint16\":\n    case \"uint24\":\n    case \"uint32\":\n    case \"uint40\":\n    case \"uint48\":\n    case \"uint56\":\n    case \"uint64\":\n    case \"uint72\":\n    case \"uint80\":\n    case \"uint88\":\n    case \"uint96\":\n    case \"uint104\":\n    case \"uint112\":\n    case \"uint120\":\n    case \"uint128\":\n    case \"uint136\":\n    case \"uint144\":\n    case \"uint152\":\n    case \"uint160\":\n    case \"uint168\":\n    case \"uint176\":\n    case \"uint184\":\n    case \"uint192\":\n    case \"uint200\":\n    case \"uint208\":\n    case \"uint216\":\n    case \"uint224\":\n    case \"uint232\":\n    case \"uint240\":\n    case \"uint248\":\n    case \"uint256\":\n    case \"int8\":\n    case \"int16\":\n    case \"int24\":\n    case \"int32\":\n    case \"int40\":\n    case \"int48\":\n    case \"int56\":\n    case \"int64\":\n    case \"int72\":\n    case \"int80\":\n    case \"int88\":\n    case \"int96\":\n    case \"int104\":\n    case \"int112\":\n    case \"int120\":\n    case \"int128\":\n    case \"int136\":\n    case \"int144\":\n    case \"int152\":\n    case \"int160\":\n    case \"int168\":\n    case \"int176\":\n    case \"int184\":\n    case \"int192\":\n    case \"int200\":\n    case \"int208\":\n    case \"int216\":\n    case \"int224\":\n    case \"int232\":\n    case \"int240\":\n    case \"int248\":\n    case \"int256\": {\n      const value = hexToBigInt(data, { signed: abiType.startsWith(\"int\") });\n      const defaultValueType = typeof staticAbiTypeToDefaultValue[abiType];\n      if (defaultValueType === \"number\") {\n        return Number(value) as TPrimitiveType;\n      }\n      if (defaultValueType === \"bigint\") {\n        return value as TPrimitiveType;\n      }\n      throw new Error(`Unexpected default value type (${defaultValueType}) for ABI type (${abiType})`);\n    }\n\n    case \"bytes1\":\n    case \"bytes2\":\n    case \"bytes3\":\n    case \"bytes4\":\n    case \"bytes5\":\n    case \"bytes6\":\n    case \"bytes7\":\n    case \"bytes8\":\n    case \"bytes9\":\n    case \"bytes10\":\n    case \"bytes11\":\n    case \"bytes12\":\n    case \"bytes13\":\n    case \"bytes14\":\n    case \"bytes15\":\n    case \"bytes16\":\n    case \"bytes17\":\n    case \"bytes18\":\n    case \"bytes19\":\n    case \"bytes20\":\n    case \"bytes21\":\n    case \"bytes22\":\n    case \"bytes23\":\n    case \"bytes24\":\n    case \"bytes25\":\n    case \"bytes26\":\n    case \"bytes27\":\n    case \"bytes28\":\n    case \"bytes29\":\n    case \"bytes30\":\n    case \"bytes31\":\n    case \"bytes32\": {\n      return data as TPrimitiveType;\n    }\n\n    case \"bool\": {\n      return hexToBool(data) as TPrimitiveType;\n    }\n\n    case \"address\": {\n      return getAddress(data) as TPrimitiveType;\n    }\n  }\n\n  return assertExhaustive(abiType, `Unsupported static ABI type: ${abiType}`);\n}\n","import { Hex } from \"viem\";\nimport { MUDError } from \"@latticexyz/common/errors\";\nimport { StaticAbiType, staticAbiTypeToByteLength } from \"@latticexyz/schema-type\";\n\nexport class InvalidHexLengthError extends MUDError {\n  override name = \"InvalidHexValueError\";\n  constructor(value: Hex) {\n    super(`Hex value \"${value}\" is an odd length (${value.length - 2}). It must be an even length.`);\n  }\n}\n\nexport class InvalidHexLengthForSchemaError extends MUDError {\n  override name = \"InvalidHexLengthForSchemaError\";\n  constructor(value: Hex) {\n    super(`Hex value \"${value}\" has length of ${value.length - 2}, but expected length of 64 for a schema.`);\n  }\n}\n\nexport class InvalidHexLengthForPackedCounterError extends MUDError {\n  override name = \"InvalidHexLengthForPackedCounterError\";\n  constructor(value: Hex) {\n    super(`Hex value \"${value}\" has length of ${value.length - 2}, but expected length of 64 for a packed counter.`);\n  }\n}\n\nexport class InvalidHexLengthForStaticFieldError extends MUDError {\n  override name = \"InvalidHexLengthForStaticFieldError\";\n  constructor(abiType: StaticAbiType, value: Hex) {\n    super(\n      `Hex value \"${value}\" has length of ${value.length - 2}, but expected length of ${\n        staticAbiTypeToByteLength[abiType] * 2\n      } for ${abiType} type.`\n    );\n  }\n}\n\nexport class InvalidHexLengthForArrayFieldError extends MUDError {\n  override name = \"InvalidHexLengthForArrayFieldError\";\n  constructor(abiType: StaticAbiType, value: Hex) {\n    super(\n      `Hex value \"${value}\" has length of ${value.length - 2}, but expected a multiple of ${\n        staticAbiTypeToByteLength[abiType] * 2\n      } for ${abiType}[] type.`\n    );\n  }\n}\n\nexport class SchemaStaticLengthMismatchError extends MUDError {\n  override name = \"SchemaStaticLengthMismatchError\";\n  constructor(schemaData: Hex, definedLength: number, summedLength: number) {\n    super(\n      `Schema \"${schemaData}\" static data length (${definedLength}) did not match the summed length of all static fields (${summedLength}). Is \\`staticAbiTypeToByteLength\\` up to date with Solidity schema types?`\n    );\n  }\n}\n\nexport class PackedCounterLengthMismatchError extends MUDError {\n  override name = \"PackedCounterLengthMismatchError\";\n  constructor(packedCounterData: Hex, definedLength: bigint, summedLength: bigint) {\n    super(\n      `PackedCounter \"${packedCounterData}\" total bytes length (${definedLength}) did not match the summed length of all field byte lengths (${summedLength}).`\n    );\n  }\n}\n","import { Hex } from \"viem\";\nimport { SchemaAbiType, SchemaAbiTypeToPrimitiveType, isDynamicAbiType } from \"@latticexyz/schema-type\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\nimport { decodeStaticField } from \"./decodeStaticField\";\n\nexport function decodeField<\n  TAbiType extends SchemaAbiType,\n  TPrimitiveType extends SchemaAbiTypeToPrimitiveType<TAbiType>\n>(abiType: TAbiType, data: Hex): TPrimitiveType {\n  return (\n    isDynamicAbiType(abiType) ? decodeDynamicField(abiType, data) : decodeStaticField(abiType, data)\n  ) as TPrimitiveType;\n}\n","import { Hex, decodeAbiParameters } from \"viem\";\nimport { StaticPrimitiveType } from \"@latticexyz/schema-type\";\nimport { Schema } from \"./common\";\n\n// key tuples are encoded in the same way as abi.encode, so we can decode them with viem\n\nexport function decodeKeyTuple(keySchema: Schema, keyTuple: readonly Hex[]): StaticPrimitiveType[] {\n  if (keySchema.staticFields.length !== keyTuple.length) {\n    throw new Error(\n      `key tuple length ${keyTuple.length} does not match key schema length ${keySchema.staticFields.length}`\n    );\n  }\n  return keyTuple.map(\n    (key, index) => decodeAbiParameters([{ type: keySchema.staticFields[index] }], key)[0] as StaticPrimitiveType\n  );\n}\n","import {\n  StaticPrimitiveType,\n  DynamicPrimitiveType,\n  staticAbiTypeToByteLength,\n  dynamicAbiTypeToDefaultValue,\n} from \"@latticexyz/schema-type\";\nimport { Hex, sliceHex } from \"viem\";\nimport { Schema } from \"./common\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\nimport { decodeStaticField } from \"./decodeStaticField\";\nimport { hexToPackedCounter } from \"./hexToPackedCounter\";\nimport { staticDataLength } from \"./staticDataLength\";\n\nexport function decodeRecord(schema: Schema, data: Hex): readonly (StaticPrimitiveType | DynamicPrimitiveType)[] {\n  const values: (StaticPrimitiveType | DynamicPrimitiveType)[] = [];\n\n  let bytesOffset = 0;\n  schema.staticFields.forEach((fieldType) => {\n    const fieldByteLength = staticAbiTypeToByteLength[fieldType];\n    const value = decodeStaticField(fieldType, sliceHex(data, bytesOffset, bytesOffset + fieldByteLength));\n    bytesOffset += fieldByteLength;\n    values.push(value);\n  });\n\n  // Warn user if static data length doesn't match the schema, because data corruption might be possible.\n  const schemaStaticDataLength = staticDataLength(schema.staticFields);\n  const actualStaticDataLength = bytesOffset;\n  if (actualStaticDataLength !== schemaStaticDataLength) {\n    console.warn(\n      \"Decoded static data length does not match schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?\",\n      {\n        expectedLength: schemaStaticDataLength,\n        actualLength: actualStaticDataLength,\n        bytesOffset,\n      }\n    );\n  }\n\n  if (schema.dynamicFields.length > 0) {\n    const dataLayout = hexToPackedCounter(sliceHex(data, bytesOffset, bytesOffset + 32));\n    bytesOffset += 32;\n\n    schema.dynamicFields.forEach((fieldType, i) => {\n      const dataLength = dataLayout.fieldByteLengths[i];\n      if (dataLength > 0) {\n        const value = decodeDynamicField(fieldType, sliceHex(data, bytesOffset, bytesOffset + dataLength));\n        bytesOffset += dataLength;\n        values.push(value);\n      } else {\n        values.push(dynamicAbiTypeToDefaultValue[fieldType]);\n      }\n    });\n\n    // Warn user if dynamic data length doesn't match the schema, because data corruption might be possible.\n    const actualDynamicDataLength = bytesOffset - 32 - actualStaticDataLength;\n    // TODO: refactor this so we don't break for bytes offsets >UINT40\n    if (BigInt(actualDynamicDataLength) !== dataLayout.totalByteLength) {\n      console.warn(\n        \"Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?\",\n        {\n          expectedLength: dataLayout.totalByteLength,\n          actualLength: actualDynamicDataLength,\n          bytesOffset,\n        }\n      );\n    }\n  }\n\n  return values;\n}\n","import { Hex, sliceHex } from \"viem\";\nimport { decodeStaticField } from \"./decodeStaticField\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\nimport { InvalidHexLengthForPackedCounterError, PackedCounterLengthMismatchError } from \"./errors\";\n\n// Keep this logic in sync with PackedCounter.sol\n\n// - First 7 bytes (uint56) are used for the total byte length of the dynamic data\n// - The next 5 byte (uint40) sections are used for the byte length of each field, in the same order as the schema's dynamic fields\n\n// We use byte lengths rather than item counts so that, on chain, we can slice without having to get the schema first (and thus the field lengths of each dynamic type)\n\nexport function hexToPackedCounter(data: Hex): {\n  totalByteLength: bigint;\n  fieldByteLengths: readonly number[];\n} {\n  if (data.length !== 66) {\n    throw new InvalidHexLengthForPackedCounterError(data);\n  }\n  const totalByteLength = decodeStaticField(\"uint56\", sliceHex(data, 0, 7));\n\n  // TODO: use schema to make sure we only parse as many as we need (rather than zeroes at the end)?\n  const fieldByteLengths = decodeDynamicField(\"uint40[]\", sliceHex(data, 7));\n\n  const summedLength = BigInt(fieldByteLengths.reduce((total, length) => total + length, 0));\n  if (summedLength !== totalByteLength) {\n    throw new PackedCounterLengthMismatchError(data, totalByteLength, summedLength);\n  }\n\n  return { totalByteLength, fieldByteLengths };\n}\n","import { StaticAbiType, staticAbiTypeToByteLength } from \"@latticexyz/schema-type\";\n\nexport function staticDataLength(staticFields: readonly StaticAbiType[]): number {\n  return staticFields.reduce((length, fieldType) => length + staticAbiTypeToByteLength[fieldType], 0);\n}\n","import { SchemaAbiType, arrayAbiTypeToStaticAbiType, isArrayAbiType } from \"@latticexyz/schema-type\";\nimport { AbiParameterToPrimitiveType } from \"abitype\";\nimport { Hex, encodePacked } from \"viem\";\n\nexport function encodeField<TSchemaAbiType extends SchemaAbiType>(\n  fieldType: TSchemaAbiType,\n  value: AbiParameterToPrimitiveType<{ type: TSchemaAbiType }>\n): Hex {\n  if (isArrayAbiType(fieldType) && Array.isArray(value)) {\n    const staticFieldType = arrayAbiTypeToStaticAbiType(fieldType);\n    return encodePacked(\n      value.map(() => staticFieldType),\n      value\n    );\n  }\n  return encodePacked([fieldType], [value]);\n}\n","import { StaticPrimitiveType } from \"@latticexyz/schema-type\";\nimport { Hex, encodeAbiParameters } from \"viem\";\nimport { Schema } from \"./common\";\n\nexport function encodeKeyTuple(keySchema: Schema, keyTuple: StaticPrimitiveType[]): Hex[] {\n  return keyTuple.map((key, index) => encodeAbiParameters([{ type: keySchema.staticFields[index] }], [key]));\n}\n","import { StaticPrimitiveType, DynamicPrimitiveType } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { encodeField } from \"./encodeField\";\nimport { Schema } from \"./common\";\n\nexport function encodeRecord(schema: Schema, values: readonly (StaticPrimitiveType | DynamicPrimitiveType)[]): Hex {\n  const staticValues = values.slice(0, schema.staticFields.length) as readonly StaticPrimitiveType[];\n  const dynamicValues = values.slice(schema.staticFields.length) as readonly DynamicPrimitiveType[];\n\n  const staticData = staticValues\n    .map((value, i) => encodeField(schema.staticFields[i], value).replace(/^0x/, \"\"))\n    .join(\"\");\n\n  if (schema.dynamicFields.length === 0) return `0x${staticData}`;\n\n  const dynamicDataItems = dynamicValues.map((value, i) =>\n    encodeField(schema.dynamicFields[i], value).replace(/^0x/, \"\")\n  );\n\n  const dynamicFieldByteLengths = dynamicDataItems.map((value) => value.length / 2);\n  const dynamicTotalByteLength = dynamicFieldByteLengths.reduce((total, length) => total + BigInt(length), 0n);\n\n  const dynamicData = dynamicDataItems.join(\"\");\n\n  const packedCounter = `${encodeField(\"uint56\", dynamicTotalByteLength).replace(/^0x/, \"\")}${dynamicFieldByteLengths\n    .map((length) => encodeField(\"uint40\", length).replace(/^0x/, \"\"))\n    .join(\"\")}`.padEnd(64, \"0\");\n\n  return `0x${staticData}${packedCounter}${dynamicData}`;\n}\n","import { StaticAbiType, DynamicAbiType, schemaAbiTypes, staticAbiTypeToByteLength } from \"@latticexyz/schema-type\";\nimport { Hex, hexToNumber, sliceHex } from \"viem\";\nimport { Schema } from \"./common\";\nimport { InvalidHexLengthForSchemaError, SchemaStaticLengthMismatchError } from \"./errors\";\n\nexport function hexToSchema(data: Hex): Schema {\n  if (data.length !== 66) {\n    throw new InvalidHexLengthForSchemaError(data);\n  }\n\n  const staticDataLength = hexToNumber(sliceHex(data, 0, 2));\n  const numStaticFields = hexToNumber(sliceHex(data, 2, 3));\n  const numDynamicFields = hexToNumber(sliceHex(data, 3, 4));\n  const staticFields: StaticAbiType[] = [];\n  const dynamicFields: DynamicAbiType[] = [];\n\n  for (let i = 4; i < 4 + numStaticFields; i++) {\n    const schemaTypeIndex = hexToNumber(sliceHex(data, i, i + 1));\n    staticFields.push(schemaAbiTypes[schemaTypeIndex] as StaticAbiType);\n  }\n  for (let i = 4 + numStaticFields; i < 4 + numStaticFields + numDynamicFields; i++) {\n    const schemaTypeIndex = hexToNumber(sliceHex(data, i, i + 1));\n    dynamicFields.push(schemaAbiTypes[schemaTypeIndex] as DynamicAbiType);\n  }\n\n  // validate static data length\n  const actualStaticDataLength = staticFields.reduce((acc, fieldType) => acc + staticAbiTypeToByteLength[fieldType], 0);\n  if (actualStaticDataLength !== staticDataLength) {\n    console.warn(\n      `Schema \"${data}\" static data length (${staticDataLength}) did not match the summed length of all static fields (${actualStaticDataLength}). Is \\`staticAbiTypeToByteLength\\` up to date with Solidity schema types?`\n    );\n    throw new SchemaStaticLengthMismatchError(data, staticDataLength, actualStaticDataLength);\n  }\n\n  return { staticFields, dynamicFields };\n}\n","import { Hex, sliceHex } from \"viem\";\nimport { TableSchema } from \"./common\";\nimport { hexToSchema } from \"./hexToSchema\";\n\nexport function hexToTableSchema(data: Hex): TableSchema {\n  const valueSchema = hexToSchema(sliceHex(data, 0, 32));\n  const keySchema = hexToSchema(sliceHex(data, 32, 64));\n  return {\n    keySchema,\n    valueSchema,\n  };\n}\n","import { SchemaAbiType } from \"@latticexyz/schema-type\";\nimport { Schema } from \"./common\";\n\nexport function schemaIndexToAbiType(schema: Schema, schemaIndex: number): SchemaAbiType {\n  if (schemaIndex < schema.staticFields.length) {\n    return schema.staticFields[schemaIndex];\n  }\n  return schema.dynamicFields[schemaIndex - schema.staticFields.length];\n}\n","import { schemaAbiTypes } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { Schema } from \"./common\";\nimport { staticDataLength } from \"./staticDataLength\";\n\nexport function schemaToHex(schema: Schema): Hex {\n  const staticSchemaTypes = schema.staticFields.map((abiType) => schemaAbiTypes.indexOf(abiType));\n  const dynamicSchemaTypes = schema.dynamicFields.map((abiType) => schemaAbiTypes.indexOf(abiType));\n  return `0x${[\n    staticDataLength(schema.staticFields).toString(16).padStart(4, \"0\"),\n    schema.staticFields.length.toString(16).padStart(2, \"0\"),\n    schema.dynamicFields.length.toString(16).padStart(2, \"0\"),\n    ...staticSchemaTypes.map((schemaType) => schemaType.toString(16).padStart(2, \"0\")),\n    ...dynamicSchemaTypes.map((schemaType) => schemaType.toString(16).padStart(2, \"0\")),\n  ]\n    .join(\"\")\n    .padEnd(64, \"0\")}`;\n}\n"],"mappings":"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","names":["isDynamicAbiType","abiTypesToSchema","abiTypes","staticFields","dynamicFields","abiType","hexToString","sliceHex","assertExhaustive","arrayAbiTypeToStaticAbiType","staticAbiTypeToByteLength","getAddress","hexToBigInt","hexToBool","assertExhaustive","staticAbiTypeToByteLength","staticAbiTypeToDefaultValue","MUDError","staticAbiTypeToByteLength","InvalidHexLengthError","value","InvalidHexLengthForSchemaError","InvalidHexLengthForPackedCounterError","InvalidHexLengthForStaticFieldError","abiType","InvalidHexLengthForArrayFieldError","SchemaStaticLengthMismatchError","schemaData","definedLength","summedLength","PackedCounterLengthMismatchError","packedCounterData","decodeStaticField","abiType","data","InvalidHexLengthError","staticAbiTypeToByteLength","InvalidHexLengthForStaticFieldError","value","hexToBigInt","defaultValueType","staticAbiTypeToDefaultValue","hexToBool","getAddress","assertExhaustive","decodeDynamicField","abiType","data","hexToString","InvalidHexLengthError","dataSize","staticAbiType","arrayAbiTypeToStaticAbiType","itemByteLength","staticAbiTypeToByteLength","InvalidHexLengthForArrayFieldError","_","i","itemData","sliceHex","decodeStaticField","assertExhaustive","isDynamicAbiType","decodeField","abiType","data","isDynamicAbiType","decodeDynamicField","decodeStaticField","decodeAbiParameters","decodeKeyTuple","keySchema","keyTuple","key","index","staticAbiTypeToByteLength","dynamicAbiTypeToDefaultValue","sliceHex","sliceHex","hexToPackedCounter","data","InvalidHexLengthForPackedCounterError","totalByteLength","decodeStaticField","sliceHex","fieldByteLengths","decodeDynamicField","summedLength","total","length","PackedCounterLengthMismatchError","staticAbiTypeToByteLength","staticDataLength","staticFields","length","fieldType","decodeRecord","schema","data","values","bytesOffset","fieldType","fieldByteLength","staticAbiTypeToByteLength","value","decodeStaticField","sliceHex","schemaStaticDataLength","staticDataLength","actualStaticDataLength","dataLayout","hexToPackedCounter","i","dataLength","decodeDynamicField","dynamicAbiTypeToDefaultValue","actualDynamicDataLength","arrayAbiTypeToStaticAbiType","isArrayAbiType","encodePacked","encodeField","fieldType","value","staticFieldType","encodeAbiParameters","encodeKeyTuple","keySchema","keyTuple","key","index","encodeRecord","schema","values","staticValues","dynamicValues","staticData","value","i","encodeField","dynamicDataItems","dynamicFieldByteLengths","dynamicTotalByteLength","total","length","dynamicData","packedCounter","schemaAbiTypes","staticAbiTypeToByteLength","hexToNumber","sliceHex","hexToSchema","data","InvalidHexLengthForSchemaError","staticDataLength","hexToNumber","sliceHex","numStaticFields","numDynamicFields","staticFields","dynamicFields","i","schemaTypeIndex","schemaAbiTypes","actualStaticDataLength","acc","fieldType","staticAbiTypeToByteLength","SchemaStaticLengthMismatchError","sliceHex","hexToTableSchema","data","valueSchema","hexToSchema","sliceHex","schemaIndexToAbiType","schema","schemaIndex","schemaAbiTypes","schemaToHex","schema","staticSchemaTypes","abiType","schemaAbiTypes","dynamicSchemaTypes","staticDataLength","schemaType"]}