import{isDynamicAbiType as C}from"@latticexyz/schema-type";function ne(e){let t=[],c=[];for(let i of e)C(i)?c.push(i):t.push(i);return{staticFields:t,dynamicFields:c}}import{hexToString as K,sliceHex as N}from"viem";import{assertExhaustive as R}from"@latticexyz/common/utils";import{arrayAbiTypeToStaticAbiType as W,staticAbiTypeToByteLength as _}from"@latticexyz/schema-type";import{getAddress as V,hexToBigInt as j,hexToBool as U}from"viem";import{assertExhaustive as z}from"@latticexyz/common/utils";import{staticAbiTypeToByteLength as M,staticAbiTypeToDefaultValue as O}from"@latticexyz/schema-type";import{MUDError as u}from"@latticexyz/common/errors";import{staticAbiTypeToByteLength as L}from"@latticexyz/schema-type";var d=class extends u{name="InvalidHexValueError";constructor(t){super(`Hex value "${t}" is an odd length (${t.length-2}). It must be an even length.`)}},f=class extends u{name="InvalidHexLengthForSchemaError";constructor(t){super(`Hex value "${t}" has length of ${t.length-2}, but expected length of 64 for a schema.`)}},x=class extends u{name="InvalidHexLengthForPackedCounterError";constructor(t){super(`Hex value "${t}" has length of ${t.length-2}, but expected length of 64 for a packed counter.`)}},g=class extends u{name="InvalidHexLengthForStaticFieldError";constructor(t,c){super(`Hex value "${c}" has length of ${c.length-2}, but expected length of ${L[t]*2} for ${t} type.`)}},S=class extends u{name="InvalidHexLengthForArrayFieldError";constructor(t,c){super(`Hex value "${c}" has length of ${c.length-2}, but expected a multiple of ${L[t]*2} for ${t}[] type.`)}},A=class extends u{name="SchemaStaticLengthMismatchError";constructor(t,c,i){super(`Schema "${t}" static data length (${c}) did not match the summed length of all static fields (${i}). Is \`staticAbiTypeToByteLength\` up to date with Solidity schema types?`)}},v=class extends u{name="PackedCounterLengthMismatchError";constructor(t,c,i){super(`PackedCounter "${t}" total bytes length (${c}) did not match the summed length of all field byte lengths (${i}).`)}};function p(e,t){if(t.length>3&&t.length%2!==0)throw new d(t);if((t.length-2)/2!==M[e])throw new g(e,t);switch(e){case"uint8":case"uint16":case"uint24":case"uint32":case"uint40":case"uint48":case"uint56":case"uint64":case"uint72":case"uint80":case"uint88":case"uint96":case"uint104":case"uint112":case"uint120":case"uint128":case"uint136":case"uint144":case"uint152":case"uint160":case"uint168":case"uint176":case"uint184":case"uint192":case"uint200":case"uint208":case"uint216":case"uint224":case"uint232":case"uint240":case"uint248":case"uint256":case"int8":case"int16":case"int24":case"int32":case"int40":case"int48":case"int56":case"int64":case"int72":case"int80":case"int88":case"int96":case"int104":case"int112":case"int120":case"int128":case"int136":case"int144":case"int152":case"int160":case"int168":case"int176":case"int184":case"int192":case"int200":case"int208":case"int216":case"int224":case"int232":case"int240":case"int248":case"int256":{let i=j(t,{signed:e.startsWith("int")}),a=typeof O[e];if(a==="number")return Number(i);if(a==="bigint")return i;throw new Error(`Unexpected default value type (${a}) for ABI type (${e})`)}case"bytes1":case"bytes2":case"bytes3":case"bytes4":case"bytes5":case"bytes6":case"bytes7":case"bytes8":case"bytes9":case"bytes10":case"bytes11":case"bytes12":case"bytes13":case"bytes14":case"bytes15":case"bytes16":case"bytes17":case"bytes18":case"bytes19":case"bytes20":case"bytes21":case"bytes22":case"bytes23":case"bytes24":case"bytes25":case"bytes26":case"bytes27":case"bytes28":case"bytes29":case"bytes30":case"bytes31":case"bytes32":return t;case"bool":return U(t);case"address":return V(t)}return z(e,`Unsupported static ABI type: ${e}`)}function h(e,t){if(e==="bytes")return t;if(e==="string")return K(t);if(t.length>3&&t.length%2!==0)throw new d(t);let c=(t.length-2)/2;switch(e){case"uint8[]":case"uint16[]":case"uint24[]":case"uint32[]":case"uint40[]":case"uint48[]":case"uint56[]":case"uint64[]":case"uint72[]":case"uint80[]":case"uint88[]":case"uint96[]":case"uint104[]":case"uint112[]":case"uint120[]":case"uint128[]":case"uint136[]":case"uint144[]":case"uint152[]":case"uint160[]":case"uint168[]":case"uint176[]":case"uint184[]":case"uint192[]":case"uint200[]":case"uint208[]":case"uint216[]":case"uint224[]":case"uint232[]":case"uint240[]":case"uint248[]":case"uint256[]":case"int8[]":case"int16[]":case"int24[]":case"int32[]":case"int40[]":case"int48[]":case"int56[]":case"int64[]":case"int72[]":case"int80[]":case"int88[]":case"int96[]":case"int104[]":case"int112[]":case"int120[]":case"int128[]":case"int136[]":case"int144[]":case"int152[]":case"int160[]":case"int168[]":case"int176[]":case"int184[]":case"int192[]":case"int200[]":case"int208[]":case"int216[]":case"int224[]":case"int232[]":case"int240[]":case"int248[]":case"int256[]":case"bytes1[]":case"bytes2[]":case"bytes3[]":case"bytes4[]":case"bytes5[]":case"bytes6[]":case"bytes7[]":case"bytes8[]":case"bytes9[]":case"bytes10[]":case"bytes11[]":case"bytes12[]":case"bytes13[]":case"bytes14[]":case"bytes15[]":case"bytes16[]":case"bytes17[]":case"bytes18[]":case"bytes19[]":case"bytes20[]":case"bytes21[]":case"bytes22[]":case"bytes23[]":case"bytes24[]":case"bytes25[]":case"bytes26[]":case"bytes27[]":case"bytes28[]":case"bytes29[]":case"bytes30[]":case"bytes31[]":case"bytes32[]":case"bool[]":case"address[]":{let i=W(e),a=_[i];if(c%a!==0)throw new S(i,t);return new Array(c/a).fill(void 0).map((n,s)=>{let r=N(t,s*a,(s+1)*a);return p(i,r)})}}return R(e,`Unsupported dynamic ABI type: ${e}`)}import{isDynamicAbiType as q}from"@latticexyz/schema-type";function ke(e,t){return q(e)?h(e,t):p(e,t)}import{decodeAbiParameters as G}from"viem";function Ue(e,t){if(e.staticFields.length!==t.length)throw new Error(`key tuple length ${t.length} does not match key schema length ${e.staticFields.length}`);return t.map((c,i)=>G([{type:e.staticFields[i]}],c)[0])}import{staticAbiTypeToByteLength as Q,dynamicAbiTypeToDefaultValue as X}from"@latticexyz/schema-type";import{sliceHex as F}from"viem";import{sliceHex as $}from"viem";function w(e){if(e.length!==66)throw new x(e);let t=p("uint56",$(e,0,7)),c=h("uint40[]",$(e,7)),i=BigInt(c.reduce((a,m)=>a+m,0));if(i!==t)throw new v(e,t,i);return{totalByteLength:t,fieldByteLengths:c}}import{staticAbiTypeToByteLength as J}from"@latticexyz/schema-type";function P(e){return e.reduce((t,c)=>t+J[c],0)}function st(e,t){let c=[],i=0;e.staticFields.forEach(n=>{let s=Q[n],r=p(n,F(t,i,i+s));i+=s,c.push(r)});let a=P(e.staticFields),m=i;if(m!==a&&console.warn("Decoded static data length does not match schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?",{expectedLength:a,actualLength:m,bytesOffset:i}),e.dynamicFields.length>0){let n=w(F(t,i,i+32));i+=32,e.dynamicFields.forEach((r,H)=>{let o=n.fieldByteLengths[H];if(o>0){let y=h(r,F(t,i,i+o));i+=o,c.push(y)}else c.push(X[r])});let s=i-32-m;BigInt(s)!==n.totalByteLength&&console.warn("Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?",{expectedLength:n.totalByteLength,actualLength:s,bytesOffset:i})}return c}import{arrayAbiTypeToStaticAbiType as Y,isArrayAbiType as Z}from"@latticexyz/schema-type";import{encodePacked as B}from"viem";function l(e,t){if(Z(e)&&Array.isArray(t)){let c=Y(e);return B(t.map(()=>c),t)}return B([e],[t])}import{encodeAbiParameters as ee}from"viem";function dt(e,t){return t.map((c,i)=>ee([{type:e.staticFields[i]}],[c]))}function Tt(e,t){let c=t.slice(0,e.staticFields.length),i=t.slice(e.staticFields.length),a=c.map((o,y)=>l(e.staticFields[y],o).replace(/^0x/,"")).join("");if(e.dynamicFields.length===0)return`0x${a}`;let m=i.map((o,y)=>l(e.dynamicFields[y],o).replace(/^0x/,"")),n=m.map(o=>o.length/2),s=n.reduce((o,y)=>o+BigInt(y),0n),r=m.join(""),H=`${l("uint56",s).replace(/^0x/,"")}${n.map(o=>l("uint40",o).replace(/^0x/,"")).join("")}`.padEnd(64,"0");return`0x${a}${H}${r}`}import{schemaAbiTypes as I,staticAbiTypeToByteLength as te}from"@latticexyz/schema-type";import{hexToNumber as T,sliceHex as b}from"viem";function D(e){if(e.length!==66)throw new f(e);let t=T(b(e,0,2)),c=T(b(e,2,3)),i=T(b(e,3,4)),a=[],m=[];for(let s=4;s<4+c;s++){let r=T(b(e,s,s+1));a.push(I[r])}for(let s=4+c;s<4+c+i;s++){let r=T(b(e,s,s+1));m.push(I[r])}let n=a.reduce((s,r)=>s+te[r],0);if(n!==t)throw console.warn(`Schema "${e}" static data length (${t}) did not match the summed length of all static fields (${n}). Is \`staticAbiTypeToByteLength\` up to date with Solidity schema types?`),new A(e,t,n);return{staticFields:a,dynamicFields:m}}import{sliceHex as E}from"viem";function Lt(e){let t=D(E(e,0,32));return{keySchema:D(E(e,32,64)),valueSchema:t}}function wt(e,t){return t<e.staticFields.length?e.staticFields[t]:e.dynamicFields[t-e.staticFields.length]}import{schemaAbiTypes as k}from"@latticexyz/schema-type";function kt(e){let t=e.staticFields.map(i=>k.indexOf(i)),c=e.dynamicFields.map(i=>k.indexOf(i));return`0x${[P(e.staticFields).toString(16).padStart(4,"0"),e.staticFields.length.toString(16).padStart(2,"0"),e.dynamicFields.length.toString(16).padStart(2,"0"),...t.map(i=>i.toString(16).padStart(2,"0")),...c.map(i=>i.toString(16).padStart(2,"0"))].join("").padEnd(64,"0")}`}export{d as InvalidHexLengthError,S as InvalidHexLengthForArrayFieldError,x as InvalidHexLengthForPackedCounterError,f as InvalidHexLengthForSchemaError,g as InvalidHexLengthForStaticFieldError,v as PackedCounterLengthMismatchError,A as SchemaStaticLengthMismatchError,ne as abiTypesToSchema,h as decodeDynamicField,ke as decodeField,Ue as decodeKeyTuple,st as decodeRecord,p as decodeStaticField,l as encodeField,dt as encodeKeyTuple,Tt as encodeRecord,w as hexToPackedCounter,D as hexToSchema,Lt as hexToTableSchema,wt as schemaIndexToAbiType,kt as schemaToHex,P as staticDataLength};
//# sourceMappingURL=index.js.map