{"version":3,"sources":["../src/utils/deployHandler.ts","../src/utils/deploy.ts","../src/utils/getChainId.ts","../src/utils/getExistingContracts.ts"],"sourcesContent":["import chalk from \"chalk\";\nimport path from \"path\";\nimport { MUDError } from \"@latticexyz/common/errors\";\nimport { loadConfig } from \"@latticexyz/config/node\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { WorldConfig } from \"@latticexyz/world\";\nimport { deploy } from \"../utils/deploy\";\nimport { forge, getRpcUrl, getSrcDirectory } from \"@latticexyz/common/foundry\";\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from \"fs\";\nimport { getChainId } from \"../utils/getChainId\";\nimport { getExistingContracts } from \"./getExistingContracts\";\n\nexport type DeployOptions = {\n  configPath?: string;\n  printConfig?: boolean;\n  profile?: string;\n  priorityFeeMultiplier: number;\n  clean?: boolean;\n  debug?: boolean;\n  saveDeployment: boolean;\n  rpc?: string;\n  worldAddress?: string;\n  srcDir?: string;\n  disableTxWait: boolean;\n  pollInterval: number;\n  skipBuild?: boolean;\n};\n\nexport async function deployHandler(args: DeployOptions) {\n  args.profile ??= process.env.FOUNDRY_PROFILE;\n  const { configPath, printConfig, profile, clean, skipBuild } = args;\n\n  const rpc = args.rpc ?? (await getRpcUrl(profile));\n  console.log(\n    chalk.bgBlue(\n      chalk.whiteBright(`\\n Deploying MUD contracts${profile ? \" with profile \" + profile : \"\"} to RPC ${rpc} \\n`)\n    )\n  );\n\n  if (clean) await forge([\"clean\"], { profile });\n\n  // Run forge build\n  if (!skipBuild) await forge([\"build\"], { profile });\n\n  // Get a list of all contract names\n  const srcDir = args?.srcDir ?? (await getSrcDirectory());\n  const existingContractNames = getExistingContracts(srcDir).map(({ basename }) => basename);\n\n  // Load the config\n  const mudConfig = (await loadConfig(configPath)) as StoreConfig & WorldConfig;\n\n  if (printConfig) console.log(chalk.green(\"\\nResolved config:\\n\"), JSON.stringify(mudConfig, null, 2));\n\n  const privateKey = process.env.PRIVATE_KEY;\n  if (!privateKey)\n    throw new MUDError(\n      `Missing PRIVATE_KEY environment variable.\nRun 'echo \"PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\" > .env'\nin your contracts directory to use the default anvil private key.`\n    );\n  const deploymentInfo = await deploy(mudConfig, existingContractNames, { ...args, rpc, privateKey });\n\n  if (args.saveDeployment) {\n    // Write deployment result to file (latest and timestamp)\n    const chainId = await getChainId(rpc);\n    const outputDir = path.join(mudConfig.deploysDirectory, chainId.toString());\n    mkdirSync(outputDir, { recursive: true });\n    writeFileSync(path.join(outputDir, \"latest.json\"), JSON.stringify(deploymentInfo, null, 2));\n    writeFileSync(path.join(outputDir, Date.now() + \".json\"), JSON.stringify(deploymentInfo, null, 2));\n\n    const localChains = [1337, 31337];\n    const deploys = existsSync(mudConfig.worldsFile) ? JSON.parse(readFileSync(mudConfig.worldsFile, \"utf-8\")) : {};\n    deploys[chainId] = {\n      address: deploymentInfo.worldAddress,\n      // We expect the worlds file to be committed and since local deployments are often a consistent address but different block number, we'll ignore the block number.\n      blockNumber: localChains.includes(chainId) ? undefined : deploymentInfo.blockNumber,\n    };\n    writeFileSync(mudConfig.worldsFile, JSON.stringify(deploys, null, 2));\n\n    console.log(\n      chalk.bgGreen(chalk.whiteBright(`\\n Deployment result (written to ${mudConfig.worldsFile} and ${outputDir}): \\n`))\n    );\n  }\n\n  console.log(deploymentInfo);\n  return deploymentInfo;\n}\n","import { existsSync, readFileSync } from \"fs\";\nimport path from \"path\";\nimport chalk from \"chalk\";\nimport { BigNumber, ContractInterface, ethers } from \"ethers\";\nimport { defaultAbiCoder as abi, Fragment, ParamType } from \"ethers/lib/utils.js\";\n\nimport { getOutDirectory, getScriptDirectory, cast, forge } from \"@latticexyz/common/foundry\";\nimport { resolveWithContext } from \"@latticexyz/config\";\nimport { MUDError } from \"@latticexyz/common/errors\";\nimport { encodeSchema } from \"@latticexyz/schema-type/deprecated\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { resolveAbiOrUserType } from \"@latticexyz/store/codegen\";\nimport { WorldConfig, resolveWorldConfig } from \"@latticexyz/world\";\nimport { IBaseWorld } from \"@latticexyz/world/types/ethers-contracts/IBaseWorld\";\nimport WorldData from \"@latticexyz/world/abi/World.sol/World.json\" assert { type: \"json\" };\nimport IBaseWorldData from \"@latticexyz/world/abi/IBaseWorld.sol/IBaseWorld.json\" assert { type: \"json\" };\nimport CoreModuleData from \"@latticexyz/world/abi/CoreModule.sol/CoreModule.json\" assert { type: \"json\" };\nimport KeysWithValueModuleData from \"@latticexyz/world/abi/KeysWithValueModule.sol/KeysWithValueModule.json\" assert { type: \"json\" };\nimport KeysInTableModuleData from \"@latticexyz/world/abi/KeysInTableModule.sol/KeysInTableModule.json\" assert { type: \"json\" };\nimport UniqueEntityModuleData from \"@latticexyz/world/abi/UniqueEntityModule.sol/UniqueEntityModule.json\" assert { type: \"json\" };\nimport SnapSyncModuleData from \"@latticexyz/world/abi/SnapSyncModule.sol/SnapSyncModule.json\" assert { type: \"json\" };\n\nexport interface DeployConfig {\n  profile?: string;\n  rpc: string;\n  privateKey: string;\n  priorityFeeMultiplier: number;\n  debug?: boolean;\n  worldAddress?: string;\n  disableTxWait: boolean;\n  pollInterval: number;\n}\n\nexport interface DeploymentInfo {\n  blockNumber: number;\n  worldAddress: string;\n}\n\nexport async function deploy(\n  mudConfig: StoreConfig & WorldConfig,\n  existingContractNames: string[],\n  deployConfig: DeployConfig\n): Promise<DeploymentInfo> {\n  const resolvedConfig = resolveWorldConfig(mudConfig, existingContractNames);\n\n  const startTime = Date.now();\n  const { worldContractName, namespace, postDeployScript } = mudConfig;\n  const { profile, rpc, privateKey, priorityFeeMultiplier, debug, worldAddress, disableTxWait, pollInterval } =\n    deployConfig;\n  const forgeOutDirectory = await getOutDirectory(profile);\n\n  // Set up signer for deployment\n  const provider = new ethers.providers.StaticJsonRpcProvider(rpc);\n  provider.pollingInterval = pollInterval;\n  const signer = new ethers.Wallet(privateKey, provider);\n  console.log(\"Deploying from\", signer.address);\n\n  // Manual nonce handling to allow for faster sending of transactions without waiting for previous transactions\n  let nonce = await signer.getTransactionCount();\n  console.log(\"Initial nonce\", nonce);\n\n  // Compute maxFeePerGas and maxPriorityFeePerGas like ethers, but allow for a multiplier to allow replacing pending transactions\n  let maxPriorityFeePerGas: number | undefined;\n  let maxFeePerGas: BigNumber | undefined;\n  let gasPrice: BigNumber | undefined;\n\n  await setInternalFeePerGas(priorityFeeMultiplier);\n\n  // Catch all to await any promises before exiting the script\n  let promises: Promise<unknown>[] = [];\n\n  // Get block number before deploying\n  const blockNumber = Number(await cast([\"block-number\", \"--rpc-url\", rpc], { profile }));\n  console.log(\"Start deployment at block\", blockNumber);\n\n  // Deploy World\n  const worldPromise = {\n    World: worldAddress\n      ? Promise.resolve(worldAddress)\n      : worldContractName\n      ? deployContractByName(worldContractName, disableTxWait)\n      : deployContract(IBaseWorldData.abi, WorldData.bytecode, disableTxWait, \"World\"),\n  };\n\n  // Deploy Systems\n  const systemPromises = Object.keys(resolvedConfig.systems).reduce<Record<string, Promise<string>>>(\n    (acc, systemName) => {\n      acc[systemName] = deployContractByName(systemName, disableTxWait);\n      return acc;\n    },\n    {}\n  );\n\n  // Deploy default World modules\n  const defaultModules: Record<string, Promise<string>> = {\n    // TODO: these only need to be deployed once per chain, add a check if they exist already\n    CoreModule: deployContract(CoreModuleData.abi, CoreModuleData.bytecode, disableTxWait, \"CoreModule\"),\n    KeysWithValueModule: deployContract(\n      KeysWithValueModuleData.abi,\n      KeysWithValueModuleData.bytecode,\n      disableTxWait,\n      \"KeysWithValueModule\"\n    ),\n    KeysInTableModule: deployContract(\n      KeysInTableModuleData.abi,\n      KeysInTableModuleData.bytecode,\n      disableTxWait,\n      \"KeysInTableModule\"\n    ),\n    UniqueEntityModule: deployContract(\n      UniqueEntityModuleData.abi,\n      UniqueEntityModuleData.bytecode,\n      disableTxWait,\n      \"UniqueEntityModule\"\n    ),\n    SnapSyncModule: deployContract(\n      SnapSyncModuleData.abi,\n      SnapSyncModuleData.bytecode,\n      disableTxWait,\n      \"SnapSyncModule\"\n    ),\n  };\n\n  // Deploy user Modules\n  const modulePromises = mudConfig.modules\n    .filter((module) => !defaultModules[module.name]) // Only deploy user modules here, not default modules\n    .reduce<Record<string, Promise<string>>>((acc, module) => {\n      acc[module.name] = deployContractByName(module.name, disableTxWait);\n      return acc;\n    }, defaultModules);\n\n  // Combine all contracts into one object\n  const contractPromises: Record<string, Promise<string>> = { ...worldPromise, ...systemPromises, ...modulePromises };\n\n  // Create World contract instance from deployed address\n  const WorldContract = new ethers.Contract(await contractPromises.World, IBaseWorldData.abi, signer) as IBaseWorld;\n\n  const confirmations = disableTxWait ? 0 : 1;\n\n  // Install core Modules\n  if (!worldAddress) {\n    console.log(chalk.blue(\"Installing core World modules\"));\n    await fastTxExecute(WorldContract, \"installRootModule\", [await modulePromises.CoreModule, \"0x\"], confirmations);\n    console.log(chalk.green(\"Installed core World modules\"));\n  }\n\n  // Register namespace\n  if (namespace) await fastTxExecute(WorldContract, \"registerNamespace\", [toBytes16(namespace)], confirmations);\n\n  // Register tables\n  const tableIds: { [tableName: string]: Uint8Array } = {};\n  promises = [\n    ...promises,\n    ...Object.entries(mudConfig.tables).map(async ([tableName, { name, schema, keySchema }]) => {\n      console.log(chalk.blue(`Registering table ${tableName} at ${namespace}/${name}`));\n\n      // Store the tableId for later use\n      tableIds[tableName] = toResourceSelector(namespace, name);\n\n      // Register table\n      const schemaTypes = Object.values(schema).map((abiOrUserType) => {\n        const { schemaType } = resolveAbiOrUserType(abiOrUserType, mudConfig);\n        return schemaType;\n      });\n\n      const keyTypes = Object.values(keySchema).map((abiOrUserType) => {\n        const { schemaType } = resolveAbiOrUserType(abiOrUserType, mudConfig);\n        return schemaType;\n      });\n\n      await fastTxExecute(\n        WorldContract,\n        \"registerTable\",\n        [toBytes16(namespace), toBytes16(name), encodeSchema(schemaTypes), encodeSchema(keyTypes)],\n        confirmations\n      );\n\n      // Register table metadata\n      await fastTxExecute(\n        WorldContract,\n        \"setMetadata(bytes16,bytes16,string,string[])\",\n        [toBytes16(namespace), toBytes16(name), tableName, Object.keys(schema)],\n        confirmations\n      );\n\n      console.log(chalk.green(`Registered table ${tableName} at ${name}`));\n    }),\n  ];\n\n  // Register systems (using forEach instead of for..of to avoid blocking on async calls)\n  promises = [\n    ...promises,\n    ...Object.entries(resolvedConfig.systems).map(\n      async ([systemName, { name, openAccess, registerFunctionSelectors }]) => {\n        // Register system at route\n        console.log(chalk.blue(`Registering system ${systemName} at ${namespace}/${name}`));\n        await fastTxExecute(\n          WorldContract,\n          \"registerSystem\",\n          [toBytes16(namespace), toBytes16(name), await contractPromises[systemName], openAccess],\n          confirmations\n        );\n        console.log(chalk.green(`Registered system ${systemName} at ${namespace}/${name}`));\n\n        // Register function selectors for the system\n        if (registerFunctionSelectors) {\n          const functionSignatures: FunctionSignature[] = await loadFunctionSignatures(systemName);\n          const isRoot = namespace === \"\";\n          // Using Promise.all to avoid blocking on async calls\n          await Promise.all(\n            functionSignatures.map(async ({ functionName, functionArgs }) => {\n              const functionSignature = isRoot\n                ? functionName + functionArgs\n                : `${namespace}_${name}_${functionName}${functionArgs}`;\n\n              console.log(chalk.blue(`Registering function \"${functionSignature}\"`));\n              if (isRoot) {\n                const worldFunctionSelector = toFunctionSelector(\n                  functionSignature === \"\"\n                    ? { functionName: systemName, functionArgs } // Register the system's fallback function as `<systemName>(<args>)`\n                    : { functionName, functionArgs }\n                );\n                const systemFunctionSelector = toFunctionSelector({ functionName, functionArgs });\n                await fastTxExecute(\n                  WorldContract,\n                  \"registerRootFunctionSelector\",\n                  [toBytes16(namespace), toBytes16(name), worldFunctionSelector, systemFunctionSelector],\n                  confirmations\n                );\n              } else {\n                await fastTxExecute(\n                  WorldContract,\n                  \"registerFunctionSelector\",\n                  [toBytes16(namespace), toBytes16(name), functionName, functionArgs],\n                  confirmations\n                );\n              }\n              console.log(chalk.green(`Registered function \"${functionSignature}\"`));\n            })\n          );\n        }\n      }\n    ),\n  ];\n\n  // Wait for resources to be registered before granting access to them\n  await Promise.all(promises); // ----------------------------------------------------------------------------------------------\n  promises = [];\n\n  // Grant access to systems\n  for (const [systemName, { name, accessListAddresses, accessListSystems }] of Object.entries(resolvedConfig.systems)) {\n    const resourceSelector = `${namespace}/${name}`;\n\n    // Grant access to addresses\n    promises = [\n      ...promises,\n      ...accessListAddresses.map(async (address) => {\n        console.log(chalk.blue(`Grant ${address} access to ${systemName} (${resourceSelector})`));\n        await fastTxExecute(\n          WorldContract,\n          \"grantAccess\",\n          [toBytes16(namespace), toBytes16(name), address],\n          confirmations\n        );\n        console.log(chalk.green(`Granted ${address} access to ${systemName} (${namespace}/${name})`));\n      }),\n    ];\n\n    // Grant access to other systems\n    promises = [\n      ...promises,\n      ...accessListSystems.map(async (granteeSystem) => {\n        console.log(chalk.blue(`Grant ${granteeSystem} access to ${systemName} (${resourceSelector})`));\n        await fastTxExecute(\n          WorldContract,\n          \"grantAccess\",\n          [toBytes16(namespace), toBytes16(name), await contractPromises[granteeSystem]],\n          confirmations\n        );\n        console.log(chalk.green(`Granted ${granteeSystem} access to ${systemName} (${resourceSelector})`));\n      }),\n    ];\n  }\n\n  // Wait for access to be granted before installing modules\n  await Promise.all(promises); // ----------------------------------------------------------------------------------------------\n  promises = [];\n\n  // Install modules\n  promises = [\n    ...promises,\n    ...mudConfig.modules.map(async (module) => {\n      console.log(chalk.blue(`Installing${module.root ? \" root \" : \" \"}module ${module.name}`));\n      // Resolve arguments\n      const resolvedArgs = await Promise.all(\n        module.args.map((arg) => resolveWithContext(arg, { tableIds, systemAddresses: contractPromises }))\n      );\n      const values = resolvedArgs.map((arg) => arg.value);\n      const types = resolvedArgs.map((arg) => arg.type);\n      const moduleAddress = await contractPromises[module.name];\n      if (!moduleAddress) throw new Error(`Module ${module.name} not found`);\n\n      // Send transaction to install module\n      await fastTxExecute(\n        WorldContract,\n        module.root ? \"installRootModule\" : \"installModule\",\n        [moduleAddress, abi.encode(types, values)],\n        confirmations\n      );\n\n      console.log(chalk.green(`Installed${module.root ? \" root \" : \" \"}module ${module.name}`));\n    }),\n  ];\n\n  // Await all promises before executing PostDeploy script\n  await Promise.all(promises); // ----------------------------------------------------------------------------------------------\n\n  // Confirm the current nonce is the expected nonce to make sure all transactions have been included\n  let remoteNonce = await signer.getTransactionCount();\n  let retryCount = 0;\n  const maxRetries = 100;\n  while (remoteNonce !== nonce && retryCount < maxRetries) {\n    console.log(\n      chalk.gray(\n        `Waiting for transactions to be included before executing ${postDeployScript} (local nonce: ${nonce}, remote nonce: ${remoteNonce}, retry number ${retryCount}/${maxRetries})`\n      )\n    );\n    await new Promise((resolve) => setTimeout(resolve, pollInterval));\n    retryCount++;\n    remoteNonce = await signer.getTransactionCount();\n  }\n  if (remoteNonce !== nonce) {\n    throw new MUDError(\n      \"Remote nonce doesn't match local nonce, indicating that not all deploy transactions were included.\"\n    );\n  }\n\n  promises = [];\n\n  // Execute postDeploy forge script\n  const postDeployPath = path.join(await getScriptDirectory(), postDeployScript + \".s.sol\");\n  if (existsSync(postDeployPath)) {\n    console.log(chalk.blue(`Executing post deploy script at ${postDeployPath}`));\n    await forge(\n      [\n        \"script\",\n        postDeployScript,\n        \"--sig\",\n        \"run(address)\",\n        await contractPromises.World,\n        \"--broadcast\",\n        \"--rpc-url\",\n        rpc,\n        \"-vvv\",\n      ],\n      {\n        profile,\n      }\n    );\n  } else {\n    console.log(`No script at ${postDeployPath}, skipping post deploy hook`);\n  }\n\n  console.log(chalk.green(\"Deployment completed in\", (Date.now() - startTime) / 1000, \"seconds\"));\n\n  return { worldAddress: await contractPromises.World, blockNumber };\n\n  // ------------------- INTERNAL FUNCTIONS -------------------\n  // (Inlined to avoid having to pass around nonce, signer and forgeOutDir)\n\n  /**\n   * Deploy a contract and return the address\n   * @param contractName Name of the contract to deploy (must exist in the file system)\n   * @param disableTxWait Disable waiting for contract deployment\n   * @returns Address of the deployed contract\n   */\n  async function deployContractByName(contractName: string, disableTxWait: boolean): Promise<string> {\n    console.log(chalk.blue(\"Deploying\", contractName));\n\n    const { abi, bytecode } = await getContractData(contractName);\n    return deployContract(abi, bytecode, disableTxWait, contractName);\n  }\n\n  /**\n   * Deploy a contract and return the address\n   * @param abi The contract interface\n   * @param bytecode The contract bytecode\n   * @param disableTxWait Disable waiting for contract deployment\n   * @param contractName The contract name (optional, used for logs)\n   * @param retryCount\n   * @returns Address of the deployed contract\n   */\n  async function deployContract(\n    abi: ContractInterface,\n    bytecode: string | { object: string },\n    disableTxWait: boolean,\n    contractName?: string,\n    retryCount = 0\n  ): Promise<string> {\n    try {\n      const factory = new ethers.ContractFactory(abi, bytecode, signer);\n      console.log(chalk.gray(`executing deployment of ${contractName} with nonce ${nonce}`));\n      const deployPromise = factory\n        .deploy({\n          nonce: nonce++,\n          maxPriorityFeePerGas,\n          maxFeePerGas,\n          gasPrice,\n        })\n        .then((c) => (disableTxWait ? c : c.deployed()));\n\n      promises.push(deployPromise);\n      const { address } = await deployPromise;\n\n      console.log(chalk.green(\"Deployed\", contractName, \"to\", address));\n      return address;\n    } catch (error: any) {\n      if (debug) console.error(error);\n      if (retryCount === 0 && error?.message.includes(\"transaction already imported\")) {\n        // If the deployment failed because the transaction was already imported,\n        // retry with a higher priority fee\n        setInternalFeePerGas(priorityFeeMultiplier * 1.1);\n        return deployContract(abi, bytecode, disableTxWait, contractName, retryCount++);\n      } else if (error?.message.includes(\"invalid bytecode\")) {\n        throw new MUDError(\n          `Error deploying ${contractName}: invalid bytecode. Note that linking of public libraries is not supported yet, make sure none of your libraries use \"external\" functions.`\n        );\n      } else if (error?.message.includes(\"CreateContractLimit\")) {\n        throw new MUDError(`Error deploying ${contractName}: CreateContractLimit exceeded.`);\n      } else throw error;\n    }\n  }\n\n  /**\n   * Deploy a contract and return the address\n   * @param contractName Name of the contract to deploy (must exist in the file system)\n   * @returns Address of the deployed contract\n   *\n   * NOTE: Forge deploy seems to be slightly slower than ethers\n   * (probably due to the extra overhead spawning a child process to run forge),\n   * so we mostly use ethersDeployContract here.\n   * However, for contracts not in the user directory (eg. the vanilla World contract),\n   * using forge is more convenient because it automatically finds the contract in the @latticexyz/world package.\n   */\n  // async function forgeDeployContract(contractName: string): Promise<string> {\n  //   console.log(chalk.blue(\"Deploying\", contractName));\n\n  //   const { deployedTo } = JSON.parse(\n  //     await forge(\n  //       [\"create\", contractName, \"--rpc-url\", rpc, \"--private-key\", privateKey, \"--json\", \"--nonce\", String(nonce++)],\n  //       { profile, silent: true }\n  //     )\n  //   );\n  //   return deployedTo;\n  // }\n\n  async function loadFunctionSignatures(contractName: string): Promise<FunctionSignature[]> {\n    const { abi } = await getContractData(contractName);\n\n    return abi\n      .filter((item) => [\"fallback\", \"function\"].includes(item.type))\n      .map((item) => {\n        if (item.type === \"fallback\") return { functionName: \"\", functionArgs: \"\" };\n\n        return {\n          functionName: item.name,\n          functionArgs: parseComponents(item.inputs),\n        };\n      });\n  }\n\n  /**\n   * Recursively turn (nested) structs in signatures into tuples\n   */\n  function parseComponents(params: ParamType[]): string {\n    const components = params.map((param) => {\n      const tupleMatch = param.type.match(/tuple(.*)/);\n      if (tupleMatch) {\n        // there can be arrays of tuples,\n        // `tupleMatch[1]` preserves the array brackets (or is empty string for non-arrays)\n        return parseComponents(param.components) + tupleMatch[1];\n      } else {\n        return param.type;\n      }\n    });\n    return `(${components})`;\n  }\n\n  /**\n   * Only await gas estimation (for speed), only execute if gas estimation succeeds (for safety)\n   */\n  async function fastTxExecute<C extends { estimateGas: any; [key: string]: any }, F extends keyof C>(\n    contract: C,\n    func: F,\n    args: Parameters<C[F]>,\n    confirmations = 1,\n    retryCount = 0\n  ): Promise<Awaited<ReturnType<Awaited<ReturnType<C[F]>>[\"wait\"]>>> {\n    const functionName = `${func as string}(${args.map((arg) => `'${arg}'`).join(\",\")})`;\n    try {\n      const gasLimit = await contract.estimateGas[func].apply(null, args);\n      console.log(chalk.gray(`executing transaction: ${functionName} with nonce ${nonce}`));\n      const txPromise = contract[func]\n        .apply(null, [...args, { gasLimit, nonce: nonce++, maxPriorityFeePerGas, maxFeePerGas, gasPrice }])\n        .then((tx: any) => (confirmations === 0 ? tx : tx.wait(confirmations)));\n      promises.push(txPromise);\n      return txPromise;\n    } catch (error: any) {\n      if (debug) console.error(error);\n      if (retryCount === 0 && error?.message.includes(\"transaction already imported\")) {\n        // If the deployment failed because the transaction was already imported,\n        // retry with a higher priority fee\n        setInternalFeePerGas(priorityFeeMultiplier * 1.1);\n        return fastTxExecute(contract, func, args, confirmations, retryCount++);\n      } else throw new MUDError(`Gas estimation error for ${functionName}: ${error?.reason}`);\n    }\n  }\n\n  /**\n   * Load the contract's abi and bytecode from the file system\n   * @param contractName: Name of the contract to load\n   */\n  async function getContractData(contractName: string): Promise<{ bytecode: string; abi: Fragment[] }> {\n    let data: any;\n    const contractDataPath = path.join(forgeOutDirectory, contractName + \".sol\", contractName + \".json\");\n    try {\n      data = JSON.parse(readFileSync(contractDataPath, \"utf8\"));\n    } catch (error: any) {\n      throw new MUDError(`Error reading file at ${contractDataPath}`);\n    }\n\n    const bytecode = data?.bytecode?.object;\n    if (!bytecode) throw new MUDError(`No bytecode found in ${contractDataPath}`);\n\n    const abi = data?.abi;\n    if (!abi) throw new MUDError(`No ABI found in ${contractDataPath}`);\n\n    return { abi, bytecode };\n  }\n\n  /**\n   * Set the maxFeePerGas and maxPriorityFeePerGas based on the current base fee and the given multiplier.\n   * The multiplier is used to allow replacing pending transactions.\n   * @param multiplier Multiplier to apply to the base fee\n   */\n  async function setInternalFeePerGas(multiplier: number) {\n    // Compute maxFeePerGas and maxPriorityFeePerGas like ethers, but allow for a multiplier to allow replacing pending transactions\n    const feeData = await provider.getFeeData();\n\n    if (feeData.lastBaseFeePerGas) {\n      if (!feeData.lastBaseFeePerGas.eq(0) && (await signer.getBalance()).eq(0)) {\n        throw new MUDError(`Attempting to deploy to a chain with non-zero base fee with an account that has no balance.\n        If you're deploying to the Lattice testnet, you can fund your account by running 'pnpm mud faucet --address ${await signer.getAddress()}'`);\n      }\n\n      // Set the priority fee to 0 for development chains with no base fee, to allow transactions from unfunded wallets\n      maxPriorityFeePerGas = feeData.lastBaseFeePerGas.eq(0) ? 0 : Math.floor(1_500_000_000 * multiplier);\n      maxFeePerGas = feeData.lastBaseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n    } else if (feeData.gasPrice) {\n      // Legacy chains with gasPrice instead of maxFeePerGas\n      if (!feeData.gasPrice.eq(0) && (await signer.getBalance()).eq(0)) {\n        throw new MUDError(\n          `Attempting to deploy to a chain with non-zero gas price with an account that has no balance.`\n        );\n      }\n\n      gasPrice = feeData.gasPrice;\n    } else {\n      throw new MUDError(\"Can not fetch fee data from RPC\");\n    }\n  }\n}\n\n// TODO: use stringToBytes16 from utils as soon as utils are usable inside cli\n// (see https://github.com/latticexyz/mud/issues/499)\nfunction toBytes16(input: string) {\n  if (input.length > 16) throw new Error(\"String does not fit into 16 bytes\");\n\n  const result = new Uint8Array(16);\n  // Set ascii bytes\n  for (let i = 0; i < input.length; i++) {\n    result[i] = input.charCodeAt(i);\n  }\n  // Set the remaining bytes to 0\n  for (let i = input.length; i < 16; i++) {\n    result[i] = 0;\n  }\n  return result;\n}\n\n// TODO: use TableId from utils as soon as utils are usable inside cli\n// (see https://github.com/latticexyz/mud/issues/499)\nfunction toResourceSelector(namespace: string, file: string): Uint8Array {\n  const namespaceBytes = toBytes16(namespace);\n  const fileBytes = toBytes16(file);\n  const result = new Uint8Array(32);\n  result.set(namespaceBytes);\n  result.set(fileBytes, 16);\n  return result;\n}\n\ninterface FunctionSignature {\n  functionName: string;\n  functionArgs: string;\n}\n\n// TODO: move this to utils as soon as utils are usable inside cli\n// (see https://github.com/latticexyz/mud/issues/499)\nfunction toFunctionSelector({ functionName, functionArgs }: FunctionSignature): string {\n  const functionSignature = functionName + functionArgs;\n  if (functionSignature === \"\") return \"0x\";\n  return sigHash(functionSignature);\n}\n\n// TODO: move this to utils as soon as utils are usable inside cli\n// (see https://github.com/latticexyz/mud/issues/499)\nfunction sigHash(signature: string) {\n  return ethers.utils.hexDataSlice(ethers.utils.keccak256(ethers.utils.toUtf8Bytes(signature)), 0, 4);\n}\n","import { ethers } from \"ethers\";\n\n// TODO: Use viem's getChainId\nexport async function getChainId(rpc: string) {\n  const { result: chainId } = await ethers.utils.fetchJson(\n    rpc,\n    '{ \"id\": 42, \"jsonrpc\": \"2.0\", \"method\": \"eth_chainId\", \"params\": [ ] }'\n  );\n  return Number(chainId);\n}\n","import glob from \"glob\";\nimport { basename } from \"path\";\n\n/**\n * Get a list of all contract paths/names within the provided src directory\n */\nexport function getExistingContracts(srcDir: string) {\n  return glob.sync(`${srcDir}/**/*.sol`).map((path) => ({\n    path,\n    basename: basename(path, \".sol\"),\n  }));\n}\n"],"mappings":"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","names":["chalk","path","MUDError","loadConfig","existsSync","readFileSync","path","chalk","ethers","abi","getOutDirectory","getScriptDirectory","cast","forge","resolveWithContext","MUDError","encodeSchema","resolveAbiOrUserType","resolveWorldConfig","WorldData","IBaseWorldData","CoreModuleData","KeysWithValueModuleData","KeysInTableModuleData","UniqueEntityModuleData","SnapSyncModuleData","deploy","mudConfig","existingContractNames","deployConfig","resolvedConfig","startTime","worldContractName","namespace","postDeployScript","profile","rpc","privateKey","priorityFeeMultiplier","debug","worldAddress","disableTxWait","pollInterval","forgeOutDirectory","provider","signer","nonce","maxPriorityFeePerGas","maxFeePerGas","gasPrice","setInternalFeePerGas","promises","blockNumber","worldPromise","deployContractByName","deployContract","systemPromises","acc","systemName","defaultModules","modulePromises","module","contractPromises","WorldContract","confirmations","fastTxExecute","toBytes16","tableIds","tableName","name","schema","keySchema","toResourceSelector","schemaTypes","abiOrUserType","schemaType","keyTypes","openAccess","registerFunctionSelectors","functionSignatures","loadFunctionSignatures","isRoot","functionName","functionArgs","functionSignature","worldFunctionSelector","toFunctionSelector","systemFunctionSelector","accessListAddresses","accessListSystems","resourceSelector","address","granteeSystem","resolvedArgs","arg","values","types","moduleAddress","remoteNonce","retryCount","maxRetries","resolve","postDeployPath","contractName","bytecode","getContractData","factory","deployPromise","c","error","item","parseComponents","params","param","tupleMatch","contract","func","args","gasLimit","txPromise","tx","data","contractDataPath","multiplier","feeData","input","result","i","file","namespaceBytes","fileBytes","sigHash","signature","forge","getRpcUrl","getSrcDirectory","existsSync","mkdirSync","readFileSync","writeFileSync","ethers","getChainId","rpc","chainId","glob","basename","getExistingContracts","srcDir","path","deployHandler","args","configPath","printConfig","profile","clean","skipBuild","rpc","getRpcUrl","chalk","forge","srcDir","getSrcDirectory","existingContractNames","getExistingContracts","basename","mudConfig","loadConfig","privateKey","MUDError","deploymentInfo","deploy","chainId","getChainId","outputDir","path","mkdirSync","writeFileSync","localChains","deploys","existsSync","readFileSync"]}