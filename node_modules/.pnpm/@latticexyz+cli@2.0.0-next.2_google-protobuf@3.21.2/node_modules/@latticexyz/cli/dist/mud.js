#!/usr/bin/env node
import{a as P,b as M,c as w}from"./chunk-KN3UEKI6.js";import xo from"yargs";import{hideBin as Mo}from"yargs/helpers";import ko from"@latticexyz/gas-report";import{rmSync as se}from"fs";import{homedir as ae}from"os";import ce from"path";import{execa as de}from"execa";var le={command:"devnode",describe:"Start a local Ethereum node for development",builder(e){return e.options({blocktime:{type:"number",default:1,decs:"Interval in which new blocks are produced"}})},async handler({blocktime:e}){console.log("Clearing devnode history");let o=ae();se(ce.join(o,".foundry","anvil","tmp"),{recursive:!0,force:!0});let t=["-b",String(e),"--block-base-fee-per-gas","0"];console.log(`Running: anvil ${t.join(" ")}`);let n=de("anvil",t,{stdio:["inherit","inherit","inherit"]});process.on("SIGINT",()=>{console.log(`
gracefully shutting down from SIGINT (Crtl-C)`),n.kill(),process.exit()}),await n}},W=le;import{FaucetServiceDefinition as pe}from"@latticexyz/services/faucet";import{createChannel as me,createClient as fe}from"nice-grpc-web";import R from"chalk";import{NodeHttpTransport as ge}from"@improbable-eng/grpc-web-node-http-transport";function ue(e){return fe(pe,me(e,ge()))}var ye={command:"faucet",describe:"Interact with a MUD faucet",builder(e){return e.options({dripDev:{type:"boolean",desc:"Request a drip from the dev endpoint (requires faucet to have dev mode enabled)",default:!0},faucetUrl:{type:"string",desc:"URL of the MUD faucet",default:"https://faucet.testnet-mud-services.linfra.xyz"},address:{type:"string",desc:"Ethereum address to fund",required:!0}})},async handler({dripDev:e,faucetUrl:o,address:t}){let n=ue(o);e&&(console.log(R.yellow("Dripping to",t)),await n.dripDev({address:t}),console.log(R.yellow("Success"))),process.exit(0)}},I=ye;var he={command:"hello <name>",describe:"Greet <name> with Hello",builder(e){return e.options({upper:{type:"boolean"}}).positional("name",{type:"string",demandOption:!0})},handler({name:e}){let o=`Gm, ${e}!`;console.log(o),process.exit(0)}},$=he;import be from"path";import{loadConfig as we}from"@latticexyz/config/node";import{tablegen as ve}from"@latticexyz/store/codegen";import{getSrcDirectory as De}from"@latticexyz/common/foundry";var Ce={command:"tablegen",describe:"Autogenerate MUD Store table libraries based on the config file",builder(e){return e.options({configPath:{type:"string",desc:"Path to the config file"}})},async handler({configPath:e}){let o=await we(e),t=await De();await ve(o,be.join(t,o.codegenDirectory)),process.exit(0)}},E=Ce;import D from"chalk";import{ZodError as ke}from"zod";import{fromZodError as xe,ValidationError as Me}from"zod-validation-error";import{NotInsideProjectError as Se}from"@latticexyz/config";import{MUDError as Oe}from"@latticexyz/common/errors";function g(e){if(e instanceof Me)console.log(D.redBright(e.message));else if(e instanceof ke){let o=xe(e,{prefixSeparator:`
- `,issueSeparator:`
- `});console.log(D.redBright(o.message))}else e instanceof Se?(console.log(D.red(e.message)),console.log(""),console.log(D.blue("To learn more about MUD's configuration, please go to https://mud.dev/packages/cli/"))):e instanceof Oe?console.log(D.red(e)):console.log(e)}import Ue from"chalk";function A(){console.log(Ue.yellow(`
.------..------..------.
|M.--. ||U.--. ||D.--. |
| (\\/) || (\\/) || :/\\: |
| :\\/: || :\\/: || (__) |
| '--'M|| '--'U|| '--'D|
'------''------''------'
`))}import{getOutDirectory as je}from"@latticexyz/common/foundry";import Pe from"path";import{runTypeChain as We}from"typechain";async function F(){let e=process.cwd(),o=await je(),t=Pe.join(process.cwd(),o,"IWorld.sol/IWorld.json");await We({cwd:e,filesToProcess:[t],allFiles:[t],target:"ethers-v5"}),console.log("Typechain generated IWorld interface")}var U={configPath:{type:"string",desc:"Path to the config file"},clean:{type:"boolean",desc:"Remove the build forge artifacts and cache directories before building"},printConfig:{type:"boolean",desc:"Print the resolved config"},profile:{type:"string",desc:"The foundry profile to use"},debug:{type:"boolean",desc:"Print debug logs, like full error messages"},priorityFeeMultiplier:{type:"number",desc:"Multiply the estimated priority fee by the provided factor",default:1},saveDeployment:{type:"boolean",desc:"Save the deployment info to a file",default:!0},rpc:{type:"string",desc:"The RPC URL to use. Defaults to the RPC url from the local foundry.toml"},worldAddress:{type:"string",desc:"Deploy to an existing World at the given address"},srcDir:{type:"string",desc:"Source directory. Defaults to foundry src directory."},disableTxWait:{type:"boolean",desc:"Disable waiting for transactions to be confirmed.",default:!1},pollInterval:{type:"number",desc:"Interval in miliseconds to use to poll for transaction receipts / block inclusion",default:1e3},skipBuild:{type:"boolean",desc:"Skip rebuilding the contracts before deploying"}},Re={command:"deploy",describe:"Deploy MUD contracts",builder(e){return e.options(U)},async handler(e){try{await w(e)}catch(o){g(o),process.exit(1)}process.exit(0)}},T=Re;import{loadConfig as Ie}from"@latticexyz/config/node";import{worldgen as $e}from"@latticexyz/world/node";import{getSrcDirectory as Ee}from"@latticexyz/common/foundry";import z from"path";import{rmSync as Ae}from"fs";var Fe={command:"worldgen",describe:"Autogenerate interfaces for Systems and World based on existing contracts and the config file",builder(e){return e.options({configPath:{type:"string",desc:"Path to the config file"},clean:{type:"boolean",desc:"Clear the worldgen directory before generating new interfaces (defaults to true)",default:!0}})},async handler(e){await j(e),process.exit(0)}};async function j(e){let o=e.srcDir??await Ee(),t=M(o),n=e.config??await Ie(e.configPath),i=z.join(o,n.codegenDirectory);e.clean&&Ae(z.join(i,n.worldgenDirectory),{recursive:!0,force:!0}),await $e(n,t,i)}var J=Fe;import h from"chalk";import{existsSync as ze,readFileSync as Je,rmSync as Be,writeFileSync as H}from"fs";import k from"path";import{MUDError as b}from"@latticexyz/common/errors";var B={name:"@latticexyz/cli",version:"2.0.0-next.2",description:"Command line interface for mud",repository:{type:"git",url:"https://github.com/latticexyz/mud.git",directory:"packages/cli"},license:"MIT",type:"module",exports:{".":"./dist/index.js"},types:"src/index.ts",bin:{mud:"./dist/mud.js"},scripts:{build:"pnpm run build:js && pnpm run build:test-tables","build:js":"tsup && chmod +x ./dist/mud.js","build:test-tables":"tsx ./scripts/generate-test-tables.ts",clean:"pnpm run clean:js","clean:js":"rimraf dist",dev:"tsup --watch",lint:"eslint . --ext .ts",test:"tsc --noEmit && forge test"},dependencies:{"@ethersproject/abi":"^5.7.0","@ethersproject/providers":"^5.7.2","@improbable-eng/grpc-web":"^0.15.0","@improbable-eng/grpc-web-node-http-transport":"^0.15.0","@latticexyz/common":"workspace:*","@latticexyz/config":"workspace:*","@latticexyz/gas-report":"workspace:*","@latticexyz/schema-type":"workspace:*","@latticexyz/services":"workspace:*","@latticexyz/solecs":"workspace:*","@latticexyz/std-contracts":"workspace:*","@latticexyz/store":"workspace:*","@latticexyz/utils":"workspace:*","@latticexyz/world":"workspace:*","@typechain/ethers-v5":"^10.2.0",chalk:"^5.0.1",chokidar:"^3.5.3",dotenv:"^16.0.3",ejs:"^3.1.8",ethers:"^5.7.2",execa:"^7.0.0",glob:"^8.0.3","nice-grpc-web":"^2.0.1",openurl:"^1.1.1",path:"^0.12.7","throttle-debounce":"^5.0.0",typechain:"^8.1.1",typescript:"5.1.6",yargs:"^17.7.1",zod:"^3.21.4","zod-validation-error":"^1.3.0"},devDependencies:{"@types/ejs":"^3.1.1","@types/glob":"^7.2.0","@types/node":"^18.15.11","@types/openurl":"^1.0.0","@types/throttle-debounce":"^5.0.0","@types/yargs":"^17.0.10","ds-test":"https://github.com/dapphub/ds-test.git#e282159d5170298eb2455a6c05280ab5a73a4ef0","forge-std":"https://github.com/foundry-rs/forge-std.git#74cfb77e308dd188d2f58864aaf44963ae6b88b1",tsup:"^6.7.0",tsx:"^3.12.6",vitest:"0.31.4"},gitHead:"914a1e0ae4a573d685841ca2ea921435057deb8f"};import He from"glob";var S=".mudbackup",C="@latticexyz",Ne={command:"set-version",describe:"Set MUD version in all package.json files and optionally backup the previously installed version",builder(e){return e.options({backup:{type:"boolean",description:`Back up the current MUD versions to "${S}"`},force:{type:"boolean",description:`Backup fails if a "${S}" file is found, unless --force is provided`},restore:{type:"boolean",description:`Restore the previous MUD versions from "${S}"`},mudVersion:{alias:"v",type:"string",description:"Set MUD to the given version"},tag:{alias:"t",type:"string",description:"Set MUD to the latest version with the given tag from npm"},commit:{alias:"c",type:"string",description:"Set MUD to the version based on a given git commit hash from npm"},link:{alias:"l",type:"string",description:"Relative path to the local MUD root directory to link"}})},async handler(e){try{let o=["mudVersion","link","tag","commit","restore"],t=o.reduce((i,c)=>e[c]?i+1:i,0);if(t===0)throw new b(`You need to provide one these options: ${o.join(", ")}`);if(t>1)throw new b(`These options are mutually exclusive: ${o.join(", ")}`);e.mudVersion=await Ve(e);let n=He.sync("**/package.json").filter(i=>!i.includes("node_modules"));for(let i of n)_e(i,e)}catch(o){g(o)}finally{process.exit(0)}}};async function Ve(e){e.mudVersion==="canary"&&(e.tag="main");let o;try{console.log(h.blue("Fetching available versions")),o=await(await fetch(`https://registry.npmjs.org/${B.name}`)).json()}catch{throw new b("Could not fetch available MUD versions")}if(e.tag){let t=o["dist-tags"][e.tag];if(!t)throw new b(`Could not find npm version with tag "${e.tag}"`);return console.log(h.green(`Latest version with tag ${e.tag}: ${t}`)),t}if(e.commit){let t=e.commit.substring(0,8),n=Object.keys(o.versions).find(i=>i.includes(t));if(!n)throw new b(`Could not find npm version based on commit "${e.commit}"`);return console.log(h.green(`Version from commit ${e.commit}: ${n}`)),n}return e.mudVersion}function _e(e,o){let{restore:t,force:n,link:i}=o,{backup:c,mudVersion:d}=o,a=k.join(k.dirname(e),S),v=ze(a);if(i&&!v&&(c=!0),c&&!n&&v)throw new b(`A backup file already exists at ${a}.
Use --force to overwrite it or --restore to restore it.`);let s=N(e),u=t?N(a):void 0,m={};for(let r in s.dependencies)r.startsWith(C)&&(m[r]=s.dependencies[r]);let y={};for(let r in s.devDependencies)r.startsWith(C)&&(y[r]=s.devDependencies[r]);c&&(H(a,JSON.stringify({dependencies:m,devDependencies:y},null,2)),console.log(h.green(`Backed up MUD dependencies from ${e} to ${a}`)));for(let r in s.dependencies)r.startsWith(C)&&(s.dependencies[r]=l(r,"dependencies"));for(let r in s.devDependencies)r.startsWith(C)&&(s.devDependencies[r]=l(r,"devDependencies"));return H(e,JSON.stringify(s,null,2)+`
`),console.log(`Updating ${e}`),V(m,s.dependencies),V(y,s.devDependencies),t&&!c&&(Be(a),console.log(h.green(`Cleaned up ${a}`))),s;function l(r,p){return t&&u?u[p][r]:(i&&(d=Le(e,i,r)),d||s[p][r])}}function N(e){try{let o=Je(e,"utf8");return JSON.parse(o)}catch{throw new b("Could not read JSON at "+e)}}function V(e,o){for(let t in e)e[t]!==o[t]&&console.log(`${t}: ${h.red(e[t])} -> ${h.green(o[t])}`)}function Le(e,o,t){let n=t.replace(C,""),i=k.relative(k.dirname(e),process.cwd());return"link:"+k.join(i,o,"packages",n)}var _=Ne;import{anvil as qe,forge as Ge,getRpcUrl as Ye}from"@latticexyz/common/foundry";import Ze from"chalk";import{rmSync as Ke,writeFileSync as Xe}from"fs";var L=".mudtest",Qe={command:"test",describe:"Run tests in MUD contracts",builder(e){return e.options({...U,port:{type:"number",description:"Port to run internal node for fork testing on",default:4242},worldAddress:{type:"string",description:"Address of an existing world contract. If provided, deployment is skipped and the RPC provided in the foundry.toml is used for fork testing."},forgeOptions:{type:"string",description:"Options to pass to forge test"}})},async handler(e){if(!e.worldAddress){let i=["--block-base-fee-per-gas","0","--port",String(e.port)];qe(i)}let o=e.worldAddress?await Ye(e.profile):`http://127.0.0.1:${e.port}`,t=e.worldAddress??(await w({...e,saveDeployment:!1,rpc:o})).worldAddress;console.log(Ze.blue("World address",t)),Xe(L,t);let n=e.forgeOptions?.replaceAll("\\","").split(" ")??[];try{let i=await Ge(["test","--fork-url",o,...n],{profile:e.profile});console.log(i)}catch(i){console.error(i)}Ke(L),process.exit(0)}},q=Qe;import{existsSync as eo,readFileSync as oo}from"fs";import{ethers as G}from"ethers";import{loadConfig as to}from"@latticexyz/config/node";import{MUDError as Y}from"@latticexyz/common/errors";import{cast as ro,getRpcUrl as no,getSrcDirectory as io}from"@latticexyz/common/foundry";import{TableId as Z}from"@latticexyz/common/deprecated";import{resolveWorldConfig as so}from"@latticexyz/world";import ao from"@latticexyz/world/abi/IBaseWorld.sol/IBaseWorld.json"assert{type:"json"};var co=new Z("","Systems"),lo={command:"trace",describe:"Display the trace of a transaction",builder(e){return e.options({tx:{type:"string",required:!0,description:"Transaction hash to replay"},worldAddress:{type:"string",description:"World contract address. Defaults to the value from worlds.json, based on rpc's chainId"},configPath:{type:"string",description:"Path to the config file"},profile:{type:"string",description:"The foundry profile to use"},srcDir:{type:"string",description:"Source directory. Defaults to foundry src directory."},rpc:{type:"string",description:"json rpc endpoint. Defaults to foundry's configured eth_rpc_url"}})},async handler(e){e.profile??=process.env.FOUNDRY_PROFILE;let{profile:o}=e;e.srcDir??=await io(o),e.rpc??=await no(o);let{tx:t,configPath:n,srcDir:i,rpc:c}=e,d=M(i),a=await to(n),v=so(a,d.map(({basename:f})=>f)),s=e.worldAddress??await po(a.worldsFile,c),u=new G.providers.StaticJsonRpcProvider(c),m=new G.Contract(s,ao.abi,u),y=a.namespace,l=Object.values(v.systems).map(({name:f})=>f),r=[];for(let f of l){let O=new Z(y,f),ie=await m.getField(co.toHex(),[O.toHex()],0);r.push({name:f,address:ie})}let p=await ro(["run","--label",`${s}:World`,...r.map(({name:f,address:O})=>["--label",`${O}:${f}`]).flat(),`${t}`]);console.log(p),process.exit(0)}},K=lo;async function po(e,o){if(eo(e)){let t=await P(o),n=JSON.parse(oo(e,"utf-8"));if(!n[t])throw new Y(`chainId ${t} is missing in worldsFile "${e}"`);return n[t].address}else throw new Y("worldAddress is not specified and worldsFile is missing")}import{anvil as mo,forge as X,getRpcUrl as fo,getScriptDirectory as go,getSrcDirectory as uo}from"@latticexyz/common/foundry";import x from"chalk";import yo from"chokidar";import{loadConfig as Q,resolveConfigPath as ho}from"@latticexyz/config/node";import{tablegen as bo}from"@latticexyz/store/codegen";import ee from"path";import{debounce as wo}from"throttle-debounce";import{homedir as vo}from"os";import{rmSync as Do}from"fs";var Co={command:"dev-contracts",describe:"Start a development server for MUD contracts",builder(e){return e.options({rpc:{type:"string",decs:"RPC endpoint of the development node. If none is provided, an anvil instance is spawned in the background on port 8545."},configPath:{type:"string",decs:"Path to MUD config"}})},async handler(e){await X(["clean"]);let o=e.rpc??await fo(),t=e.configPath??await ho(e.configPath),n=await uo(),i=await go(),c=await Q(t);if(await u(c),await m(c),!e.rpc){console.log(x.gray("Cleaning devnode cache"));let l=vo();Do(ee.join(l,".foundry","anvil","tmp"),{recursive:!0,force:!0}),mo(["--block-time","1","--block-base-fee-per-gas","0"])}let d={config:!1,contracts:!1},a={current:!1};yo.watch([t,n]).on("all",async(l,r)=>{if(r.includes(t)&&(d.config=!0,d.contracts=!0),r.includes(n)||r.includes(i)){if(r.includes(c.codegenDirectory))return;d.contracts=!0}s()});let s=wo(100,async()=>{if(a.current)return;a.current=!0;let{config:l,contracts:r}=d;d.config=!1,d.contracts=!1;try{let p=await Q(t);l&&await u(p),r&&await m(p),await y()}catch(p){console.error(x.red(`MUD dev-contracts watcher failed to deploy config or contracts changes
`)),g(p)}a.current=!1,(d.config||d.contracts)&&(console.log("Detected change while handling the previous change"),s()),A(),console.log("MUD watching for changes...")});async function u(l){console.log(x.blue("mud.config.ts changed - regenerating tables and recs types"));let r=ee.join(n,l.codegenDirectory);await bo(l,r)}async function m(l){console.log(x.blue("contracts changed - regenerating interfaces and contract types")),await j({config:l,clean:!0,srcDir:n}),await X(["build"]),await F()}async function y(){console.log(x.blue("redeploying World")),await w({configPath:t,skipBuild:!0,priorityFeeMultiplier:1,disableTxWait:!0,pollInterval:1e3,saveDeployment:!0,srcDir:n,rpc:o})}}},oe=Co;var te=[T,W,I,ko,$,E,J,_,q,K,oe];import*as ne from"dotenv";import re from"chalk";ne.config();xo(Mo(process.argv)).scriptName("mud").command(te).strict().fail((e,o)=>{console.error(re.red(e)),e.includes("Missing required argument")&&console.log(re.yellow(`Run 'pnpm mud ${process.argv[2]} --help' for a list of available and required arguments.`)),console.log(""),g(o),console.log(""),process.exit(1)}).alias({h:"help"}).argv;
//# sourceMappingURL=mud.js.map