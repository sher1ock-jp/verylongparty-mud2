import T from"chalk";import V from"path";import{MUDError as Ee}from"@latticexyz/common/errors";import{loadConfig as Oe}from"@latticexyz/config/node";import{existsSync as Ce,readFileSync as Se}from"fs";import oe from"path";import a from"chalk";import{ethers as j}from"ethers";import{defaultAbiCoder as De}from"ethers/lib/utils.js";import{getOutDirectory as Fe,getScriptDirectory as ve,cast as Ie,forge as xe}from"@latticexyz/common/foundry";import{resolveWithContext as Me}from"@latticexyz/config";import{MUDError as C}from"@latticexyz/common/errors";import{encodeSchema as ne}from"@latticexyz/schema-type/deprecated";import{resolveAbiOrUserType as re}from"@latticexyz/store/codegen";import{resolveWorldConfig as Re}from"@latticexyz/world";import je from"@latticexyz/world/abi/World.sol/World.json"assert{type:"json"};import se from"@latticexyz/world/abi/IBaseWorld.sol/IBaseWorld.json"assert{type:"json"};import ie from"@latticexyz/world/abi/CoreModule.sol/CoreModule.json"assert{type:"json"};import ae from"@latticexyz/world/abi/KeysWithValueModule.sol/KeysWithValueModule.json"assert{type:"json"};import le from"@latticexyz/world/abi/KeysInTableModule.sol/KeysInTableModule.json"assert{type:"json"};import ce from"@latticexyz/world/abi/UniqueEntityModule.sol/UniqueEntityModule.json"assert{type:"json"};import de from"@latticexyz/world/abi/SnapSyncModule.sol/SnapSyncModule.json"assert{type:"json"};async function pe(r,g,u){let f=Re(r,g),M=Date.now(),{worldContractName:B,namespace:i,postDeployScript:k}=r,{profile:A,rpc:b,privateKey:E,priorityFeeMultiplier:h,debug:F,worldAddress:v,disableTxWait:y,pollInterval:W}=u,fe=await Fe(A),U=new j.providers.StaticJsonRpcProvider(b);U.pollingInterval=W;let S=new j.Wallet(E,U);console.log("Deploying from",S.address);let I=await S.getTransactionCount();console.log("Initial nonce",I);let O,N,K;await L(h);let d=[],z=Number(await Ie(["block-number","--rpc-url",b],{profile:A}));console.log("Start deployment at block",z);let be={World:v?Promise.resolve(v):B?J(B,y):x(se.abi,je.bytecode,y,"World")},we=Object.keys(f.systems).reduce((e,t)=>(e[t]=J(t,y),e),{}),H={CoreModule:x(ie.abi,ie.bytecode,y,"CoreModule"),KeysWithValueModule:x(ae.abi,ae.bytecode,y,"KeysWithValueModule"),KeysInTableModule:x(le.abi,le.bytecode,y,"KeysInTableModule"),UniqueEntityModule:x(ce.abi,ce.bytecode,y,"UniqueEntityModule"),SnapSyncModule:x(de.abi,de.bytecode,y,"SnapSyncModule")},Q=r.modules.filter(e=>!H[e.name]).reduce((e,t)=>(e[t.name]=J(t.name,y),e),H),R={...be,...we,...Q},$=new j.Contract(await R.World,se.abi,S),P=y?0:1;v||(console.log(a.blue("Installing core World modules")),await w($,"installRootModule",[await Q.CoreModule,"0x"],P),console.log(a.green("Installed core World modules"))),i&&await w($,"registerNamespace",[p(i)],P);let X={};d=[...d,...Object.entries(r.tables).map(async([e,{name:t,schema:o,keySchema:s}])=>{console.log(a.blue(`Registering table ${e} at ${i}/${t}`)),X[e]=ke(i,t);let c=Object.values(o).map(l=>{let{schemaType:m}=re(l,r);return m}),n=Object.values(s).map(l=>{let{schemaType:m}=re(l,r);return m});await w($,"registerTable",[p(i),p(t),ne(c),ne(n)],P),await w($,"setMetadata(bytes16,bytes16,string,string[])",[p(i),p(t),e,Object.keys(o)],P),console.log(a.green(`Registered table ${e} at ${t}`))})],d=[...d,...Object.entries(f.systems).map(async([e,{name:t,openAccess:o,registerFunctionSelectors:s}])=>{if(console.log(a.blue(`Registering system ${e} at ${i}/${t}`)),await w($,"registerSystem",[p(i),p(t),await R[e],o],P),console.log(a.green(`Registered system ${e} at ${i}/${t}`)),s){let c=await he(e),n=i==="";await Promise.all(c.map(async({functionName:l,functionArgs:m})=>{let D=n?l+m:`${i}_${t}_${l}${m}`;if(console.log(a.blue(`Registering function "${D}"`)),n){let $e=ue(D===""?{functionName:e,functionArgs:m}:{functionName:l,functionArgs:m}),Pe=ue({functionName:l,functionArgs:m});await w($,"registerRootFunctionSelector",[p(i),p(t),$e,Pe],P)}else await w($,"registerFunctionSelector",[p(i),p(t),l,m],P);console.log(a.green(`Registered function "${D}"`))}))}})],await Promise.all(d),d=[];for(let[e,{name:t,accessListAddresses:o,accessListSystems:s}]of Object.entries(f.systems)){let c=`${i}/${t}`;d=[...d,...o.map(async n=>{console.log(a.blue(`Grant ${n} access to ${e} (${c})`)),await w($,"grantAccess",[p(i),p(t),n],P),console.log(a.green(`Granted ${n} access to ${e} (${i}/${t})`))})],d=[...d,...s.map(async n=>{console.log(a.blue(`Grant ${n} access to ${e} (${c})`)),await w($,"grantAccess",[p(i),p(t),await R[n]],P),console.log(a.green(`Granted ${n} access to ${e} (${c})`))})]}await Promise.all(d),d=[],d=[...d,...r.modules.map(async e=>{console.log(a.blue(`Installing${e.root?" root ":" "}module ${e.name}`));let t=await Promise.all(e.args.map(n=>Me(n,{tableIds:X,systemAddresses:R}))),o=t.map(n=>n.value),s=t.map(n=>n.type),c=await R[e.name];if(!c)throw new Error(`Module ${e.name} not found`);await w($,e.root?"installRootModule":"installModule",[c,De.encode(s,o)],P),console.log(a.green(`Installed${e.root?" root ":" "}module ${e.name}`))})],await Promise.all(d);let G=await S.getTransactionCount(),_=0,Z=100;for(;G!==I&&_<Z;)console.log(a.gray(`Waiting for transactions to be included before executing ${k} (local nonce: ${I}, remote nonce: ${G}, retry number ${_}/${Z})`)),await new Promise(e=>setTimeout(e,W)),_++,G=await S.getTransactionCount();if(G!==I)throw new C("Remote nonce doesn't match local nonce, indicating that not all deploy transactions were included.");d=[];let q=oe.join(await ve(),k+".s.sol");return Ce(q)?(console.log(a.blue(`Executing post deploy script at ${q}`)),await xe(["script",k,"--sig","run(address)",await R.World,"--broadcast","--rpc-url",b,"-vvv"],{profile:A})):console.log(`No script at ${q}, skipping post deploy hook`),console.log(a.green("Deployment completed in",(Date.now()-M)/1e3,"seconds")),{worldAddress:await R.World,blockNumber:z};async function J(e,t){console.log(a.blue("Deploying",e));let{abi:o,bytecode:s}=await te(e);return x(o,s,t,e)}async function x(e,t,o,s,c=0){try{let n=new j.ContractFactory(e,t,S);console.log(a.gray(`executing deployment of ${s} with nonce ${I}`));let l=n.deploy({nonce:I++,maxPriorityFeePerGas:O,maxFeePerGas:N,gasPrice:K}).then(D=>o?D:D.deployed());d.push(l);let{address:m}=await l;return console.log(a.green("Deployed",s,"to",m)),m}catch(n){if(F&&console.error(n),c===0&&n?.message.includes("transaction already imported"))return L(h*1.1),x(e,t,o,s,c++);throw n?.message.includes("invalid bytecode")?new C(`Error deploying ${s}: invalid bytecode. Note that linking of public libraries is not supported yet, make sure none of your libraries use "external" functions.`):n?.message.includes("CreateContractLimit")?new C(`Error deploying ${s}: CreateContractLimit exceeded.`):n}}async function he(e){let{abi:t}=await te(e);return t.filter(o=>["fallback","function"].includes(o.type)).map(o=>o.type==="fallback"?{functionName:"",functionArgs:""}:{functionName:o.name,functionArgs:ee(o.inputs)})}function ee(e){return`(${e.map(o=>{let s=o.type.match(/tuple(.*)/);return s?ee(o.components)+s[1]:o.type})})`}async function w(e,t,o,s=1,c=0){let n=`${t}(${o.map(l=>`'${l}'`).join(",")})`;try{let l=await e.estimateGas[t].apply(null,o);console.log(a.gray(`executing transaction: ${n} with nonce ${I}`));let m=e[t].apply(null,[...o,{gasLimit:l,nonce:I++,maxPriorityFeePerGas:O,maxFeePerGas:N,gasPrice:K}]).then(D=>s===0?D:D.wait(s));return d.push(m),m}catch(l){if(F&&console.error(l),c===0&&l?.message.includes("transaction already imported"))return L(h*1.1),w(e,t,o,s,c++);throw new C(`Gas estimation error for ${n}: ${l?.reason}`)}}async function te(e){let t,o=oe.join(fe,e+".sol",e+".json");try{t=JSON.parse(Se(o,"utf8"))}catch{throw new C(`Error reading file at ${o}`)}let s=t?.bytecode?.object;if(!s)throw new C(`No bytecode found in ${o}`);let c=t?.abi;if(!c)throw new C(`No ABI found in ${o}`);return{abi:c,bytecode:s}}async function L(e){let t=await U.getFeeData();if(t.lastBaseFeePerGas){if(!t.lastBaseFeePerGas.eq(0)&&(await S.getBalance()).eq(0))throw new C(`Attempting to deploy to a chain with non-zero base fee with an account that has no balance.
        If you're deploying to the Lattice testnet, you can fund your account by running 'pnpm mud faucet --address ${await S.getAddress()}'`);O=t.lastBaseFeePerGas.eq(0)?0:Math.floor(15e8*e),N=t.lastBaseFeePerGas.mul(2).add(O)}else if(t.gasPrice){if(!t.gasPrice.eq(0)&&(await S.getBalance()).eq(0))throw new C("Attempting to deploy to a chain with non-zero gas price with an account that has no balance.");K=t.gasPrice}else throw new C("Can not fetch fee data from RPC")}}function p(r){if(r.length>16)throw new Error("String does not fit into 16 bytes");let g=new Uint8Array(16);for(let u=0;u<r.length;u++)g[u]=r.charCodeAt(u);for(let u=r.length;u<16;u++)g[u]=0;return g}function ke(r,g){let u=p(r),f=p(g),M=new Uint8Array(32);return M.set(u),M.set(f,16),M}function ue({functionName:r,functionArgs:g}){let u=r+g;return u===""?"0x":Ae(u)}function Ae(r){return j.utils.hexDataSlice(j.utils.keccak256(j.utils.toUtf8Bytes(r)),0,4)}import{forge as ye,getRpcUrl as Ge,getSrcDirectory as Ue}from"@latticexyz/common/foundry";import{existsSync as Ne,mkdirSync as Ke,readFileSync as _e,writeFileSync as Y}from"fs";import{ethers as We}from"ethers";async function ge(r){let{result:g}=await We.utils.fetchJson(r,'{ "id": 42, "jsonrpc": "2.0", "method": "eth_chainId", "params": [ ] }');return Number(g)}import Te from"glob";import{basename as Be}from"path";function me(r){return Te.sync(`${r}/**/*.sol`).map(g=>({path:g,basename:Be(g,".sol")}))}async function xt(r){r.profile??=process.env.FOUNDRY_PROFILE;let{configPath:g,printConfig:u,profile:f,clean:M,skipBuild:B}=r,i=r.rpc??await Ge(f);console.log(T.bgBlue(T.whiteBright(`
 Deploying MUD contracts${f?" with profile "+f:""} to RPC ${i} 
`))),M&&await ye(["clean"],{profile:f}),B||await ye(["build"],{profile:f});let k=r?.srcDir??await Ue(),A=me(k).map(({basename:F})=>F),b=await Oe(g);u&&console.log(T.green(`
Resolved config:
`),JSON.stringify(b,null,2));let E=process.env.PRIVATE_KEY;if(!E)throw new Ee(`Missing PRIVATE_KEY environment variable.
Run 'echo "PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" > .env'
in your contracts directory to use the default anvil private key.`);let h=await pe(b,A,{...r,rpc:i,privateKey:E});if(r.saveDeployment){let F=await ge(i),v=V.join(b.deploysDirectory,F.toString());Ke(v,{recursive:!0}),Y(V.join(v,"latest.json"),JSON.stringify(h,null,2)),Y(V.join(v,Date.now()+".json"),JSON.stringify(h,null,2));let y=[1337,31337],W=Ne(b.worldsFile)?JSON.parse(_e(b.worldsFile,"utf-8")):{};W[F]={address:h.worldAddress,blockNumber:y.includes(F)?void 0:h.blockNumber},Y(b.worldsFile,JSON.stringify(W,null,2)),console.log(T.bgGreen(T.whiteBright(`
 Deployment result (written to ${b.worldsFile} and ${v}): 
`)))}return console.log(h),h}export{ge as a,me as b,xt as c};
//# sourceMappingURL=chunk-KN3UEKI6.js.map