{"version":3,"sources":["../ts/library/config/defaults.ts","../ts/library/config/resolveWorldConfig.ts","../ts/library/config/worldConfig.ts"],"sourcesContent":["export const SYSTEM_DEFAULTS = {\n  registerFunctionSelector: true,\n  openAccess: true,\n  accessList: [] as string[],\n} as const;\n\nexport const WORLD_DEFAULTS = {\n  worldContractName: undefined,\n  worldInterfaceName: \"IWorld\",\n  systems: {} as Record<string, never>,\n  excludeSystems: [] as string[],\n  postDeployScript: \"PostDeploy\",\n  deploysDirectory: \"./deploys\",\n  worldsFile: \"./worlds.json\",\n  worldgenDirectory: \"world\",\n  worldImportPath: \"@latticexyz/world/src/\",\n  modules: [] as [],\n} as const;\n","import { getDuplicates, STORE_SELECTOR_MAX_LENGTH, UnrecognizedSystemErrorFactory } from \"@latticexyz/config\";\nimport { MUDError } from \"@latticexyz/common/errors\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { SystemConfig, WorldConfig } from \"./types\";\n\nexport type ResolvedSystemConfig = ReturnType<typeof resolveSystemConfig>;\n\nexport type ResolvedWorldConfig = ReturnType<typeof resolveWorldConfig>;\n\n/**\n * Resolves the world config by combining the default and overridden system configs,\n * filtering out excluded systems, validate system names refer to existing contracts, and\n * splitting the access list into addresses and system names.\n */\nexport function resolveWorldConfig(config: StoreConfig & WorldConfig, existingContracts?: string[]) {\n  // Include contract names ending in \"System\", but not the base \"System\" contract, and not Interfaces\n  const defaultSystemNames =\n    existingContracts?.filter((name) => name.endsWith(\"System\") && name !== \"System\" && !name.match(/^I[A-Z]/)) ?? [];\n  const overriddenSystemNames = Object.keys(config.systems);\n\n  // Validate every key in systems refers to an existing system contract (and is not called \"World\")\n  if (existingContracts) {\n    for (const systemName of overriddenSystemNames) {\n      if (!existingContracts.includes(systemName) || systemName === \"World\") {\n        throw UnrecognizedSystemErrorFactory([\"systems\", systemName], systemName);\n      }\n    }\n  }\n\n  // Combine the default and overridden system names and filter out excluded systems\n  const systemNames = [...new Set([...defaultSystemNames, ...overriddenSystemNames])].filter(\n    (name) => !config.excludeSystems.includes(name)\n  );\n\n  // Resolve the config\n  const resolvedSystems: Record<string, ResolvedSystemConfig> = systemNames.reduce((acc, systemName) => {\n    return {\n      ...acc,\n      [systemName]: resolveSystemConfig(systemName, config.systems[systemName], existingContracts),\n    };\n  }, {});\n\n  // Table and system names must be unique (because they're both used for world selectors)\n  const tableNames = Object.values(config.tables).map(({ name }) => name);\n  const configuredSystemNames = Object.values(resolvedSystems).map(({ name }) => name);\n  const duplicateNames = getDuplicates([...tableNames, ...configuredSystemNames]);\n  if (duplicateNames.length > 0) {\n    throw new MUDError(`Table and system names must be unique: ${duplicateNames.join(\", \")}`);\n  }\n\n  return { systems: resolvedSystems };\n}\n\n/**\n * Resolves the system config by combining the default and overridden system configs,\n * @param systemName name of the system\n * @param config optional SystemConfig object, if none is provided the default config is used\n * @param existingContracts optional list of existing contract names, used to validate system names in the access list. If not provided, no validation is performed.\n * @returns ResolvedSystemConfig object\n * Default value for name is `systemName`\n * Default value for registerFunctionSelectors is true\n * Default value for openAccess is true\n * Default value for accessListAddresses is []\n * Default value for accessListSystems is []\n */\nexport function resolveSystemConfig(systemName: string, config?: SystemConfig, existingContracts?: string[]) {\n  const name = config?.name ?? systemName.slice(0, STORE_SELECTOR_MAX_LENGTH);\n  const registerFunctionSelectors = config?.registerFunctionSelectors ?? true;\n  const openAccess = config?.openAccess ?? true;\n  const accessListAddresses: string[] = [];\n  const accessListSystems: string[] = [];\n  const accessList = config && !config.openAccess ? config.accessList : [];\n\n  // Split the access list into addresses and system names\n  for (const accessListItem of accessList) {\n    if (accessListItem.startsWith(\"0x\")) {\n      accessListAddresses.push(accessListItem);\n    } else {\n      // Validate every system refers to an existing system contract\n      if (existingContracts && !existingContracts.includes(accessListItem)) {\n        throw UnrecognizedSystemErrorFactory([\"systems\", systemName, \"accessList\"], accessListItem);\n      }\n      accessListSystems.push(accessListItem);\n    }\n  }\n\n  return { name, registerFunctionSelectors, openAccess, accessListAddresses, accessListSystems };\n}\n","import { z } from \"zod\";\nimport { DynamicResolutionType, zEthereumAddress, zObjectName, zSelector } from \"@latticexyz/config\";\nimport { SYSTEM_DEFAULTS, WORLD_DEFAULTS } from \"./defaults\";\n\nconst zSystemName = zObjectName;\nconst zModuleName = zObjectName;\nconst zSystemAccessList = z.array(zSystemName.or(zEthereumAddress)).default(SYSTEM_DEFAULTS.accessList);\n\n// The system config is a combination of a name config and access config\nconst zSystemConfig = z.intersection(\n  z.object({\n    name: zSelector.optional(),\n    registerFunctionSelectors: z.boolean().default(SYSTEM_DEFAULTS.registerFunctionSelector),\n  }),\n  z.discriminatedUnion(\"openAccess\", [\n    z.object({\n      openAccess: z.literal(true).default(SYSTEM_DEFAULTS.openAccess),\n    }),\n    z.object({\n      openAccess: z.literal(false),\n      accessList: zSystemAccessList,\n    }),\n  ])\n);\n\nconst zValueWithType = z.object({\n  value: z.union([z.string(), z.number(), z.instanceof(Uint8Array)]),\n  type: z.string(),\n});\nconst zDynamicResolution = z.object({ type: z.nativeEnum(DynamicResolutionType), input: z.string() });\n\nconst zModuleConfig = z.object({\n  name: zModuleName,\n  root: z.boolean().default(false),\n  args: z.array(z.union([zValueWithType, zDynamicResolution])).default([]),\n});\n\n// The parsed world config is the result of parsing the user config\nexport const zWorldConfig = z.object({\n  worldContractName: z.string().optional(),\n  worldInterfaceName: z.string().default(WORLD_DEFAULTS.worldInterfaceName),\n  systems: z.record(zSystemName, zSystemConfig).default(WORLD_DEFAULTS.systems),\n  excludeSystems: z.array(zSystemName).default(WORLD_DEFAULTS.excludeSystems),\n  postDeployScript: z.string().default(WORLD_DEFAULTS.postDeployScript),\n  deploysDirectory: z.string().default(WORLD_DEFAULTS.deploysDirectory),\n  worldsFile: z.string().default(WORLD_DEFAULTS.worldsFile),\n  worldgenDirectory: z.string().default(WORLD_DEFAULTS.worldgenDirectory),\n  worldImportPath: z.string().default(WORLD_DEFAULTS.worldImportPath),\n  modules: z.array(zModuleConfig).default(WORLD_DEFAULTS.modules),\n});\n\n// Catchall preserves other plugins' options\nexport const zPluginWorldConfig = zWorldConfig.catchall(z.any());\n"],"mappings":"AAAO,IAAMA,EAAkB,CAC7B,yBAA0B,GAC1B,WAAY,GACZ,WAAY,CAAC,CACf,EAEaC,EAAiB,CAC5B,kBAAmB,OACnB,mBAAoB,SACpB,QAAS,CAAC,EACV,eAAgB,CAAC,EACjB,iBAAkB,aAClB,iBAAkB,YAClB,WAAY,gBACZ,kBAAmB,QACnB,gBAAiB,yBACjB,QAAS,CAAC,CACZ,ECjBA,OAAS,iBAAAC,EAAe,6BAAAC,EAA2B,kCAAAC,MAAsC,qBACzF,OAAS,YAAAC,MAAgB,4BAalB,SAASC,EAAmBC,EAAmCC,EAA8B,CAElG,IAAMC,EACJD,GAAmB,OAAQE,GAASA,EAAK,SAAS,QAAQ,GAAKA,IAAS,UAAY,CAACA,EAAK,MAAM,SAAS,CAAC,GAAK,CAAC,EAC5GC,EAAwB,OAAO,KAAKJ,EAAO,OAAO,EAGxD,GAAIC,GACF,QAAWI,KAAcD,EACvB,GAAI,CAACH,EAAkB,SAASI,CAAU,GAAKA,IAAe,QAC5D,MAAMR,EAA+B,CAAC,UAAWQ,CAAU,EAAGA,CAAU,EAW9E,IAAMC,EALc,CAAC,GAAG,IAAI,IAAI,CAAC,GAAGJ,EAAoB,GAAGE,CAAqB,CAAC,CAAC,EAAE,OACjFD,GAAS,CAACH,EAAO,eAAe,SAASG,CAAI,CAChD,EAG0E,OAAO,CAACI,EAAKF,KAC9E,CACL,GAAGE,EACH,CAACF,CAAU,EAAGG,EAAoBH,EAAYL,EAAO,QAAQK,CAAU,EAAGJ,CAAiB,CAC7F,GACC,CAAC,CAAC,EAGCQ,EAAa,OAAO,OAAOT,EAAO,MAAM,EAAE,IAAI,CAAC,CAAE,KAAAG,CAAK,IAAMA,CAAI,EAChEO,EAAwB,OAAO,OAAOJ,CAAe,EAAE,IAAI,CAAC,CAAE,KAAAH,CAAK,IAAMA,CAAI,EAC7EQ,EAAiBhB,EAAc,CAAC,GAAGc,EAAY,GAAGC,CAAqB,CAAC,EAC9E,GAAIC,EAAe,OAAS,EAC1B,MAAM,IAAIb,EAAS,0CAA0Ca,EAAe,KAAK,IAAI,GAAG,EAG1F,MAAO,CAAE,QAASL,CAAgB,CACpC,CAcO,SAASE,EAAoBH,EAAoBL,EAAuBC,EAA8B,CAC3G,IAAME,EAAOH,GAAQ,MAAQK,EAAW,MAAM,EAAGT,CAAyB,EACpEgB,EAA4BZ,GAAQ,2BAA6B,GACjEa,EAAab,GAAQ,YAAc,GACnCc,EAAgC,CAAC,EACjCC,EAA8B,CAAC,EAC/BC,EAAahB,GAAU,CAACA,EAAO,WAAaA,EAAO,WAAa,CAAC,EAGvE,QAAWiB,KAAkBD,EAC3B,GAAIC,EAAe,WAAW,IAAI,EAChCH,EAAoB,KAAKG,CAAc,MAClC,CAEL,GAAIhB,GAAqB,CAACA,EAAkB,SAASgB,CAAc,EACjE,MAAMpB,EAA+B,CAAC,UAAWQ,EAAY,YAAY,EAAGY,CAAc,EAE5FF,EAAkB,KAAKE,CAAc,EAIzC,MAAO,CAAE,KAAAd,EAAM,0BAAAS,EAA2B,WAAAC,EAAY,oBAAAC,EAAqB,kBAAAC,CAAkB,CAC/F,CCvFA,OAAS,KAAAG,MAAS,MAClB,OAAS,yBAAAC,EAAuB,oBAAAC,EAAkB,eAAAC,EAAa,aAAAC,MAAiB,qBAGhF,IAAMC,EAAcC,EACdC,EAAcD,EACdE,EAAoBC,EAAE,MAAMJ,EAAY,GAAGK,CAAgB,CAAC,EAAE,QAAQC,EAAgB,UAAU,EAGhGC,EAAgBH,EAAE,aACtBA,EAAE,OAAO,CACP,KAAMI,EAAU,SAAS,EACzB,0BAA2BJ,EAAE,QAAQ,EAAE,QAAQE,EAAgB,wBAAwB,CACzF,CAAC,EACDF,EAAE,mBAAmB,aAAc,CACjCA,EAAE,OAAO,CACP,WAAYA,EAAE,QAAQ,EAAI,EAAE,QAAQE,EAAgB,UAAU,CAChE,CAAC,EACDF,EAAE,OAAO,CACP,WAAYA,EAAE,QAAQ,EAAK,EAC3B,WAAYD,CACd,CAAC,CACH,CAAC,CACH,EAEMM,EAAiBL,EAAE,OAAO,CAC9B,MAAOA,EAAE,MAAM,CAACA,EAAE,OAAO,EAAGA,EAAE,OAAO,EAAGA,EAAE,WAAW,UAAU,CAAC,CAAC,EACjE,KAAMA,EAAE,OAAO,CACjB,CAAC,EACKM,EAAqBN,EAAE,OAAO,CAAE,KAAMA,EAAE,WAAWO,CAAqB,EAAG,MAAOP,EAAE,OAAO,CAAE,CAAC,EAE9FQ,EAAgBR,EAAE,OAAO,CAC7B,KAAMF,EACN,KAAME,EAAE,QAAQ,EAAE,QAAQ,EAAK,EAC/B,KAAMA,EAAE,MAAMA,EAAE,MAAM,CAACK,EAAgBC,CAAkB,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CACzE,CAAC,EAGYG,EAAeT,EAAE,OAAO,CACnC,kBAAmBA,EAAE,OAAO,EAAE,SAAS,EACvC,mBAAoBA,EAAE,OAAO,EAAE,QAAQU,EAAe,kBAAkB,EACxE,QAASV,EAAE,OAAOJ,EAAaO,CAAa,EAAE,QAAQO,EAAe,OAAO,EAC5E,eAAgBV,EAAE,MAAMJ,CAAW,EAAE,QAAQc,EAAe,cAAc,EAC1E,iBAAkBV,EAAE,OAAO,EAAE,QAAQU,EAAe,gBAAgB,EACpE,iBAAkBV,EAAE,OAAO,EAAE,QAAQU,EAAe,gBAAgB,EACpE,WAAYV,EAAE,OAAO,EAAE,QAAQU,EAAe,UAAU,EACxD,kBAAmBV,EAAE,OAAO,EAAE,QAAQU,EAAe,iBAAiB,EACtE,gBAAiBV,EAAE,OAAO,EAAE,QAAQU,EAAe,eAAe,EAClE,QAASV,EAAE,MAAMQ,CAAa,EAAE,QAAQE,EAAe,OAAO,CAChE,CAAC,EAGYC,EAAqBF,EAAa,SAAST,EAAE,IAAI,CAAC","names":["SYSTEM_DEFAULTS","WORLD_DEFAULTS","getDuplicates","STORE_SELECTOR_MAX_LENGTH","UnrecognizedSystemErrorFactory","MUDError","resolveWorldConfig","config","existingContracts","defaultSystemNames","name","overriddenSystemNames","systemName","resolvedSystems","acc","resolveSystemConfig","tableNames","configuredSystemNames","duplicateNames","registerFunctionSelectors","openAccess","accessListAddresses","accessListSystems","accessList","accessListItem","z","DynamicResolutionType","zEthereumAddress","zObjectName","zSelector","zSystemName","zObjectName","zModuleName","zSystemAccessList","z","zEthereumAddress","SYSTEM_DEFAULTS","zSystemConfig","zSelector","zValueWithType","zDynamicResolution","DynamicResolutionType","zModuleConfig","zWorldConfig","WORLD_DEFAULTS","zPluginWorldConfig"]}