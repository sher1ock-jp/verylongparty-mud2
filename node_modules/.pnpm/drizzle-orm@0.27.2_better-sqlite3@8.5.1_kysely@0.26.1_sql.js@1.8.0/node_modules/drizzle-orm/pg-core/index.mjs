import { M as TableAliasProxyHandler, N as PgColumnBuilder, e as entityKind, O as PgColumn, U as pgTableWithSchema, X as pgViewWithSchema, Y as pgMaterializedViewWithSchema, i as is } from '../alias-3e926a50.mjs';
export { _ as Check, Z as CheckBuilder, aU as DefaultViewBuilderCore, at as ForeignKey, as as ForeignKeyBuilder, ax as Index, aw as IndexBuilder, av as IndexBuilderOn, aK as InlineForeignKeys, aZ as ManualMaterializedViewBuilder, aW as ManualViewBuilder, aY as MaterializedViewBuilder, aX as MaterializedViewBuilderCore, a1 as PgArray, a0 as PgArrayBuilder, a3 as PgDate, a2 as PgDateBuilder, a5 as PgDateString, a4 as PgDateStringBuilder, P as PgDialect, a8 as PgJson, a7 as PgJsonBuilder, ab as PgJsonb, aa as PgJsonbBuilder, b2 as PgMaterializedView, b1 as PgMaterializedViewConfig, ae as PgNumeric, ad as PgNumericBuilder, aJ as PgSelect, k as PgSelectBuilder, aI as PgSelectQueryBuilder, aL as PgTable, ai as PgTime, ah as PgTimeBuilder, al as PgTimestamp, ak as PgTimestampBuilder, an as PgTimestampString, am as PgTimestampStringBuilder, aq as PgUUID, ap as PgUUIDBuilder, b0 as PgView, a_ as PgViewBase, a$ as PgViewConfig, aC as PrimaryKey, aB as PrimaryKeyBuilder, h as QueryBuilder, aH as UniqueConstraint, aF as UniqueConstraintBuilder, aG as UniqueOnConstraintBuilder, aV as ViewBuilder, $ as check, a6 as date, ag as decimal, au as foreignKey, aQ as getMaterializedViewConfig, aO as getTableConfig, aP as getViewConfig, ay as index, a9 as json, ac as jsonb, aT as makePgArray, af as numeric, aS as parsePgArray, aR as parsePgNestedArray, b4 as pgMaterializedView, aM as pgTable, aN as pgTableCreator, b3 as pgView, aA as primaryKey, aj as time, ao as timestamp, aD as unique, az as uniqueIndex, aE as uniqueKeyName, ar as uuid } from '../alias-3e926a50.mjs';
export { c as PgDatabase, d as PgDelete, f as PgInsert, e as PgInsertBuilder, g as PgRefreshMaterializedView, a as PgSession, b as PgTransaction, i as PgUpdate, h as PgUpdateBuilder, P as PreparedQuery } from '../session-2062e9e6.mjs';
import '../errors-fed11085.mjs';

function alias(table, alias) {
    return new Proxy(table, new TableAliasProxyHandler(alias, false));
}

class PgBigInt53Builder extends PgColumnBuilder {
    static [entityKind] = 'PgBigInt53Builder';
    /** @internal */
    build(table) {
        return new PgBigInt53(table, this.config);
    }
}
class PgBigInt53 extends PgColumn {
    static [entityKind] = 'PgBigInt53';
    getSQLType() {
        return 'bigint';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'number') {
            return value;
        }
        return Number(value);
    }
}
class PgBigInt64Builder extends PgColumnBuilder {
    static [entityKind] = 'PgBigInt64Builder';
    /** @internal */
    build(table) {
        return new PgBigInt64(table, this.config);
    }
}
class PgBigInt64 extends PgColumn {
    static [entityKind] = 'PgBigInt64';
    getSQLType() {
        return 'bigint';
    }
    // eslint-disable-next-line unicorn/prefer-native-coercion-functions
    mapFromDriverValue(value) {
        return BigInt(value);
    }
}
function bigint(name, config) {
    if (config.mode === 'number') {
        return new PgBigInt53Builder(name);
    }
    return new PgBigInt64Builder(name);
}

class PgBigSerial53Builder extends PgColumnBuilder {
    static [entityKind] = 'PgBigSerial53Builder';
    constructor(name) {
        super(name);
        this.config.hasDefault = true;
        this.config.notNull = true;
    }
    /** @internal */
    build(table) {
        return new PgBigSerial53(table, this.config);
    }
}
class PgBigSerial53 extends PgColumn {
    static [entityKind] = 'PgBigSerial53';
    getSQLType() {
        return 'bigserial';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'number') {
            return value;
        }
        return Number(value);
    }
}
class PgBigSerial64Builder extends PgColumnBuilder {
    static [entityKind] = 'PgBigSerial64Builder';
    constructor(name) {
        super(name);
        this.config.hasDefault = true;
    }
    /** @internal */
    build(table) {
        return new PgBigSerial64(table, this.config);
    }
}
class PgBigSerial64 extends PgColumn {
    static [entityKind] = 'PgBigSerial64';
    getSQLType() {
        return 'bigserial';
    }
    // eslint-disable-next-line unicorn/prefer-native-coercion-functions
    mapFromDriverValue(value) {
        return BigInt(value);
    }
}
function bigserial(name, { mode }) {
    if (mode === 'number') {
        return new PgBigSerial53Builder(name);
    }
    return new PgBigSerial64Builder(name);
}

class PgBooleanBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgBooleanBuilder';
    /** @internal */
    build(table) {
        return new PgBoolean(table, this.config);
    }
}
class PgBoolean extends PgColumn {
    static [entityKind] = 'PgBoolean';
    getSQLType() {
        return 'boolean';
    }
}
function boolean(name) {
    return new PgBooleanBuilder(name);
}

class PgCharBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgCharBuilder';
    constructor(name, config) {
        super(name);
        this.config.length = config.length;
        this.config.enumValues = (config.enum ?? []);
    }
    /** @internal */
    build(table) {
        return new PgChar(table, this.config);
    }
}
class PgChar extends PgColumn {
    static [entityKind] = 'PgChar';
    length = this.config.length;
    enumValues = this.config.enumValues;
    getSQLType() {
        return this.length === undefined ? `char` : `char(${this.length})`;
    }
}
function char(name, config = {}) {
    return new PgCharBuilder(name, config);
}

class PgCidrBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgCidrBuilder';
    /** @internal */
    build(table) {
        return new PgCidr(table, this.config);
    }
}
class PgCidr extends PgColumn {
    static [entityKind] = 'PgCidr';
    getSQLType() {
        return 'cidr';
    }
}
function cidr(name) {
    return new PgCidrBuilder(name);
}

class PgCustomColumnBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgCustomColumnBuilder';
    constructor(name, fieldConfig, customTypeParams) {
        super(name);
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
    }
    /** @internal */
    build(table) {
        return new PgCustomColumn(table, this.config);
    }
}
class PgCustomColumn extends PgColumn {
    static [entityKind] = 'PgCustomColumn';
    sqlName;
    mapTo;
    mapFrom;
    constructor(table, config) {
        super(table, config);
        this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
        this.mapTo = config.customTypeParams.toDriver;
        this.mapFrom = config.customTypeParams.fromDriver;
    }
    getSQLType() {
        return this.sqlName;
    }
    mapFromDriverValue(value) {
        return typeof this.mapFrom === 'function' ? this.mapFrom(value) : value;
    }
    mapToDriverValue(value) {
        return typeof this.mapTo === 'function' ? this.mapTo(value) : value;
    }
}
/**
 * Custom pg database data type generator
 */
function customType(customTypeParams) {
    return (dbName, fieldConfig) => {
        return new PgCustomColumnBuilder(dbName, fieldConfig, customTypeParams);
    };
}

class PgDoublePrecisionBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgDoublePrecisionBuilder';
    /** @internal */
    build(table) {
        return new PgDoublePrecision(table, this.config);
    }
}
class PgDoublePrecision extends PgColumn {
    static [entityKind] = 'PgDoublePrecision';
    getSQLType() {
        return 'double precision';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            return Number.parseFloat(value);
        }
        return value;
    }
}
function doublePrecision(name) {
    return new PgDoublePrecisionBuilder(name);
}

const isPgEnumSym = Symbol.for('drizzle:isPgEnum');
function isPgEnum(obj) {
    return !!obj && typeof obj === 'function' && isPgEnumSym in obj;
}
class PgEnumColumnBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgEnumColumnBuilder';
    constructor(name, enumInstance) {
        super(name);
        this.config.enum = enumInstance;
    }
    /** @internal */
    build(table) {
        return new PgEnumColumn(table, this.config);
    }
}
class PgEnumColumn extends PgColumn {
    static [entityKind] = 'PgEnumColumn';
    enum = this.config.enum;
    enumValues = this.config.enum.enumValues;
    constructor(table, config) {
        super(table, config);
        this.enum = config.enum;
    }
    getSQLType() {
        return this.enum.enumName;
    }
}
// Gratitude to zod for the enum function types
function pgEnum(enumName, values) {
    const enumInstance = Object.assign((name) => new PgEnumColumnBuilder(name, enumInstance), {
        enumName,
        enumValues: values,
        [isPgEnumSym]: true,
    });
    return enumInstance;
}

class PgInetBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgInetBuilder';
    /** @internal */
    build(table) {
        return new PgInet(table, this.config);
    }
}
class PgInet extends PgColumn {
    static [entityKind] = 'PgInet';
    getSQLType() {
        return 'inet';
    }
}
function inet(name) {
    return new PgInetBuilder(name);
}

class PgIntegerBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgIntegerBuilder';
    /** @internal */
    build(table) {
        return new PgInteger(table, this.config);
    }
}
class PgInteger extends PgColumn {
    static [entityKind] = 'PgInteger';
    getSQLType() {
        return 'integer';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            return Number.parseInt(value);
        }
        return value;
    }
}
function integer(name) {
    return new PgIntegerBuilder(name);
}

class PgIntervalBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgIntervalBuilder';
    constructor(name, intervalConfig) {
        super(name);
        this.config.intervalConfig = intervalConfig;
    }
    /** @internal */
    build(table) {
        return new PgInterval(table, this.config);
    }
}
class PgInterval extends PgColumn {
    static [entityKind] = 'PgInterval';
    fields = this.config.intervalConfig.fields;
    precision = this.config.intervalConfig.precision;
    getSQLType() {
        const fields = this.fields ? ` ${this.fields}` : '';
        const precision = this.precision ? `(${this.precision})` : '';
        return `interval${fields}${precision}`;
    }
}
function interval(name, config = {}) {
    return new PgIntervalBuilder(name, config);
}

class PgMacaddrBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgMacaddrBuilder';
    /** @internal */
    build(table) {
        return new PgMacaddr(table, this.config);
    }
}
class PgMacaddr extends PgColumn {
    static [entityKind] = 'PgMacaddr';
    getSQLType() {
        return 'macaddr';
    }
}
function macaddr(name) {
    return new PgMacaddrBuilder(name);
}

class PgMacaddr8Builder extends PgColumnBuilder {
    static [entityKind] = 'PgMacaddr8Builder';
    /** @internal */
    build(table) {
        return new PgMacaddr8(table, this.config);
    }
}
class PgMacaddr8 extends PgColumn {
    static [entityKind] = 'PgMacaddr8';
    getSQLType() {
        return 'macaddr8';
    }
}
function macaddr8(name) {
    return new PgMacaddr8Builder(name);
}

class PgRealBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgRealBuilder';
    constructor(name, length) {
        super(name);
        this.config.length = length;
    }
    /** @internal */
    build(table) {
        return new PgReal(table, this.config);
    }
}
class PgReal extends PgColumn {
    static [entityKind] = 'PgReal';
    constructor(table, config) {
        super(table, config);
    }
    getSQLType() {
        return 'real';
    }
    mapFromDriverValue = (value) => {
        if (typeof value === 'string') {
            return Number.parseFloat(value);
        }
        return value;
    };
}
function real(name) {
    return new PgRealBuilder(name);
}

class PgSerialBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgSerialBuilder';
    constructor(name) {
        super(name);
        this.config.hasDefault = true;
        this.config.notNull = true;
    }
    /** @internal */
    build(table) {
        return new PgSerial(table, this.config);
    }
}
class PgSerial extends PgColumn {
    static [entityKind] = 'PgSerial';
    getSQLType() {
        return 'serial';
    }
}
function serial(name) {
    return new PgSerialBuilder(name);
}

class PgSmallIntBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgSmallIntBuilder';
    /** @internal */
    build(table) {
        return new PgSmallInt(table, this.config);
    }
}
class PgSmallInt extends PgColumn {
    static [entityKind] = 'PgSmallInt';
    getSQLType() {
        return 'smallint';
    }
    mapFromDriverValue = (value) => {
        if (typeof value === 'string') {
            return Number(value);
        }
        return value;
    };
}
function smallint(name) {
    return new PgSmallIntBuilder(name);
}

class PgSmallSerialBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgSmallSerialBuilder';
    constructor(name) {
        super(name);
        this.config.hasDefault = true;
        this.config.notNull = true;
    }
    /** @internal */
    build(table) {
        return new PgSmallSerial(table, this.config);
    }
}
class PgSmallSerial extends PgColumn {
    static [entityKind] = 'PgSmallSerial';
    getSQLType() {
        return 'serial';
    }
}
function smallserial(name) {
    return new PgSmallSerialBuilder(name);
}

class PgTextBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgTextBuilder';
    constructor(name, config) {
        super(name);
        this.config.enumValues = (config.enum ?? []);
    }
    /** @internal */
    build(table) {
        return new PgText(table, this.config);
    }
}
class PgText extends PgColumn {
    static [entityKind] = 'PgText';
    enumValues = this.config.enumValues;
    getSQLType() {
        return 'text';
    }
}
function text(name, config = {}) {
    return new PgTextBuilder(name, config);
}

class PgVarcharBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgVarcharBuilder';
    constructor(name, config) {
        super(name);
        this.config.length = config.length;
        this.config.enumValues = (config.enum ?? []);
    }
    /** @internal */
    build(table) {
        return new PgVarchar(table, this.config);
    }
}
class PgVarchar extends PgColumn {
    static [entityKind] = 'PgVarchar';
    length = this.config.length;
    enumValues = this.config.enumValues;
    getSQLType() {
        return this.length === undefined ? `varchar` : `varchar(${this.length})`;
    }
}
function varchar(name, config = {}) {
    return new PgVarcharBuilder(name, config);
}

class PgSchema {
    schemaName;
    static [entityKind] = 'PgSchema';
    constructor(schemaName) {
        this.schemaName = schemaName;
    }
    table = ((name, columns, extraConfig) => {
        return pgTableWithSchema(name, columns, extraConfig, this.schemaName);
    });
    view = ((name, columns) => {
        return pgViewWithSchema(name, columns, this.schemaName);
    });
    materializedView = ((name, columns) => {
        return pgMaterializedViewWithSchema(name, columns, this.schemaName);
    });
}
function isPgSchema(obj) {
    return is(obj, PgSchema);
}
function pgSchema(name) {
    if (name === 'public') {
        throw new Error(`You can't specify 'public' as schema name. Postgres is using public schema by default. If you want to use 'public' schema, just use pgTable() instead of creating a schema`);
    }
    return new PgSchema(name);
}

export { PgBigInt53, PgBigInt53Builder, PgBigInt64, PgBigInt64Builder, PgBigSerial53, PgBigSerial53Builder, PgBigSerial64, PgBigSerial64Builder, PgBoolean, PgBooleanBuilder, PgChar, PgCharBuilder, PgCidr, PgCidrBuilder, PgColumn, PgColumnBuilder, PgCustomColumn, PgCustomColumnBuilder, PgDoublePrecision, PgDoublePrecisionBuilder, PgEnumColumn, PgEnumColumnBuilder, PgInet, PgInetBuilder, PgInteger, PgIntegerBuilder, PgInterval, PgIntervalBuilder, PgMacaddr, PgMacaddr8, PgMacaddr8Builder, PgMacaddrBuilder, PgReal, PgRealBuilder, PgSchema, PgSerial, PgSerialBuilder, PgSmallInt, PgSmallIntBuilder, PgSmallSerial, PgSmallSerialBuilder, PgText, PgTextBuilder, PgVarchar, PgVarcharBuilder, alias, bigint, bigserial, boolean, char, cidr, customType, doublePrecision, inet, integer, interval, isPgEnum, isPgSchema, macaddr, macaddr8, pgEnum, pgMaterializedViewWithSchema, pgSchema, pgTableWithSchema, pgViewWithSchema, real, serial, smallint, smallserial, text, varchar };
//# sourceMappingURL=index.mjs.map
