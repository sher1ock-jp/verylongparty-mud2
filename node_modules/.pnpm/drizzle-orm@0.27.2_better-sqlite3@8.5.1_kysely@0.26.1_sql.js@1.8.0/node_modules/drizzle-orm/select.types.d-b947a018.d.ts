import { a as SQL, e as entityKind, ap as TableConfig$1, T as Table, aq as UpdateTableConfig, v as BuildColumns, o as ColumnBuilderHKTBase, aD as Assume, l as ColumnBuilderBaseConfig, c as ColumnHKTBase, C as ColumnBaseConfig, s as ColumnBuilder, aA as Update, f as ColumnHKT, g as Column, r as ColumnBuilderRuntimeConfig, u as UpdateCBConfig, ay as UpdateSet, S as Simplify, G as GetColumnData, a1 as SQLWrapper, Q as Query, ae as Param, I as InferModel, ai as Placeholder, A as AnyColumn, aN as KnownKeysOnly, aQ as ColumnsSelection, am as Subquery, an as WithSubquery, aF as DrizzleTypeError, aE as Equal, aG as ValueOrArray, V as View, as as AnyTable, K as SelectedFieldsFlat$1, X as SelectedFields$1, Y as SelectedFieldsOrdered$1 } from './column.d-aa4e525d.js';
import { A as AddAliasToSelection, T as TypedQueryBuilder, G as GetSelectTableName, a as GetSelectTableSelection, S as SelectMode, J as JoinNullability, B as BuildSubquerySelection, b as SelectResult, c as JoinType, M as MapColumnsToTableAlias, d as AppendToResult, e as AppendToNullabilityMap } from './select.types.d-eff54486.js';
import { Q as QueryPromise, T as TablesRelationalConfig, K as TableRelationalConfig, J as DBQueryConfig, a2 as BuildRelationalQueryResult, U as BuildQueryResult, L as ExtractTablesWithRelations, R as RelationalSchemaConfig } from './query-promise.d-0dd411fc.js';
import { ResultSetHeader } from 'mysql2/promise';
import { MigrationMeta, MigrationConfig } from './migrator.js';

declare class CheckBuilder {
    name: string;
    value: SQL;
    static readonly [entityKind]: string;
    protected brand: 'MySqlConstraintBuilder';
    constructor(name: string, value: SQL);
}
declare class Check {
    table: AnyMySqlTable;
    static readonly [entityKind]: string;
    readonly name: string;
    readonly value: SQL;
    constructor(table: AnyMySqlTable, builder: CheckBuilder);
}
declare function check(name: string, value: SQL): CheckBuilder;

interface IndexConfig {
    name: string;
    columns: IndexColumn[];
    /**
     * If true, the index will be created as `create unique index` instead of `create index`.
     */
    unique?: boolean;
    /**
     * If set, the index will be created as `create index ... using { 'btree' | 'hash' }`.
     */
    using?: 'btree' | 'hash';
    /**
     * If set, the index will be created as `create index ... algorythm { 'default' | 'inplace' | 'copy' }`.
     */
    algorythm?: 'default' | 'inplace' | 'copy';
    /**
     * If set, adds locks to the index creation.
     */
    lock?: 'default' | 'none' | 'shared' | 'exclusive';
}
type IndexColumn = AnyMySqlColumn | SQL;
declare class IndexBuilderOn {
    private name;
    private unique;
    static readonly [entityKind]: string;
    constructor(name: string, unique: boolean);
    on(...columns: [IndexColumn, ...IndexColumn[]]): IndexBuilder;
}
interface AnyIndexBuilder {
    build(table: AnyMySqlTable): Index;
}
interface IndexBuilder extends AnyIndexBuilder {
}
declare class IndexBuilder implements AnyIndexBuilder {
    static readonly [entityKind]: string;
    constructor(name: string, columns: IndexColumn[], unique: boolean);
    using(using: IndexConfig['using']): Omit<this, 'using'>;
    algorythm(algorythm: IndexConfig['algorythm']): Omit<this, 'algorythm'>;
    lock(lock: IndexConfig['lock']): Omit<this, 'lock'>;
}
declare class Index {
    static readonly [entityKind]: string;
    readonly config: IndexConfig & {
        table: AnyMySqlTable;
    };
    constructor(config: IndexConfig, table: AnyMySqlTable);
}
type GetColumnsTableName<TColumns> = TColumns extends AnyMySqlColumn<{
    tableName: infer TTableName extends string;
}> | AnyMySqlColumn<{
    tableName: infer TTableName extends string;
}>[] ? TTableName : never;
declare function index(name: string): IndexBuilderOn;
declare function uniqueIndex(name: string): IndexBuilderOn;

declare function primaryKey<TTableName extends string, TColumns extends AnyMySqlColumn<{
    tableName: TTableName;
}>[]>(...columns: TColumns): PrimaryKeyBuilder;
declare class PrimaryKeyBuilder {
    static readonly [entityKind]: string;
    constructor(columns: AnyMySqlColumn[]);
}
declare class PrimaryKey {
    readonly table: AnyMySqlTable;
    static readonly [entityKind]: string;
    readonly columns: AnyMySqlColumn<{}>[];
    constructor(table: AnyMySqlTable, columns: AnyMySqlColumn<{}>[]);
    getName(): string;
}

declare function unique(name?: string): UniqueOnConstraintBuilder;
declare function uniqueKeyName(table: AnyMySqlTable, columns: string[]): string;
declare class UniqueConstraintBuilder {
    private name?;
    static readonly [entityKind]: string;
    constructor(columns: AnyMySqlColumn[], name?: string | undefined);
}
declare class UniqueOnConstraintBuilder {
    static readonly [entityKind]: string;
    constructor(name?: string);
    on(...columns: [AnyMySqlColumn, ...AnyMySqlColumn[]]): UniqueConstraintBuilder;
}
declare class UniqueConstraint {
    readonly table: AnyMySqlTable;
    static readonly [entityKind]: string;
    readonly columns: AnyMySqlColumn<{}>[];
    readonly name?: string;
    readonly nullsNotDistinct: boolean;
    constructor(table: AnyMySqlTable, columns: AnyMySqlColumn<{}>[], name?: string);
    getName(): string | undefined;
}

type MySqlTableExtraConfig = Record<string, AnyIndexBuilder | CheckBuilder | ForeignKeyBuilder | PrimaryKeyBuilder | UniqueConstraintBuilder>;
type TableConfig = TableConfig$1<AnyMySqlColumn>;
declare class MySqlTable<T extends TableConfig> extends Table<T> {
    static readonly [entityKind]: string;
    protected $columns: T['columns'];
}
type AnyMySqlTable<TPartial extends Partial<TableConfig> = {}> = MySqlTable<UpdateTableConfig<TableConfig, TPartial>>;
type MySqlTableWithColumns<T extends TableConfig> = MySqlTable<T> & {
    [Key in keyof T['columns']]: T['columns'][Key];
};
declare function mysqlTableWithSchema<TTableName extends string, TSchemaName extends string | undefined, TColumnsMap extends Record<string, AnyMySqlColumnBuilder>>(name: TTableName, columns: TColumnsMap, extraConfig: ((self: BuildColumns<TTableName, TColumnsMap>) => MySqlTableExtraConfig) | undefined, schema: TSchemaName, baseName?: TTableName): MySqlTableWithColumns<{
    name: TTableName;
    schema: TSchemaName;
    columns: BuildColumns<TTableName, TColumnsMap>;
}>;
interface MySqlTableFn<TSchemaName extends string | undefined = undefined> {
    <TTableName extends string, TColumnsMap extends Record<string, AnyMySqlColumnBuilder>>(name: TTableName, columns: TColumnsMap, extraConfig?: (self: BuildColumns<TTableName, TColumnsMap>) => MySqlTableExtraConfig): MySqlTableWithColumns<{
        name: TTableName;
        schema: TSchemaName;
        columns: BuildColumns<TTableName, TColumnsMap>;
    }>;
}
declare const mysqlTable: MySqlTableFn;
declare function mysqlTableCreator(customizeTableName: (name: string) => string): MySqlTableFn;

type UpdateDeleteAction = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';
type Reference = () => {
    readonly columns: AnyMySqlColumn[];
    readonly foreignTable: AnyMySqlTable;
    readonly foreignColumns: AnyMySqlColumn[];
};
declare class ForeignKeyBuilder {
    static readonly [entityKind]: string;
    constructor(config: () => {
        columns: AnyMySqlColumn[];
        foreignColumns: AnyMySqlColumn[];
    }, actions?: {
        onUpdate?: UpdateDeleteAction;
        onDelete?: UpdateDeleteAction;
    } | undefined);
    onUpdate(action: UpdateDeleteAction): this;
    onDelete(action: UpdateDeleteAction): this;
}
type AnyForeignKeyBuilder = ForeignKeyBuilder;
declare class ForeignKey {
    readonly table: AnyMySqlTable;
    static readonly [entityKind]: string;
    readonly reference: Reference;
    readonly onUpdate: UpdateDeleteAction | undefined;
    readonly onDelete: UpdateDeleteAction | undefined;
    constructor(table: AnyMySqlTable, builder: ForeignKeyBuilder);
    getName(): string;
}
type ColumnsWithTable<TTableName extends string, TColumns extends AnyMySqlColumn[]> = {
    [Key in keyof TColumns]: AnyMySqlColumn<{
        tableName: TTableName;
    }>;
};
type GetColumnsTable<TColumns extends AnyMySqlColumn | AnyMySqlColumn[]> = (TColumns extends AnyMySqlColumn ? TColumns : TColumns extends AnyMySqlColumn[] ? TColumns[number] : never) extends AnyMySqlColumn<{
    tableName: infer TTableName extends string;
}> ? TTableName : never;
declare function foreignKey<TTableName extends string, TForeignTableName extends string, TColumns extends [AnyMySqlColumn<{
    tableName: TTableName;
}>, ...AnyMySqlColumn<{
    tableName: TTableName;
}>[]]>(config: {
    columns: TColumns;
    foreignColumns: ColumnsWithTable<TForeignTableName, TColumns>;
}): ForeignKeyBuilder;

interface ReferenceConfig {
    ref: () => AnyMySqlColumn;
    actions: {
        onUpdate?: UpdateDeleteAction;
        onDelete?: UpdateDeleteAction;
    };
}
interface MySqlColumnBuilderHKT extends ColumnBuilderHKTBase {
    _type: MySqlColumnBuilder<MySqlColumnBuilderHKT, Assume<this['config'], ColumnBuilderBaseConfig>>;
    _columnHKT: MySqlColumnHKT;
}
interface MySqlColumnHKT extends ColumnHKTBase {
    _type: MySqlColumn<MySqlColumnHKT, Assume<this['config'], ColumnBaseConfig>>;
}
declare abstract class MySqlColumnBuilder<THKT extends ColumnBuilderHKTBase, T extends ColumnBuilderBaseConfig, TRuntimeConfig extends object = {}, TTypeConfig extends object = {}> extends ColumnBuilder<THKT, T, TRuntimeConfig, TTypeConfig & {
    mysqlBrand: 'MySqlColumnBuilder';
}> {
    static readonly [entityKind]: string;
    private foreignKeyConfigs;
    references(ref: ReferenceConfig['ref'], actions?: ReferenceConfig['actions']): this;
    unique(name?: string): this;
}
type AnyMySqlColumnBuilder<TPartial extends Partial<ColumnBuilderBaseConfig> = {}> = MySqlColumnBuilder<MySqlColumnBuilderHKT, Required<Update<ColumnBuilderBaseConfig, TPartial>>>;
declare abstract class MySqlColumn<THKT extends ColumnHKT, T extends ColumnBaseConfig, TRuntimeConfig extends object = {}> extends Column<THKT, T, TRuntimeConfig, {
    mysqlBrand: 'MySqlColumn';
}> {
    readonly table: AnyMySqlTable;
    static readonly [entityKind]: string;
    constructor(table: AnyMySqlTable, config: ColumnBuilderRuntimeConfig<T['data']> & TRuntimeConfig);
}
type AnyMySqlColumn<TPartial extends Partial<ColumnBaseConfig> = {}> = MySqlColumn<MySqlColumnHKT, Required<Update<ColumnBaseConfig, TPartial>>>;
interface MySqlColumnWithAutoIncrementConfig {
    autoIncrement: boolean;
}
declare abstract class MySqlColumnBuilderWithAutoIncrement<THKT extends ColumnBuilderHKTBase, T extends ColumnBuilderBaseConfig, TRuntimeConfig extends object = {}> extends MySqlColumnBuilder<THKT, T, TRuntimeConfig & MySqlColumnWithAutoIncrementConfig> {
    static readonly [entityKind]: string;
    constructor(name: NonNullable<T['name']>);
    autoincrement(): MySqlColumnBuilderWithAutoIncrement<THKT, UpdateCBConfig<T, {
        hasDefault: true;
    }>, TRuntimeConfig>;
}
declare abstract class MySqlColumnWithAutoIncrement<THKT extends ColumnHKT, T extends ColumnBaseConfig, TRuntimeConfig extends object = {}> extends MySqlColumn<THKT, T, MySqlColumnWithAutoIncrementConfig & TRuntimeConfig> {
    static readonly [entityKind]: string;
    readonly autoIncrement: boolean;
}

interface MySqlUpdateConfig {
    where?: SQL | undefined;
    set: UpdateSet;
    table: AnyMySqlTable;
    returning?: SelectedFieldsOrdered;
}
type MySqlUpdateSetSource<TTable extends AnyMySqlTable> = Simplify<{
    [Key in keyof TTable['_']['columns']]?: GetColumnData<TTable['_']['columns'][Key], 'query'> | SQL;
}>;
declare class MySqlUpdateBuilder<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> {
    private table;
    private session;
    private dialect;
    static readonly [entityKind]: string;
    protected $table: TTable;
    constructor(table: TTable, session: MySqlSession, dialect: MySqlDialect);
    set(values: MySqlUpdateSetSource<TTable>): MySqlUpdate<TTable, TQueryResult, TPreparedQueryHKT>;
}
interface MySqlUpdate<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>>, SQLWrapper {
}
declare class MySqlUpdate<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    protected $table: TTable;
    private config;
    constructor(table: TTable, set: UpdateSet, session: MySqlSession, dialect: MySqlDialect);
    where(where: SQL | undefined): Omit<this, 'where'>;
    toSQL(): Omit<Query, 'typings'>;
    prepare(): Assume<(TPreparedQueryHKT & {
        readonly config: PreparedQueryConfig & {
            execute: QueryResultKind<TQueryResult, never>;
            iterator: never;
        };
    })["type"], PreparedQuery<PreparedQueryConfig & {
        execute: QueryResultKind<TQueryResult, never>;
        iterator: never;
    }>>;
    execute: ReturnType<this['prepare']>['execute'];
    private createIterator;
    iterator: ReturnType<this["prepare"]>["iterator"];
}

interface MySqlInsertConfig<TTable extends AnyMySqlTable = AnyMySqlTable> {
    table: TTable;
    values: Record<string, Param | SQL>[];
    ignore: boolean;
    onConflict?: SQL;
}
type AnyMySqlInsertConfig = MySqlInsertConfig<AnyMySqlTable>;
type MySqlInsertValue<TTable extends AnyMySqlTable> = Simplify<{
    [Key in keyof InferModel<TTable, 'insert'>]: InferModel<TTable, 'insert'>[Key] | SQL | Placeholder;
}>;
declare class MySqlInsertBuilder<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> {
    private table;
    private session;
    private dialect;
    static readonly [entityKind]: string;
    private shouldIgnore;
    constructor(table: TTable, session: MySqlSession, dialect: MySqlDialect);
    ignore(): this;
    values(value: MySqlInsertValue<TTable>): MySqlInsert<TTable, TQueryResult, TPreparedQueryHKT>;
    values(values: MySqlInsertValue<TTable>[]): MySqlInsert<TTable, TQueryResult, TPreparedQueryHKT>;
}
interface MySqlInsert<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>>, SQLWrapper {
}
declare class MySqlInsert<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    protected $table: TTable;
    private config;
    constructor(table: TTable, values: MySqlInsertConfig['values'], ignore: boolean, session: MySqlSession, dialect: MySqlDialect);
    onDuplicateKeyUpdate(config: {
        set: MySqlUpdateSetSource<TTable>;
    }): this;
    toSQL(): Simplify<Omit<Query, 'typings'>>;
    prepare(): Assume<(TPreparedQueryHKT & {
        readonly config: PreparedQueryConfig & {
            execute: QueryResultKind<TQueryResult, never>;
            iterator: never;
        };
    })["type"], PreparedQuery<PreparedQueryConfig & {
        execute: QueryResultKind<TQueryResult, never>;
        iterator: never;
    }>>;
    execute: ReturnType<this['prepare']>['execute'];
    private createIterator;
    iterator: ReturnType<this["prepare"]>["iterator"];
}

declare class MySqlDialect {
    static readonly [entityKind]: string;
    migrate(migrations: MigrationMeta[], session: MySqlSession, config: MigrationConfig): Promise<void>;
    escapeName(name: string): string;
    escapeParam(_num: number): string;
    escapeString(str: string): string;
    buildDeleteQuery({ table, where, returning }: MySqlDeleteConfig): SQL;
    buildUpdateSet(table: AnyMySqlTable, set: UpdateSet): SQL;
    buildUpdateQuery({ table, set, where, returning }: MySqlUpdateConfig): SQL;
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    private buildSelection;
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, lockingClause, distinct, }: MySqlSelectConfig): SQL;
    buildInsertQuery({ table, values, ignore, onConflict }: MySqlInsertConfig): SQL;
    sqlToQuery(sql: SQL): Query;
    buildRelationalQuery(fullSchema: Record<string, unknown>, schema: TablesRelationalConfig, tableNamesMap: Record<string, string>, table: AnyMySqlTable, tableConfig: TableRelationalConfig, config: true | DBQueryConfig<'many', true>, tableAlias: string, relationColumns: AnyColumn[], isRoot?: boolean): BuildRelationalQueryResult;
}

declare class RelationalQueryBuilder<TPreparedQueryHKT extends PreparedQueryHKTBase, TSchema extends TablesRelationalConfig, TFields extends TableRelationalConfig> {
    private fullSchema;
    private schema;
    private tableNamesMap;
    private table;
    private tableConfig;
    private dialect;
    private session;
    static readonly [entityKind]: string;
    constructor(fullSchema: Record<string, unknown>, schema: TSchema, tableNamesMap: Record<string, string>, table: AnyMySqlTable, tableConfig: TableRelationalConfig, dialect: MySqlDialect, session: MySqlSession);
    findMany<TConfig extends DBQueryConfig<'many', true, TSchema, TFields>>(config?: KnownKeysOnly<TConfig, DBQueryConfig<'many', true, TSchema, TFields>>): MySqlRelationalQuery<TPreparedQueryHKT, BuildQueryResult<TSchema, TFields, TConfig>[]>;
    findFirst<TSelection extends Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>(config?: KnownKeysOnly<TSelection, Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>): MySqlRelationalQuery<TPreparedQueryHKT, BuildQueryResult<TSchema, TFields, TSelection> | undefined>;
}
declare class MySqlRelationalQuery<TPreparedQueryHKT extends PreparedQueryHKTBase, TResult> extends QueryPromise<TResult> {
    private fullSchema;
    private schema;
    private tableNamesMap;
    private table;
    private tableConfig;
    private dialect;
    private session;
    private config;
    private mode;
    static readonly [entityKind]: string;
    protected $brand: 'MySqlRelationalQuery';
    constructor(fullSchema: Record<string, unknown>, schema: TablesRelationalConfig, tableNamesMap: Record<string, string>, table: AnyMySqlTable, tableConfig: TableRelationalConfig, dialect: MySqlDialect, session: MySqlSession, config: DBQueryConfig<'many', true> | true, mode: 'many' | 'first');
    prepare(): Assume<(TPreparedQueryHKT & {
        readonly config: PreparedQueryConfig & {
            execute: TResult;
        };
    })["type"], PreparedQuery<PreparedQueryConfig & {
        execute: TResult;
    }>>;
    execute(): Promise<TResult>;
}

type SubqueryWithSelection<TSelection extends ColumnsSelection, TAlias extends string> = Subquery<TAlias, AddAliasToSelection<TSelection, TAlias>> & AddAliasToSelection<TSelection, TAlias>;
type WithSubqueryWithSelection<TSelection extends ColumnsSelection, TAlias extends string> = WithSubquery<TAlias, AddAliasToSelection<TSelection, TAlias>> & AddAliasToSelection<TSelection, TAlias>;

declare class MySqlDatabase<TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase, TFullSchema extends Record<string, unknown> = {}, TSchema extends TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>> {
    static readonly [entityKind]: string;
    readonly _: {
        readonly schema: TSchema | undefined;
        readonly tableNamesMap: Record<string, string>;
    };
    query: TFullSchema extends Record<string, never> ? DrizzleTypeError<'Seems like the schema generic is missing - did you forget to add it to your DB type?'> : {
        [K in keyof TSchema]: RelationalQueryBuilder<TPreparedQueryHKT, TSchema, TSchema[K]>;
    };
    constructor(
    /** @internal */
    dialect: MySqlDialect, 
    /** @internal */
    session: MySqlSession<any, any, any, any>, schema: RelationalSchemaConfig<TSchema> | undefined);
    $with<TAlias extends string>(alias: TAlias): {
        as<TSelection extends ColumnsSelection>(qb: TypedQueryBuilder<TSelection, unknown> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection, unknown>)): WithSubqueryWithSelection<TSelection, TAlias>;
    };
    with(...queries: WithSubquery[]): {
        select: {
            (): MySqlSelectBuilder<undefined, TPreparedQueryHKT>;
            <TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, TPreparedQueryHKT, "db">;
        };
        selectDistinct: {
            (): MySqlSelectBuilder<undefined, TPreparedQueryHKT>;
            <TSelection_1 extends SelectedFields>(fields: TSelection_1): MySqlSelectBuilder<TSelection_1, TPreparedQueryHKT, "db">;
        };
    };
    select(): MySqlSelectBuilder<undefined, TPreparedQueryHKT>;
    select<TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, TPreparedQueryHKT>;
    selectDistinct(): MySqlSelectBuilder<undefined, TPreparedQueryHKT>;
    selectDistinct<TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, TPreparedQueryHKT>;
    update<TTable extends AnyMySqlTable>(table: TTable): MySqlUpdateBuilder<TTable, TQueryResult, TPreparedQueryHKT>;
    insert<TTable extends AnyMySqlTable>(table: TTable): MySqlInsertBuilder<TTable, TQueryResult, TPreparedQueryHKT>;
    delete<TTable extends AnyMySqlTable>(table: TTable): MySqlDelete<TTable, TQueryResult, TPreparedQueryHKT>;
    execute<T extends {
        [column: string]: any;
    } = ResultSetHeader>(query: SQLWrapper): Promise<QueryResultKind<TQueryResult, T>>;
    transaction<T>(transaction: (tx: MySqlTransaction<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema>, config?: MySqlTransactionConfig) => Promise<T>, config?: MySqlTransactionConfig): Promise<T>;
}

interface QueryResultHKT {
    readonly $brand: 'MySqlQueryRowHKT';
    readonly row: unknown;
    readonly type: unknown;
}
type QueryResultKind<TKind extends QueryResultHKT, TRow> = (TKind & {
    readonly row: TRow;
})['type'];
interface PreparedQueryConfig {
    execute: unknown;
    iterator: unknown;
}
interface PreparedQueryHKT {
    readonly $brand: 'MySqlPreparedQueryHKT';
    readonly config: unknown;
    readonly type: unknown;
}
type PreparedQueryKind<TKind extends PreparedQueryHKT, TConfig extends PreparedQueryConfig, TAssume extends boolean = false> = Equal<TAssume, true> extends true ? Assume<(TKind & {
    readonly config: TConfig;
})['type'], PreparedQuery<TConfig>> : (TKind & {
    readonly config: TConfig;
})['type'];
declare abstract class PreparedQuery<T extends PreparedQueryConfig> {
    static readonly [entityKind]: string;
    abstract execute(placeholderValues?: Record<string, unknown>): Promise<T['execute']>;
    abstract iterator(placeholderValues?: Record<string, unknown>): AsyncGenerator<T['iterator']>;
}
interface MySqlTransactionConfig {
    withConsistentSnapshot?: boolean;
    accessMode?: 'read only' | 'read write';
    isolationLevel: 'read uncommitted' | 'read committed' | 'repeatable read' | 'serializable';
}
declare abstract class MySqlSession<TQueryResult extends QueryResultHKT = QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase = PreparedQueryHKTBase, TFullSchema extends Record<string, unknown> = Record<string, never>, TSchema extends TablesRelationalConfig = Record<string, never>> {
    protected dialect: MySqlDialect;
    static readonly [entityKind]: string;
    constructor(dialect: MySqlDialect);
    abstract prepareQuery<T extends PreparedQueryConfig, TPreparedQueryHKT extends PreparedQueryHKT>(query: Query, fields: SelectedFieldsOrdered | undefined, customResultMapper?: (rows: unknown[][]) => T['execute']): PreparedQueryKind<TPreparedQueryHKT, T>;
    execute<T>(query: SQL): Promise<T>;
    abstract all<T = unknown>(query: SQL): Promise<T[]>;
    abstract transaction<T>(transaction: (tx: MySqlTransaction<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema>) => Promise<T>, config?: MySqlTransactionConfig): Promise<T>;
    protected getSetTransactionSQL(config: MySqlTransactionConfig): SQL | undefined;
    protected getStartTransactionSQL(config: MySqlTransactionConfig): SQL | undefined;
}
declare abstract class MySqlTransaction<TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase, TFullSchema extends Record<string, unknown> = Record<string, never>, TSchema extends TablesRelationalConfig = Record<string, never>> extends MySqlDatabase<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema> {
    protected schema: RelationalSchemaConfig<TSchema> | undefined;
    protected readonly nestedIndex: number;
    static readonly [entityKind]: string;
    constructor(dialect: MySqlDialect, session: MySqlSession, schema: RelationalSchemaConfig<TSchema> | undefined, nestedIndex?: number);
    rollback(): never;
    /** Nested transactions (aka savepoints) only work with InnoDB engine. */
    abstract transaction<T>(transaction: (tx: MySqlTransaction<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema>) => Promise<T>): Promise<T>;
}
interface PreparedQueryHKTBase extends PreparedQueryHKT {
    type: PreparedQuery<Assume<this['config'], PreparedQueryConfig>>;
}

interface MySqlDeleteConfig {
    where?: SQL | undefined;
    table: AnyMySqlTable;
    returning?: SelectedFieldsOrdered;
}
interface MySqlDelete<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>> {
}
declare class MySqlDelete<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>> implements SQLWrapper {
    private table;
    private session;
    private dialect;
    static readonly [entityKind]: string;
    private config;
    constructor(table: TTable, session: MySqlSession, dialect: MySqlDialect);
    where(where: SQL | undefined): Omit<this, 'where'>;
    toSQL(): Omit<Query, 'typings'>;
    prepare(): Assume<(TPreparedQueryHKT & {
        readonly config: PreparedQueryConfig & {
            execute: QueryResultKind<TQueryResult, never>;
            iterator: never;
        };
    })["type"], PreparedQuery<PreparedQueryConfig & {
        execute: QueryResultKind<TQueryResult, never>;
        iterator: never;
    }>>;
    execute: ReturnType<this['prepare']>['execute'];
    private createIterator;
    iterator: ReturnType<this["prepare"]>["iterator"];
}

type CreateMySqlSelectFromBuilderMode<TBuilderMode extends 'db' | 'qb', TTableName extends string | undefined, TSelection extends ColumnsSelection, TSelectMode extends SelectMode, TPreparedQueryHKT extends PreparedQueryHKTBase> = TBuilderMode extends 'db' ? MySqlSelect<TTableName, TSelection, TSelectMode, TPreparedQueryHKT> : MySqlSelectQueryBuilder<MySqlSelectQueryBuilderHKT, TTableName, TSelection, TSelectMode>;
declare class MySqlSelectBuilder<TSelection extends SelectedFields | undefined, TPreparedQueryHKT extends PreparedQueryHKTBase, TBuilderMode extends 'db' | 'qb' = 'db'> {
    static readonly [entityKind]: string;
    private fields;
    private session;
    private dialect;
    private withList;
    private distinct;
    constructor(config: {
        fields: TSelection;
        session: MySqlSession | undefined;
        dialect: MySqlDialect;
        withList?: Subquery[];
        distinct?: boolean;
    });
    from<TFrom extends AnyMySqlTable | Subquery | MySqlViewBase | SQL>(source: TFrom): CreateMySqlSelectFromBuilderMode<TBuilderMode, GetSelectTableName<TFrom>, TSelection extends undefined ? GetSelectTableSelection<TFrom> : TSelection, TSelection extends undefined ? 'single' : 'partial', TPreparedQueryHKT>;
}
declare abstract class MySqlSelectQueryBuilder<THKT extends MySqlSelectHKTBase, TTableName extends string | undefined, TSelection extends ColumnsSelection, TSelectMode extends SelectMode, TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends TypedQueryBuilder<BuildSubquerySelection<TSelection, TNullabilityMap>, SelectResult<TSelection, TSelectMode, TNullabilityMap>[]> {
    static readonly [entityKind]: string;
    readonly _: {
        selectMode: TSelectMode;
        selection: TSelection;
        result: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
        selectedFields: BuildSubquerySelection<TSelection, TNullabilityMap>;
    };
    protected config: MySqlSelectConfig;
    protected joinsNotNullableMap: Record<string, boolean>;
    private tableName;
    private isPartialSelect;
    protected dialect: MySqlDialect;
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }: {
        table: MySqlSelectConfig['table'];
        fields: MySqlSelectConfig['fields'];
        isPartialSelect: boolean;
        session: MySqlSession | undefined;
        dialect: MySqlDialect;
        withList: Subquery[];
        distinct: boolean | undefined;
    });
    private createJoin;
    leftJoin: JoinFn<THKT, TTableName, TSelectMode, "left", TSelection, TNullabilityMap>;
    rightJoin: JoinFn<THKT, TTableName, TSelectMode, "right", TSelection, TNullabilityMap>;
    innerJoin: JoinFn<THKT, TTableName, TSelectMode, "inner", TSelection, TNullabilityMap>;
    fullJoin: JoinFn<THKT, TTableName, TSelectMode, "full", TSelection, TNullabilityMap>;
    where(where: ((aliases: TSelection) => SQL | undefined) | SQL | undefined): this;
    having(having: ((aliases: TSelection) => SQL | undefined) | SQL | undefined): this;
    groupBy(builder: (aliases: TSelection) => ValueOrArray<AnyMySqlColumn | SQL | SQL.Aliased>): this;
    groupBy(...columns: (AnyMySqlColumn | SQL | SQL.Aliased)[]): this;
    orderBy(builder: (aliases: TSelection) => ValueOrArray<AnyMySqlColumn | SQL | SQL.Aliased>): this;
    orderBy(...columns: (AnyMySqlColumn | SQL | SQL.Aliased)[]): this;
    limit(limit: number): this;
    offset(offset: number): this;
    for(strength: LockStrength, config?: LockConfig): this;
    toSQL(): Simplify<Omit<Query, 'typings'>>;
    as<TAlias extends string>(alias: TAlias): SubqueryWithSelection<BuildSubquerySelection<TSelection, TNullabilityMap>, TAlias>;
}
interface MySqlSelect<TTableName extends string | undefined, TSelection extends ColumnsSelection, TSelectMode extends SelectMode, TPreparedQueryHKT extends PreparedQueryHKTBase, TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends MySqlSelectQueryBuilder<MySqlSelectHKT, TTableName, TSelection, TSelectMode, TNullabilityMap>, QueryPromise<SelectResult<TSelection, TSelectMode, TNullabilityMap>[]> {
}
declare class MySqlSelect<TTableName extends string | undefined, TSelection, TSelectMode extends SelectMode, TPreparedQueryHKT extends PreparedQueryHKTBase, TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends MySqlSelectQueryBuilder<MySqlSelectHKT, TTableName, TSelection, TSelectMode, TNullabilityMap> {
    static readonly [entityKind]: string;
    prepare(): Assume<(TPreparedQueryHKT & {
        readonly config: PreparedQueryConfig & {
            execute: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
            iterator: SelectResult<TSelection, TSelectMode, TNullabilityMap>;
        };
    })["type"], PreparedQuery<PreparedQueryConfig & {
        execute: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
        iterator: SelectResult<TSelection, TSelectMode, TNullabilityMap>;
    }>>;
    execute: ReturnType<this["prepare"]>["execute"];
    private createIterator;
    iterator: ReturnType<this["prepare"]>["iterator"];
}

declare class QueryBuilder {
    static readonly [entityKind]: string;
    private dialect;
    $with<TAlias extends string>(alias: TAlias): {
        as<TSelection extends ColumnsSelection>(qb: TypedQueryBuilder<TSelection, unknown> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection, unknown>)): WithSubqueryWithSelection<TSelection, TAlias>;
    };
    with(...queries: WithSubquery[]): {
        select: {
            (): MySqlSelectBuilder<undefined, never, 'qb'>;
            <TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, never, "qb">;
        };
        selectDistinct: {
            (): MySqlSelectBuilder<undefined, never, 'qb'>;
            <TSelection_1 extends SelectedFields>(fields: TSelection_1): MySqlSelectBuilder<TSelection_1, never, "qb">;
        };
    };
    select(): MySqlSelectBuilder<undefined, never, 'qb'>;
    select<TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, never, 'qb'>;
    selectDistinct(): MySqlSelectBuilder<undefined, never, 'qb'>;
    selectDistinct<TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, never, 'qb'>;
    private getDialect;
}

interface ViewBuilderConfig {
    algorithm?: 'undefined' | 'merge' | 'temptable';
    definer?: string;
    sqlSecurity?: 'definer' | 'invoker';
    withCheckOption?: 'cascaded' | 'local';
}
declare class ViewBuilderCore<TConfig extends {
    name: string;
    columns?: unknown;
}> {
    protected name: TConfig['name'];
    protected schema: string | undefined;
    static readonly [entityKind]: string;
    readonly _: {
        readonly name: TConfig['name'];
        readonly columns: TConfig['columns'];
    };
    constructor(name: TConfig['name'], schema: string | undefined);
    protected config: ViewBuilderConfig;
    algorithm(algorithm: Exclude<ViewBuilderConfig['algorithm'], undefined>): this;
    definer(definer: Exclude<ViewBuilderConfig['definer'], undefined>): this;
    sqlSecurity(sqlSecurity: Exclude<ViewBuilderConfig['sqlSecurity'], undefined>): this;
    withCheckOption(withCheckOption?: Exclude<ViewBuilderConfig['withCheckOption'], undefined>): this;
}
declare class ViewBuilder<TName extends string = string> extends ViewBuilderCore<{
    name: TName;
}> {
    static readonly [entityKind]: string;
    as<TSelectedFields extends SelectedFields>(qb: TypedQueryBuilder<TSelectedFields> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelectedFields>)): MySqlViewWithSelection<TName, false, AddAliasToSelection<TSelectedFields, TName>>;
}
declare class ManualViewBuilder<TName extends string = string, TColumns extends Record<string, AnyMySqlColumnBuilder> = Record<string, AnyMySqlColumnBuilder>> extends ViewBuilderCore<{
    name: TName;
    columns: TColumns;
}> {
    static readonly [entityKind]: string;
    private columns;
    constructor(name: TName, columns: TColumns, schema: string | undefined);
    existing(): MySqlViewWithSelection<TName, true, BuildColumns<TName, TColumns>>;
    as(query: SQL): MySqlViewWithSelection<TName, false, BuildColumns<TName, TColumns>>;
}
declare abstract class MySqlViewBase<TName extends string = string, TExisting extends boolean = boolean, TSelectedFields extends ColumnsSelection = ColumnsSelection> extends View<TName, TExisting, TSelectedFields> {
    static readonly [entityKind]: string;
    readonly _: View<TName, TExisting, TSelectedFields>['_'] & {
        readonly viewBrand: 'MySqlViewBase';
    };
}
declare const MySqlViewConfig: unique symbol;
declare class MySqlView<TName extends string = string, TExisting extends boolean = boolean, TSelectedFields extends ColumnsSelection = ColumnsSelection> extends MySqlViewBase<TName, TExisting, TSelectedFields> {
    static readonly [entityKind]: string;
    protected $MySqlViewBrand: 'MySqlView';
    [MySqlViewConfig]: ViewBuilderConfig | undefined;
    constructor({ mysqlConfig, config }: {
        mysqlConfig: ViewBuilderConfig | undefined;
        config: {
            name: TName;
            schema: string | undefined;
            selectedFields: SelectedFields;
            query: SQL | undefined;
        };
    });
}
type MySqlViewWithSelection<TName extends string, TExisting extends boolean, TSelectedFields extends ColumnsSelection> = MySqlView<TName, TExisting, TSelectedFields> & TSelectedFields;
declare function mysqlView<TName extends string>(name: TName): ViewBuilder<TName>;
declare function mysqlView<TName extends string, TColumns extends Record<string, AnyMySqlColumnBuilder>>(name: TName, columns: TColumns): ManualViewBuilder<TName, TColumns>;

interface JoinsValue {
    on: SQL | undefined;
    table: AnyMySqlTable | Subquery | MySqlViewBase | SQL;
    alias: string | undefined;
    joinType: JoinType;
}
type AnyMySqlSelect = MySqlSelect<any, any, any, any>;
type BuildAliasTable<TTable extends AnyTable, TAlias extends string> = MySqlTableWithColumns<Assume<UpdateTableConfig<TTable['_']['config'], {
    name: TAlias;
    columns: MapColumnsToTableAlias<TTable['_']['columns'], TAlias>;
}>, TableConfig>>;
interface MySqlSelectConfig {
    withList?: Subquery[];
    fields: Record<string, unknown>;
    fieldsFlat?: SelectedFieldsOrdered;
    where?: SQL;
    having?: SQL;
    table: AnyMySqlTable | Subquery | MySqlViewBase | SQL;
    limit?: number | Placeholder;
    offset?: number | Placeholder;
    joins: JoinsValue[];
    orderBy: (AnyMySqlColumn | SQL | SQL.Aliased)[];
    groupBy: (AnyMySqlColumn | SQL | SQL.Aliased)[];
    lockingClause?: {
        strength: LockStrength;
        config: LockConfig;
    };
    distinct?: boolean;
}
type JoinFn<THKT extends MySqlSelectHKTBase, TTableName extends string | undefined, TSelectMode extends SelectMode, TJoinType extends JoinType, TSelection, TNullabilityMap extends Record<string, JoinNullability>> = <TJoinedTable extends AnyMySqlTable | Subquery | MySqlViewBase | SQL, TJoinedName extends GetSelectTableName<TJoinedTable> = GetSelectTableName<TJoinedTable>>(table: TJoinedTable, on: ((aliases: TSelection) => SQL | undefined) | SQL | undefined) => MySqlSelectKind<THKT, TTableName, AppendToResult<TTableName, TSelection, TJoinedName, TJoinedTable extends AnyMySqlTable ? TJoinedTable['_']['columns'] : TJoinedTable extends Subquery ? Assume<TJoinedTable['_']['selectedFields'], SelectedFields> : never, TSelectMode>, TSelectMode extends 'partial' ? TSelectMode : 'multiple', AppendToNullabilityMap<TNullabilityMap, TJoinedName, TJoinType>>;
type SelectedFieldsFlat = SelectedFieldsFlat$1<AnyMySqlColumn>;
type SelectedFields = SelectedFields$1<AnyMySqlColumn, AnyMySqlTable>;
type SelectedFieldsOrdered = SelectedFieldsOrdered$1<AnyMySqlColumn>;
type LockStrength = 'update' | 'share';
type LockConfig = {
    noWait: true;
    skipLocked?: undefined;
} | {
    noWait?: undefined;
    skipLocked: true;
} | {
    noWait?: undefined;
    skipLocked?: undefined;
};
interface MySqlSelectHKTBase {
    tableName: string | undefined;
    selection: unknown;
    selectMode: SelectMode;
    preparedQueryHKT: unknown;
    nullabilityMap: unknown;
    _type: unknown;
}
type MySqlSelectKind<T extends MySqlSelectHKTBase, TTableName extends string | undefined, TSelection, TSelectMode extends SelectMode, TNullabilityMap extends Record<string, JoinNullability>> = (T & {
    tableName: TTableName;
    selection: TSelection;
    selectMode: TSelectMode;
    nullabilityMap: TNullabilityMap;
})['_type'];
interface MySqlSelectQueryBuilderHKT extends MySqlSelectHKTBase {
    _type: MySqlSelectQueryBuilder<this, this['tableName'], Assume<this['selection'], ColumnsSelection>, this['selectMode'], Assume<this['nullabilityMap'], Record<string, JoinNullability>>>;
}
interface MySqlSelectHKT extends MySqlSelectHKTBase {
    _type: MySqlSelect<this['tableName'], Assume<this['selection'], ColumnsSelection>, this['selectMode'], Assume<this['preparedQueryHKT'], PreparedQueryHKTBase>, Assume<this['nullabilityMap'], Record<string, JoinNullability>>>;
}

export { MySqlSelect as $, AnyMySqlTable as A, BuildAliasTable as B, Check as C, uniqueIndex as D, primaryKey as E, ForeignKey as F, GetColumnsTable as G, PrimaryKeyBuilder as H, Index as I, unique as J, uniqueKeyName as K, UniqueConstraintBuilder as L, MySqlColumnBuilderWithAutoIncrement as M, UniqueOnConstraintBuilder as N, MySqlDeleteConfig as O, PrimaryKey as P, MySqlDelete as Q, ReferenceConfig as R, MySqlInsertConfig as S, AnyMySqlInsertConfig as T, UniqueConstraint as U, MySqlInsertValue as V, MySqlInsertBuilder as W, MySqlInsert as X, QueryBuilder as Y, MySqlSelectBuilder as Z, MySqlSelectQueryBuilder as _, MySqlColumnWithAutoIncrement as a, JoinsValue as a0, AnyMySqlSelect as a1, MySqlSelectConfig as a2, JoinFn as a3, SelectedFieldsFlat as a4, SelectedFields as a5, SelectedFieldsOrdered as a6, LockStrength as a7, LockConfig as a8, MySqlSelectHKTBase as a9, ViewBuilderConfig as aA, ViewBuilderCore as aB, ViewBuilder as aC, ManualViewBuilder as aD, MySqlViewBase as aE, MySqlViewConfig as aF, MySqlViewWithSelection as aG, MySqlSelectKind as aa, MySqlSelectQueryBuilderHKT as ab, MySqlSelectHKT as ac, MySqlUpdateConfig as ad, MySqlUpdateSetSource as ae, MySqlUpdateBuilder as af, MySqlUpdate as ag, QueryResultHKT as ah, QueryResultKind as ai, PreparedQueryConfig as aj, PreparedQueryHKT as ak, PreparedQueryKind as al, PreparedQuery as am, MySqlTransactionConfig as an, MySqlSession as ao, MySqlTransaction as ap, PreparedQueryHKTBase as aq, SubqueryWithSelection as ar, WithSubqueryWithSelection as as, MySqlTableExtraConfig as at, TableConfig as au, MySqlTable as av, MySqlTableWithColumns as aw, mysqlTableWithSchema as ax, mysqlTable as ay, mysqlTableCreator as az, MySqlColumnBuilder as b, MySqlColumn as c, MySqlTableFn as d, AnyMySqlColumn as e, MySqlView as f, CheckBuilder as g, check as h, MySqlColumnBuilderHKT as i, MySqlColumnHKT as j, AnyMySqlColumnBuilder as k, MySqlColumnWithAutoIncrementConfig as l, mysqlView as m, MySqlDatabase as n, MySqlDialect as o, UpdateDeleteAction as p, Reference as q, ForeignKeyBuilder as r, AnyForeignKeyBuilder as s, foreignKey as t, IndexColumn as u, IndexBuilderOn as v, AnyIndexBuilder as w, IndexBuilder as x, GetColumnsTableName as y, index as z };
