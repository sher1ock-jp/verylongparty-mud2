'use strict';

const entityKind = Symbol.for('drizzle:entityKind');
const hasOwnEntityKind = Symbol.for('drizzle:hasOwnEntityKind');
function is(value, type) {
    if (!value || typeof value !== 'object') {
        return false;
    }
    if (value instanceof type) { // eslint-disable-line no-instanceof/no-instanceof
        return true;
    }
    if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
        throw new Error(`Class "${type.name ?? '<unknown>'}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
    }
    let cls = value.constructor;
    if (cls) {
        // Traverse the prototype chain to find the entityKind
        while (cls) {
            if (entityKind in cls && cls[entityKind] === type[entityKind]) {
                return true;
            }
            cls = Object.getPrototypeOf(cls);
        }
    }
    return false;
}

var _a$V;
/*
    `Column` only accepts a full `ColumnConfig` as its generic.
    To infer parts of the config, use `AnyColumn` that accepts a partial config.
    See `GetColumnData` for example usage of inferring.
*/
class Column {
    constructor(table, config) {
        this.table = table;
        this.config = config;
        this.name = config.name;
        this.notNull = config.notNull;
        this.default = config.default;
        this.hasDefault = config.hasDefault;
        this.primary = config.primaryKey;
        this.isUnique = config.isUnique;
        this.uniqueName = config.uniqueName;
        this.uniqueType = config.uniqueType;
    }
    mapFromDriverValue(value) {
        return value;
    }
    mapToDriverValue(value) {
        return value;
    }
}
_a$V = entityKind;
Column[_a$V] = 'Column';

var _a$U, _b$K, _c$e, _d$7;
/** @internal */
const TableName = Symbol.for('drizzle:Name');
/** @internal */
const Schema = Symbol.for('drizzle:Schema');
/** @internal */
const Columns = Symbol.for('drizzle:Columns');
/** @internal */
const OriginalName = Symbol.for('drizzle:OriginalName');
/** @internal */
const BaseName = Symbol.for('drizzle:BaseName');
/** @internal */
const IsAlias = Symbol.for('drizzle:IsAlias');
/** @internal */
const ExtraConfigBuilder = Symbol.for('drizzle:ExtraConfigBuilder');
const IsDrizzleTable = Symbol.for('drizzle:IsDrizzleTable');
class Table {
    constructor(name, schema, baseName) {
        /** @internal */
        this[_b$K] = false;
        /** @internal */
        this[_c$e] = undefined;
        this[_d$7] = true;
        this[TableName] = this[OriginalName] = name;
        this[Schema] = schema;
        this[BaseName] = baseName;
    }
}
_a$U = entityKind, _b$K = IsAlias, _c$e = ExtraConfigBuilder, _d$7 = IsDrizzleTable;
Table[_a$U] = 'Table';
/** @internal */
Table.Symbol = {
    Name: TableName,
    Schema: Schema,
    OriginalName: OriginalName,
    Columns: Columns,
    BaseName: BaseName,
    IsAlias: IsAlias,
    ExtraConfigBuilder: ExtraConfigBuilder,
};
function isTable(table) {
    return typeof table === 'object' && table !== null && IsDrizzleTable in table;
}
function getTableName(table) {
    return table[TableName];
}

var _a$T, _b$J;
class CheckBuilder {
    constructor(name, value) {
        this.name = name;
        this.value = value;
    }
    /** @internal */
    build(table) {
        return new Check(table, this);
    }
}
_a$T = entityKind;
CheckBuilder[_a$T] = 'PgCheckBuilder';
class Check {
    constructor(table, builder) {
        this.table = table;
        this.name = builder.name;
        this.value = builder.value;
    }
}
_b$J = entityKind;
Check[_b$J] = 'PgCheck';
function check(name, value) {
    return new CheckBuilder(name, value);
}

var _a$S, _b$I, _c$d;
/** @internal */
const InlineForeignKeys = Symbol.for('drizzle:PgInlineForeignKeys');
class PgTable extends Table {
    constructor() {
        super(...arguments);
        /**@internal */
        this[_b$I] = [];
        /** @internal */
        this[_c$d] = undefined;
    }
}
_a$S = entityKind, _b$I = InlineForeignKeys, _c$d = Table.Symbol.ExtraConfigBuilder;
PgTable[_a$S] = 'PgTable';
/** @internal */
PgTable.Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys,
});
/** @internal */
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
    const rawTable = new PgTable(name, schema, baseName);
    const builtColumns = Object.fromEntries(Object.entries(columns).map(([name, colBuilder]) => {
        const column = colBuilder.build(rawTable);
        rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
        return [name, column];
    }));
    const table = Object.assign(rawTable, builtColumns);
    table[Table.Symbol.Columns] = builtColumns;
    if (extraConfig) {
        table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
    }
    return table;
}
const pgTable = (name, columns, extraConfig) => {
    return pgTableWithSchema(name, columns, extraConfig, undefined);
};
function pgTableCreator(customizeTableName) {
    return (name, columns, extraConfig) => {
        return pgTableWithSchema(customizeTableName(name), columns, extraConfig, undefined, name);
    };
}

var _a$R;
const ViewBaseConfig = Symbol.for('drizzle:ViewBaseConfig');
class View {
    constructor({ name, schema, selectedFields, query }) {
        this[ViewBaseConfig] = {
            name,
            originalName: name,
            schema,
            selectedFields,
            query: query,
            isExisting: !query,
            isAlias: false,
        };
    }
}
_a$R = entityKind;
View[_a$R] = 'View';

var _a$Q, _b$H;
class ForeignKeyBuilder {
    constructor(config, actions) {
        /** @internal */
        this._onUpdate = 'no action';
        /** @internal */
        this._onDelete = 'no action';
        this.reference = () => {
            const { columns, foreignColumns } = config();
            return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
            this._onUpdate = actions.onUpdate;
            this._onDelete = actions.onDelete;
        }
    }
    onUpdate(action) {
        this._onUpdate = action === undefined ? 'no action' : action;
        return this;
    }
    onDelete(action) {
        this._onDelete = action === undefined ? 'no action' : action;
        return this;
    }
    /** @internal */
    build(table) {
        return new ForeignKey(table, this);
    }
}
_a$Q = entityKind;
ForeignKeyBuilder[_a$Q] = 'PgForeignKeyBuilder';
class ForeignKey {
    constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
    }
    getName() {
        const { columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
            this.table[PgTable.Symbol.Name],
            ...columnNames,
            foreignColumns[0].table[PgTable.Symbol.Name],
            ...foreignColumnNames,
        ];
        return `${chunks.join('_')}_fk`;
    }
}
_b$H = entityKind;
ForeignKey[_b$H] = 'PgForeignKey';
function foreignKey(config) {
    function mappedConfig() {
        const { columns, foreignColumns } = config;
        return {
            columns,
            foreignColumns,
        };
    }
    return new ForeignKeyBuilder(mappedConfig);
}

var _a$P, _b$G, _c$c;
class IndexBuilderOn {
    constructor(unique, name) {
        this.unique = unique;
        this.name = name;
    }
    on(...columns) {
        return new IndexBuilder(columns, this.unique, false, this.name);
    }
    onOnly(...columns) {
        return new IndexBuilder(columns, this.unique, true, this.name);
    }
}
_a$P = entityKind;
IndexBuilderOn[_a$P] = 'PgIndexBuilderOn';
class IndexBuilder {
    constructor(columns, unique, only, name) {
        this.config = {
            name,
            columns,
            unique,
            only,
        };
    }
    concurrently() {
        this.config.concurrently = true;
        return this;
    }
    using(method) {
        this.config.using = method;
        return this;
    }
    asc() {
        this.config.order = 'asc';
        return this;
    }
    desc() {
        this.config.order = 'desc';
        return this;
    }
    nullsFirst() {
        this.config.nulls = 'first';
        return this;
    }
    nullsLast() {
        this.config.nulls = 'last';
        return this;
    }
    where(condition) {
        this.config.where = condition;
        return this;
    }
    /** @internal */
    build(table) {
        return new Index(this.config, table);
    }
}
_b$G = entityKind;
IndexBuilder[_b$G] = 'PgIndexBuilder';
class Index {
    constructor(config, table) {
        this.config = { ...config, table };
    }
}
_c$c = entityKind;
Index[_c$c] = 'PgIndex';
function index(name) {
    return new IndexBuilderOn(false, name);
}
function uniqueIndex(name) {
    return new IndexBuilderOn(true, name);
}

var _a$O, _b$F;
function primaryKey(...columns) {
    return new PrimaryKeyBuilder(columns);
}
class PrimaryKeyBuilder {
    constructor(columns) {
        this.columns = columns;
    }
    /** @internal */
    build(table) {
        return new PrimaryKey(table, this.columns);
    }
}
_a$O = entityKind;
PrimaryKeyBuilder[_a$O] = 'PgPrimaryKeyBuilder';
class PrimaryKey {
    constructor(table, columns) {
        this.table = table;
        this.columns = columns;
    }
    getName() {
        return `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join('_')}_pk`;
    }
}
_b$F = entityKind;
PrimaryKey[_b$F] = 'PgPrimaryKey';

var _a$N, _b$E, _c$b;
function unique(name) {
    return new UniqueOnConstraintBuilder(name);
}
function uniqueKeyName(table, columns) {
    return `${table[PgTable.Symbol.Name]}_${columns.join('_')}_unique`;
}
class UniqueConstraintBuilder {
    constructor(columns, name) {
        this.name = name;
        /** @internal */
        this.nullsNotDistinctConfig = false;
        this.columns = columns;
    }
    nullsNotDistinct() {
        this.nullsNotDistinctConfig = true;
        return this;
    }
    /** @internal */
    build(table) {
        return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
    }
}
_a$N = entityKind;
UniqueConstraintBuilder[_a$N] = 'PgUniqueConstraintBuilder';
class UniqueOnConstraintBuilder {
    constructor(name) {
        this.name = name;
    }
    on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
    }
}
_b$E = entityKind;
UniqueOnConstraintBuilder[_b$E] = 'PgUniqueOnConstraintBuilder';
class UniqueConstraint {
    constructor(table, columns, nullsNotDistinct, name) {
        this.table = table;
        this.nullsNotDistinct = false;
        this.columns = columns;
        this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
        this.nullsNotDistinct = nullsNotDistinct;
    }
    getName() {
        return this.name;
    }
}
_c$b = entityKind;
UniqueConstraint[_c$b] = 'PgUniqueConstraint';

var _a$M, _b$D, _c$a;
const SubqueryConfig = Symbol.for('drizzle:SubqueryConfig');
class Subquery {
    constructor(sql, selection, alias, isWith = false) {
        this[SubqueryConfig] = {
            sql,
            selection,
            alias,
            isWith,
        };
    }
}
_a$M = entityKind;
Subquery[_a$M] = 'Subquery';
class WithSubquery extends Subquery {
}
_b$D = entityKind;
WithSubquery[_b$D] = 'WithSubquery';
class SelectionProxyHandler {
    constructor(config) {
        this.config = { ...config };
    }
    get(subquery, prop) {
        if (prop === SubqueryConfig) {
            return {
                ...subquery[SubqueryConfig],
                selection: new Proxy(subquery[SubqueryConfig].selection, this),
            };
        }
        if (prop === ViewBaseConfig) {
            return {
                ...subquery[ViewBaseConfig],
                selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this),
            };
        }
        if (typeof prop === 'symbol') {
            return subquery[prop];
        }
        const columns = is(subquery, Subquery)
            ? subquery[SubqueryConfig].selection
            : is(subquery, View)
                ? subquery[ViewBaseConfig].selectedFields
                : subquery;
        const value = columns[prop];
        if (is(value, SQL.Aliased)) {
            // Never return the underlying SQL expression for a field previously selected in a subquery
            if (this.config.sqlAliasedBehavior === 'sql' && !value.isSelectionField) {
                return value.sql;
            }
            const newValue = value.clone();
            newValue.isSelectionField = true;
            return newValue;
        }
        if (is(value, SQL)) {
            if (this.config.sqlBehavior === 'sql') {
                return value;
            }
            throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
        }
        if (is(value, Column)) {
            if (this.config.alias) {
                return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
            }
            return value;
        }
        if (typeof value !== 'object' || value === null) {
            return value;
        }
        return new Proxy(value, new SelectionProxyHandler(this.config));
    }
}
_c$a = entityKind;
SelectionProxyHandler[_c$a] = 'SelectionProxyHandler';

/** @internal */
function mapResultRow(columns, row, joinsNotNullableMap) {
    // Key -> nested object key, value -> table name if all fields in the nested object are from the same table, false otherwise
    const nullifyMap = {};
    const result = columns.reduce((result, { path, field }, columnIndex) => {
        let decoder;
        if (is(field, Column)) {
            decoder = field;
        }
        else if (is(field, SQL)) {
            decoder = field.decoder;
        }
        else {
            decoder = field.sql.decoder;
        }
        let node = result;
        for (const [pathChunkIndex, pathChunk] of path.entries()) {
            if (pathChunkIndex < path.length - 1) {
                if (!(pathChunk in node)) {
                    node[pathChunk] = {};
                }
                node = node[pathChunk];
            }
            else {
                const rawValue = row[columnIndex];
                const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
                if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
                    const objectName = path[0];
                    if (!(objectName in nullifyMap)) {
                        nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
                    }
                    else if (typeof nullifyMap[objectName] === 'string' && nullifyMap[objectName] !== getTableName(field.table)) {
                        nullifyMap[objectName] = false;
                    }
                }
            }
        }
        return result;
    }, {});
    // Nullify all nested objects from nullifyMap that are nullable
    if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
        for (const [objectName, tableName] of Object.entries(nullifyMap)) {
            if (typeof tableName === 'string' && !joinsNotNullableMap[tableName]) {
                result[objectName] = null;
            }
        }
    }
    return result;
}
/** @internal */
function orderSelectedFields(fields, pathPrefix) {
    return Object.entries(fields).reduce((result, [name, field]) => {
        if (typeof name !== 'string') {
            return result;
        }
        const newPath = pathPrefix ? [...pathPrefix, name] : [name];
        if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
            result.push({ path: newPath, field });
        }
        else if (is(field, Table)) {
            result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
        }
        else {
            result.push(...orderSelectedFields(field, newPath));
        }
        return result;
    }, []);
}
/** @internal */
function mapUpdateSet(table, values) {
    const entries = Object.entries(values)
        .filter(([, value]) => value !== undefined)
        .map(([key, value]) => {
        // eslint-disable-next-line unicorn/prefer-ternary
        if (is(value, SQL)) {
            return [key, value];
        }
        else {
            return [key, new Param(value, table[Table.Symbol.Columns][key])];
        }
    });
    if (entries.length === 0) {
        throw new Error('No values to set');
    }
    return Object.fromEntries(entries);
}
/** @internal */
function applyMixins(baseClass, extendedClasses) {
    for (const extendedClass of extendedClasses) {
        for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
            Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null));
        }
    }
}
function getTableColumns(table) {
    return table[Table.Symbol.Columns];
}
/** @internal */
function getTableLikeName(table) {
    return is(table, Subquery)
        ? table[SubqueryConfig].alias
        : is(table, View)
            ? table[ViewBaseConfig].name
            : is(table, SQL)
                ? undefined
                : table[Table.Symbol.IsAlias]
                    ? table[Table.Symbol.Name]
                    : table[Table.Symbol.BaseName];
}
function iife(fn, ...args) {
    return fn(...args);
}

var _a$L, _b$C;
class QueryPromise {
    constructor() {
        this[_b$C] = 'QueryPromise';
    }
    catch(onRejected) {
        return this.then(undefined, onRejected);
    }
    finally(onFinally) {
        return this.then((value) => {
            onFinally?.();
            return value;
        }, (reason) => {
            onFinally?.();
            throw reason;
        });
    }
    then(onFulfilled, onRejected) {
        return this.execute().then(onFulfilled, onRejected);
    }
}
_a$L = entityKind, _b$C = Symbol.toStringTag;
QueryPromise[_a$L] = 'QueryPromise';

/** @internal */
const tracer = {
    startActiveSpan(name, fn) {
        {
            return fn();
        }
    },
};

var _a$K;
class PgDelete extends QueryPromise {
    constructor(table, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return tracer.startActiveSpan('drizzle.operation', () => {
                return this._prepare().execute(placeholderValues);
            });
        };
        this.config = { table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    returning(fields = this.config.table[Table.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    _prepare(name) {
        return tracer.startActiveSpan('drizzle.prepareQuery', () => {
            return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
        });
    }
    prepare(name) {
        return this._prepare(name);
    }
}
_a$K = entityKind;
PgDelete[_a$K] = 'PgDelete';

var _a$J, _b$B;
class PgInsertBuilder {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
            throw new Error('values() must be called with at least one value');
        }
        const mappedValues = values.map((entry) => {
            const result = {};
            const cols = this.table[Table.Symbol.Columns];
            for (const colKey of Object.keys(entry)) {
                const colValue = entry[colKey];
                result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
            }
            return result;
        });
        return new PgInsert(this.table, mappedValues, this.session, this.dialect);
    }
}
_a$J = entityKind;
PgInsertBuilder[_a$J] = 'PgInsertBuilder';
class PgInsert extends QueryPromise {
    constructor(table, values, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return tracer.startActiveSpan('drizzle.operation', () => {
                return this._prepare().execute(placeholderValues);
            });
        };
        this.config = { table, values };
    }
    returning(fields = this.config.table[Table.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
    }
    onConflictDoNothing(config = {}) {
        if (config.target === undefined) {
            this.config.onConflict = sql `do nothing`;
        }
        else {
            let targetColumn = '';
            targetColumn = Array.isArray(config.target)
                ? config.target.map((it) => this.dialect.escapeName(it.name)).join(',')
                : this.dialect.escapeName(config.target.name);
            const whereSql = config.where ? sql ` where ${config.where}` : undefined;
            this.config.onConflict = sql `(${sql.raw(targetColumn)}) do nothing${whereSql}`;
        }
        return this;
    }
    onConflictDoUpdate(config) {
        const whereSql = config.where ? sql ` where ${config.where}` : undefined;
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
        let targetColumn = '';
        targetColumn = Array.isArray(config.target)
            ? config.target.map((it) => this.dialect.escapeName(it.name)).join(',')
            : this.dialect.escapeName(config.target.name);
        this.config.onConflict = sql `(${sql.raw(targetColumn)}) do update set ${setSql}${whereSql}`;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildInsertQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    _prepare(name) {
        return tracer.startActiveSpan('drizzle.prepareQuery', () => {
            return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
        });
    }
    prepare(name) {
        return this._prepare(name);
    }
}
_b$B = entityKind;
PgInsert[_b$B] = 'PgInsert';

var _a$I;
class PgDialect {
    async migrate(migrations, session) {
        const migrationTableCreate = sql `
			CREATE TABLE IF NOT EXISTS "drizzle"."__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
        await session.execute(sql `CREATE SCHEMA IF NOT EXISTS "drizzle"`);
        await session.execute(migrationTableCreate);
        const dbMigrations = await session.all(sql `select id, hash, created_at from "drizzle"."__drizzle_migrations" order by created_at desc limit 1`);
        const lastDbMigration = dbMigrations[0];
        await session.transaction(async (tx) => {
            for await (const migration of migrations) {
                if (!lastDbMigration
                    || Number(lastDbMigration.created_at) < migration.folderMillis) {
                    for (const stmt of migration.sql) {
                        await tx.execute(sql.raw(stmt));
                    }
                    await tx.execute(sql `insert into "drizzle"."__drizzle_migrations" ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
                }
            }
        });
    }
    escapeName(name) {
        return `"${name}"`;
    }
    escapeParam(num) {
        return `$${num + 1}`;
    }
    escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
    }
    buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? sql ` where ${where}` : undefined;
        return sql `delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
        const setEntries = Object.entries(set);
        const setSize = setEntries.length;
        return sql.fromList(setEntries
            .flatMap(([colName, value], i) => {
            const col = table[Table.Symbol.Columns][colName];
            const res = sql `${name(col.name)} = ${value}`;
            if (i < setSize - 1) {
                return [res, sql.raw(', ')];
            }
            return [res];
        }));
    }
    buildUpdateQuery({ table, set, where, returning }) {
        const setSql = this.buildUpdateSet(table, set);
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? sql ` where ${where}` : undefined;
        return sql `update ${table} set ${setSql}${whereSql}${returningSql}`;
    }
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields
            .flatMap(({ field }, i) => {
            const chunk = [];
            if (is(field, SQL.Aliased) && field.isSelectionField) {
                chunk.push(sql.identifier(field.fieldAlias));
            }
            else if (is(field, SQL.Aliased) || is(field, SQL)) {
                const query = is(field, SQL.Aliased) ? field.sql : field;
                if (isSingleTable) {
                    chunk.push(new SQL(query.queryChunks.map((c) => {
                        if (is(c, PgColumn)) {
                            return name(c.name);
                        }
                        return c;
                    })));
                }
                else {
                    chunk.push(query);
                }
                if (is(field, SQL.Aliased)) {
                    chunk.push(sql ` as ${sql.identifier(field.fieldAlias)}`);
                }
            }
            else if (is(field, Column)) {
                if (isSingleTable) {
                    chunk.push(sql.identifier(field.name));
                }
                else {
                    chunk.push(field);
                }
            }
            if (i < columnsLen - 1) {
                chunk.push(sql `, `);
            }
            return chunk;
        });
        return sql.fromList(chunks);
    }
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, lockingClauses, distinct, }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f of fieldsList) {
            if (is(f.field, Column)
                && getTableName(f.field.table)
                    !== (is(table, Subquery)
                        ? table[SubqueryConfig].alias
                        : is(table, PgViewBase)
                            ? table[ViewBaseConfig].name
                            : is(table, SQL)
                                ? undefined
                                : getTableName(table))
                && !((table) => joins.some(({ alias }) => alias === (table[Table.Symbol.IsAlias] ? getTableName(table) : table[Table.Symbol.BaseName])))(f.field.table)) {
                const tableName = getTableName(f.field.table);
                throw new Error(`Your "${f.path.join('->')}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
            }
        }
        const isSingleTable = joins.length === 0;
        let withSql;
        if (withList?.length) {
            const withSqlChunks = [sql `with `];
            for (const [i, w] of withList.entries()) {
                withSqlChunks.push(sql `${name(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);
                if (i < withList.length - 1) {
                    withSqlChunks.push(sql `, `);
                }
            }
            withSqlChunks.push(sql ` `);
            withSql = sql.fromList(withSqlChunks);
        }
        let distinctSql;
        if (distinct) {
            distinctSql = distinct === true ? sql ` distinct` : sql ` distinct on (${sql.join(distinct.on, ', ')})`;
        }
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
            if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
                let fullName = sql `${sql.identifier(table[Table.Symbol.OriginalName])}`;
                if (table[Table.Symbol.Schema]) {
                    fullName = sql `${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
                }
                return sql `${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
            }
            return table;
        })();
        const joinsArray = [];
        for (const [index, joinMeta] of joins.entries()) {
            if (index === 0) {
                joinsArray.push(sql ` `);
            }
            const table = joinMeta.table;
            if (is(table, PgTable)) {
                const tableName = table[PgTable.Symbol.Name];
                const tableSchema = table[PgTable.Symbol.Schema];
                const origTableName = table[PgTable.Symbol.OriginalName];
                const alias = tableName === origTableName ? undefined : joinMeta.alias;
                joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql `${name(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql ` ${name(alias)}`} on ${joinMeta.on}`);
            }
            else {
                joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join ${table} on ${joinMeta.on}`);
            }
            if (index < joins.length - 1) {
                joinsArray.push(sql ` `);
            }
        }
        const joinsSql = sql.fromList(joinsArray);
        const whereSql = where ? sql ` where ${where}` : undefined;
        const havingSql = having ? sql ` having ${having}` : undefined;
        const orderByList = [];
        for (const [index, orderByValue] of orderBy.entries()) {
            orderByList.push(orderByValue);
            if (index < orderBy.length - 1) {
                orderByList.push(sql `, `);
            }
        }
        const orderBySql = orderByList.length > 0 ? sql ` order by ${sql.fromList(orderByList)}` : undefined;
        const groupByList = [];
        for (const [index, groupByValue] of groupBy.entries()) {
            groupByList.push(groupByValue);
            if (index < groupBy.length - 1) {
                groupByList.push(sql `, `);
            }
        }
        const groupBySql = groupByList.length > 0 ? sql ` group by ${sql.fromList(groupByList)}` : undefined;
        const limitSql = limit ? sql ` limit ${limit}` : undefined;
        const offsetSql = offset ? sql ` offset ${offset}` : undefined;
        const lockingClausesSql = sql.empty();
        for (const { strength, config } of lockingClauses) {
            const clauseSql = sql ` for ${sql.raw(strength)}`;
            if (config.of) {
                clauseSql.append(sql ` of ${config.of}`);
            }
            if (config.noWait) {
                clauseSql.append(sql ` no wait`);
            }
            else if (config.skipLocked) {
                clauseSql.append(sql ` skip locked`);
            }
            lockingClausesSql.append(clauseSql);
        }
        return sql `${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClausesSql}`;
    }
    buildInsertQuery({ table, values, onConflict, returning }) {
        const isSingleValue = values.length === 1;
        const valuesSqlList = [];
        const columns = table[Table.Symbol.Columns];
        const colEntries = isSingleValue
            ? Object.keys(values[0]).map((fieldName) => [fieldName, columns[fieldName]])
            : Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => name(column.name));
        for (const [valueIndex, value] of values.entries()) {
            const valueList = [];
            for (const [fieldName] of colEntries) {
                const colValue = value[fieldName];
                if (colValue === undefined || (is(colValue, Param) && colValue.value === undefined)) {
                    valueList.push(sql `default`);
                }
                else {
                    valueList.push(colValue);
                }
            }
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
                valuesSqlList.push(sql `, `);
            }
        }
        const valuesSql = sql.fromList(valuesSqlList);
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const onConflictSql = onConflict ? sql ` on conflict ${onConflict}` : undefined;
        return sql `insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
    }
    buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
        const concurrentlySql = concurrently ? sql ` concurrently` : undefined;
        const withNoDataSql = withNoData ? sql ` with no data` : undefined;
        return sql `refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
    }
    prepareTyping(encoder) {
        if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
            return 'json';
        }
        else if (is(encoder, PgNumeric)) {
            return 'decimal';
        }
        else if (is(encoder, PgTime)) {
            return 'time';
        }
        else if (is(encoder, PgTimestamp)) {
            return 'timestamp';
        }
        else if (is(encoder, PgDate)) {
            return 'date';
        }
        else if (is(encoder, PgUUID)) {
            return 'uuid';
        }
        else {
            return 'none';
        }
    }
    sqlToQuery(sql) {
        return sql.toQuery({
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
            escapeString: this.escapeString,
            prepareTyping: this.prepareTyping,
        });
    }
    buildRelationalQuery(fullSchema, schema, tableNamesMap, table, tableConfig, config, tableAlias, relationColumns, isRoot = false) {
        if (config === true) {
            const selectionEntries = Object.entries(tableConfig.columns);
            const selection = selectionEntries.map(([key, value]) => ({
                dbKey: value.name,
                tsKey: key,
                field: value,
                tableTsKey: undefined,
                isJson: false,
                selection: [],
            }));
            return {
                tableTsKey: tableConfig.tsName,
                sql: table,
                selection,
            };
        }
        const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
        const aliasedRelations = Object.fromEntries(Object.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]));
        const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
        const fieldsSelection = {};
        let selectedColumns = [];
        let selectedExtras = [];
        let selectedRelations = [];
        if (config.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config.columns)) {
                if (value === undefined) {
                    continue;
                }
                if (field in tableConfig.columns) {
                    if (!isIncludeMode && value === true) {
                        isIncludeMode = true;
                    }
                    selectedColumns.push(field);
                }
            }
            if (selectedColumns.length > 0) {
                selectedColumns = isIncludeMode
                    ? selectedColumns.filter((c) => config.columns?.[c] === true)
                    : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
            }
        }
        if (config.with) {
            selectedRelations = Object.entries(config.with)
                .filter((entry) => !!entry[1])
                .map(([key, value]) => ({ key, value }));
        }
        if (!config.columns) {
            selectedColumns = Object.keys(tableConfig.columns);
        }
        if (config.extras) {
            const extrasOrig = typeof config.extras === 'function'
                ? config.extras(aliasedFields, { sql })
                : config.extras;
            selectedExtras = Object.entries(extrasOrig).map(([key, value]) => ({
                key,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
            }));
        }
        for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection[field] = column;
        }
        for (const { key, value } of selectedExtras) {
            fieldsSelection[key] = value;
        }
        let where;
        if (config.where) {
            const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
        }
        const groupBy = ((tableConfig.primaryKey.length > 0 && selectedRelations.length < 2)
            ? tableConfig.primaryKey
            : Object.values(tableConfig.columns)).map((c) => aliasedTableColumn(c, tableAlias));
        let orderByOrig = typeof config.orderBy === 'function'
            ? config.orderBy(aliasedFields, orderByOperators)
            : config.orderBy ?? [];
        if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
        }
        const orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
                return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
        });
        const builtRelations = [];
        const builtRelationFields = [];
        let result;
        let selectedRelationIndex = 0;
        for (const { key: selectedRelationKey, value: selectedRelationValue } of selectedRelations) {
            let relation;
            for (const [relationKey, relationValue] of Object.entries(tableConfig.relations)) {
                if (is(relationValue, Relation) && relationKey === selectedRelationKey) {
                    relation = relationValue;
                    break;
                }
            }
            if (!relation) {
                throw new Error(`Relation ${selectedRelationKey} not found`);
            }
            const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
            const relationAlias = `${tableAlias}_${selectedRelationKey}`;
            const relationConfig = schema[tableNamesMap[relation.referencedTable[Table.Symbol.Name]]];
            const builtRelation = this.buildRelationalQuery(fullSchema, schema, tableNamesMap, fullSchema[tableNamesMap[relation.referencedTable[Table.Symbol.Name]]], schema[tableNamesMap[relation.referencedTable[Table.Symbol.Name]]], selectedRelationValue, relationAlias, normalizedRelation.references);
            builtRelations.push({ key: selectedRelationKey, value: builtRelation });
            let relationWhere;
            if (typeof selectedRelationValue === 'object' && selectedRelationValue.limit) {
                const field = sql `${sql.identifier(relationAlias)}.${sql.identifier('__drizzle_row_number')}`;
                relationWhere = and(relationWhere, or(and(sql `${field} <= ${selectedRelationValue.limit}`), sql `(${field} is null)`));
            }
            const join = {
                table: is(builtRelation.sql, Table)
                    ? aliasedTable(builtRelation.sql, relationAlias)
                    : new Subquery(builtRelation.sql, {}, relationAlias),
                alias: relationAlias,
                on: and(...normalizedRelation.fields.map((field, i) => eq(aliasedTableColumn(field, tableAlias), aliasedTableColumn(normalizedRelation.references[i], relationAlias)))),
                joinType: 'left',
            };
            const relationAliasedColumns = Object.fromEntries(Object.entries(relationConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
            const relationAliasedRelations = Object.fromEntries(Object.entries(relationConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]));
            const relationAliasedFields = Object.assign({}, relationAliasedColumns, relationAliasedRelations);
            let relationOrderBy;
            if (typeof selectedRelationValue === 'object') {
                let orderByOrig = typeof selectedRelationValue.orderBy === 'function'
                    ? selectedRelationValue.orderBy(relationAliasedFields, orderByOperators)
                    : selectedRelationValue.orderBy ?? [];
                if (!Array.isArray(orderByOrig)) {
                    orderByOrig = [orderByOrig];
                }
                relationOrderBy = orderByOrig.map((orderByValue) => {
                    if (is(orderByValue, Column)) {
                        return aliasedTableColumn(orderByValue, relationAlias);
                    }
                    return mapColumnsInSQLToAlias(orderByValue, relationAlias);
                });
            }
            const relationOrderBySql = relationOrderBy?.length
                ? sql ` order by ${sql.join(relationOrderBy, sql `, `)}`
                : undefined;
            const elseField = sql `json_agg(json_build_array(${sql.join(builtRelation.selection.map(({ dbKey: key, isJson }) => {
                let field = sql `${sql.identifier(relationAlias)}.${sql.identifier(key)}`;
                if (isJson) {
                    field = sql `${field}::json`;
                }
                return field;
            }), sql `, `)})${relationOrderBySql})`;
            if (selectedRelations.length > 1) {
                elseField.append(sql.raw('::text'));
            }
            const countSql = normalizedRelation.references.length === 1
                ? aliasedTableColumn(normalizedRelation.references[0], relationAlias)
                : sql.fromList([
                    sql `coalesce(`,
                    sql.join(normalizedRelation.references.map((c) => aliasedTableColumn(c, relationAlias)), sql.raw(', ')),
                    sql.raw(')'),
                ]);
            const field = sql `case when count(${countSql}) = 0 then '[]' else ${elseField} end`.as(selectedRelationKey);
            const builtRelationField = {
                path: [selectedRelationKey],
                field,
            };
            result = this.buildSelectQuery({
                table: result ? new Subquery(result, {}, tableAlias) : aliasedTable(table, tableAlias),
                fields: {},
                fieldsFlat: [
                    {
                        path: [],
                        field: sql `${sql.identifier(tableAlias)}.*`,
                    },
                    ...(selectedRelationIndex === selectedRelations.length - 1
                        ? selectedExtras.map(({ key, value }) => ({
                            path: [key],
                            field: value,
                        }))
                        : []),
                    builtRelationField,
                ],
                where: relationWhere,
                groupBy: [
                    ...groupBy,
                    ...builtRelationFields.map(({ field }) => sql `${sql.identifier(tableAlias)}.${sql.identifier(field.fieldAlias)}`),
                ],
                orderBy: selectedRelationIndex === selectedRelations.length - 1 ? orderBy : [],
                joins: [join],
                lockingClauses: [],
            });
            builtRelationFields.push(builtRelationField);
            selectedRelationIndex++;
        }
        const finalFieldsSelection = Object.entries(fieldsSelection).map(([key, value]) => {
            return {
                path: [key],
                field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
            };
        });
        const finalFieldsFlat = isRoot
            ? [
                ...finalFieldsSelection.map(({ path, field }) => ({
                    path,
                    field: is(field, SQL.Aliased) ? sql `${sql.identifier(field.fieldAlias)}` : field,
                })),
                ...builtRelationFields.map(({ path, field }) => ({
                    path,
                    field: sql `${sql.identifier(field.fieldAlias)}${selectedRelations.length > 1 ? sql.raw('::json') : undefined}`,
                })),
            ]
            : [
                {
                    path: [],
                    field: sql `${sql.identifier(tableAlias)}.*`,
                },
                ...(builtRelationFields.length === 0
                    ? selectedExtras.map(({ key, value }) => ({
                        path: [key],
                        field: value,
                    }))
                    : []),
            ];
        let limit, offset;
        if (config.limit !== undefined || config.offset !== undefined) {
            if (isRoot) {
                limit = config.limit;
                offset = config.offset;
            }
            else {
                finalFieldsFlat.push({
                    path: ['__drizzle_row_number'],
                    field: sql `row_number() over(partition by ${relationColumns.map((c) => aliasedTableColumn(c, tableAlias))}${orderBy.length ? sql ` order by ${sql.join(orderBy, sql `, `)}` : undefined})`
                        .as('__drizzle_row_number'),
                });
            }
        }
        result = this.buildSelectQuery({
            table: result ? new Subquery(result, {}, tableAlias) : aliasedTable(table, tableAlias),
            fields: {},
            fieldsFlat: finalFieldsFlat,
            where,
            groupBy: [],
            orderBy: orderBy ?? [],
            joins: [],
            lockingClauses: [],
            limit,
            offset: offset,
        });
        return {
            tableTsKey: tableConfig.tsName,
            sql: result,
            selection: [
                ...finalFieldsSelection.map(({ path, field }) => ({
                    dbKey: is(field, SQL.Aliased) ? field.fieldAlias : tableConfig.columns[path[0]].name,
                    tsKey: path[0],
                    field,
                    tableTsKey: undefined,
                    isJson: false,
                    selection: [],
                })),
                ...builtRelations.map(({ key, value }) => ({
                    dbKey: key,
                    tsKey: key,
                    field: undefined,
                    tableTsKey: value.tableTsKey,
                    isJson: true,
                    selection: value.selection,
                })),
            ],
        };
    }
}
_a$I = entityKind;
PgDialect[_a$I] = 'PgDialect';

var _a$H;
class TypedQueryBuilder {
    /** @internal */
    getSelectedFields() {
        return this._.selectedFields;
    }
}
_a$H = entityKind;
TypedQueryBuilder[_a$H] = 'TypedQueryBuilder';

var _a$G, _b$A, _c$9;
class PgSelectBuilder {
    constructor(config) {
        this.withList = [];
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        if (config.withList) {
            this.withList = config.withList;
        }
        this.distinct = config.distinct;
    }
    /**
     * Specify the table, subquery, or other target that you're
     * building a select query against.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM|Postgres from documentation}
     */
    from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
            fields = this.fields;
        }
        else if (is(source, Subquery)) {
            // This is required to use the proxy handler to get the correct field values from the subquery
            fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
        }
        else if (is(source, PgViewBase)) {
            fields = source[ViewBaseConfig].selectedFields;
        }
        else if (is(source, SQL)) {
            fields = {};
        }
        else {
            fields = getTableColumns(source);
        }
        return new PgSelect({
            table: source,
            fields,
            isPartialSelect,
            session: this.session,
            dialect: this.dialect,
            withList: this.withList,
            distinct: this.distinct,
        });
    }
}
_a$G = entityKind;
PgSelectBuilder[_a$G] = 'PgSelectBuilder';
class PgSelectQueryBuilder extends TypedQueryBuilder {
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        /**
         * For each row of the table, include
         * values from a matching row of the joined
         * table, if there is a matching row. If not,
         * all of the columns of the joined table
         * will be set to null.
         */
        this.leftJoin = this.createJoin('left');
        /**
         * Includes all of the rows of the joined table.
         * If there is no matching row in the main table,
         * all the columns of the main table will be
         * set to null.
         */
        this.rightJoin = this.createJoin('right');
        /**
         * This is the default type of join.
         *
         * For each row of the table, the joined table
         * needs to have a matching row, or it will
         * be excluded from results.
         */
        this.innerJoin = this.createJoin('inner');
        /**
         * Rows from both the main & joined are included,
         * regardless of whether or not they have matching
         * rows in the other table.
         */
        this.fullJoin = this.createJoin('full');
        this.config = {
            withList,
            table,
            fields: { ...fields },
            joins: [],
            orderBy: [],
            groupBy: [],
            lockingClauses: [],
            distinct,
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
            selectedFields: fields,
        };
        this.tableName = getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};
    }
    createJoin(joinType) {
        return (table, on) => {
            const baseTableName = this.tableName;
            const tableName = getTableLikeName(table);
            if (typeof tableName === 'string' && this.config.joins.some((join) => join.alias === tableName)) {
                throw new Error(`Alias "${tableName}" is already used in this query`);
            }
            if (!this.isPartialSelect) {
                // If this is the first join and this is not a partial select and we're not selecting from raw SQL, "move" the fields from the main table to the nested object
                if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {
                    this.config.fields = {
                        [baseTableName]: this.config.fields,
                    };
                }
                if (typeof tableName === 'string' && !is(table, SQL)) {
                    const selection = is(table, Subquery)
                        ? table[SubqueryConfig].selection
                        : is(table, View)
                            ? table[ViewBaseConfig].selectedFields
                            : table[Table.Symbol.Columns];
                    this.config.fields[tableName] = selection;
                }
            }
            if (typeof on === 'function') {
                on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
            }
            this.config.joins.push({ on, table, joinType, alias: tableName });
            if (typeof tableName === 'string') {
                switch (joinType) {
                    case 'left': {
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                    case 'right': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'inner': {
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'full': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                }
            }
            return this;
        };
    }
    /**
     * Specify a condition to narrow the result set. Multiple
     * conditions can be combined with the `and` and `or`
     * functions.
     *
     * ## Examples
     *
     * ```ts
     * // Find cars made in the year 2000
     * db.select().from(cars).where(eq(cars.year, 2000));
     * ```
     */
    where(where) {
        if (typeof where === 'function') {
            where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.where = where;
        return this;
    }
    /**
     * Sets the HAVING clause of this query, which often
     * used with GROUP BY and filters rows after they've been
     * grouped together and combined.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-HAVING|Postgres having clause documentation}
     */
    having(having) {
        if (typeof having === 'function') {
            having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.having = having;
        return this;
    }
    groupBy(...columns) {
        if (typeof columns[0] === 'function') {
            const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        }
        else {
            this.config.groupBy = columns;
        }
        return this;
    }
    orderBy(...columns) {
        if (typeof columns[0] === 'function') {
            const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
        }
        else {
            this.config.orderBy = columns;
        }
        return this;
    }
    /**
     * Set the maximum number of rows that will be
     * returned by this query.
     *
     * ## Examples
     *
     * ```ts
     * // Get the first 10 people from this query.
     * db.select().from(people).limit(10);
     * ```
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-LIMIT|Postgres LIMIT documentation}
     */
    limit(limit) {
        this.config.limit = limit;
        return this;
    }
    /**
     * Skip a number of rows when returning results
     * from this query.
     *
     * ## Examples
     *
     * ```ts
     * // Get the 10th-20th people from this query.
     * db.select().from(people).offset(10).limit(10);
     * ```
     */
    offset(offset) {
        this.config.offset = offset;
        return this;
    }
    /**
     * The FOR clause specifies a lock strength for this query
     * that controls how strictly it acquires exclusive access to
     * the rows being queried.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE|Postgres locking clause documentation}
     */
    for(strength, config = {}) {
        this.config.lockingClauses.push({ strength, config });
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildSelectQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    as(alias) {
        return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
    }
}
_b$A = entityKind;
PgSelectQueryBuilder[_b$A] = 'PgSelectQueryBuilder';
class PgSelect extends PgSelectQueryBuilder {
    constructor() {
        super(...arguments);
        this.execute = (placeholderValues) => {
            return tracer.startActiveSpan('drizzle.operation', () => {
                return this._prepare().execute(placeholderValues);
            });
        };
    }
    _prepare(name) {
        const { session, config, dialect, joinsNotNullableMap } = this;
        if (!session) {
            throw new Error('Cannot execute a query on a query builder. Please use a database instance instead.');
        }
        return tracer.startActiveSpan('drizzle.prepareQuery', () => {
            const fieldsList = orderSelectedFields(config.fields);
            const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name);
            query.joinsNotNullableMap = joinsNotNullableMap;
            return query;
        });
    }
    /**
     * Create a prepared statement for this query. This allows
     * the database to remember this query for the given session
     * and call it by name, rather than specifying the full query.
     *
     * {@link https://www.postgresql.org/docs/current/sql-prepare.html|Postgres prepare documentation}
     */
    prepare(name) {
        return this._prepare(name);
    }
}
_c$9 = entityKind;
PgSelect[_c$9] = 'PgSelect';
applyMixins(PgSelect, [QueryPromise]);

var _a$F;
class QueryBuilder {
    $with(alias) {
        const queryBuilder = this;
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(queryBuilder);
                }
                return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new PgSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new PgSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                distinct: true,
            });
        }
        function selectDistinctOn(on, fields) {
            return new PgSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                distinct: { on },
            });
        }
        return { select, selectDistinct, selectDistinctOn };
    }
    select(fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
        });
    }
    selectDistinct(fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
            distinct: true,
        });
    }
    selectDistinctOn(on, fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
            distinct: { on },
        });
    }
    // Lazy load dialect to avoid circular dependency
    getDialect() {
        if (!this.dialect) {
            this.dialect = new PgDialect();
        }
        return this.dialect;
    }
}
_a$F = entityKind;
QueryBuilder[_a$F] = 'PgQueryBuilder';

var _a$E;
class PgRefreshMaterializedView extends QueryPromise {
    constructor(view, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return tracer.startActiveSpan('drizzle.operation', () => {
                return this._prepare().execute(placeholderValues);
            });
        };
        this.config = { view };
    }
    concurrently() {
        if (this.config.withNoData !== undefined) {
            throw new Error('Cannot use concurrently and withNoData together');
        }
        this.config.concurrently = true;
        return this;
    }
    withNoData() {
        if (this.config.concurrently !== undefined) {
            throw new Error('Cannot use concurrently and withNoData together');
        }
        this.config.withNoData = true;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildRefreshMaterializedViewQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    _prepare(name) {
        return tracer.startActiveSpan('drizzle.prepareQuery', () => {
            return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name);
        });
    }
    prepare(name) {
        return this._prepare(name);
    }
}
_a$E = entityKind;
PgRefreshMaterializedView[_a$E] = 'PgRefreshMaterializedView';

var _a$D, _b$z;
class PgUpdateBuilder {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    set(values) {
        return new PgUpdate(this.table, mapUpdateSet(this.table, values), this.session, this.dialect);
    }
}
_a$D = entityKind;
PgUpdateBuilder[_a$D] = 'PgUpdateBuilder';
class PgUpdate extends QueryPromise {
    constructor(table, set, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return this._prepare().execute(placeholderValues);
        };
        this.config = { set, table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    returning(fields = this.config.table[Table.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    _prepare(name) {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    }
    prepare(name) {
        return this._prepare(name);
    }
}
_b$z = entityKind;
PgUpdate[_b$z] = 'PgUpdate';

var _a$C, _b$y, _c$8, _d$6, _e$1, _f$1, _g, _h, _j;
class DefaultViewBuilderCore {
    constructor(name, schema) {
        this.name = name;
        this.schema = schema;
        this.config = {};
    }
    with(config) {
        this.config.with = config;
        return this;
    }
}
_a$C = entityKind;
DefaultViewBuilderCore[_a$C] = 'PgDefaultViewBuilderCore';
class ViewBuilder extends DefaultViewBuilderCore {
    as(qb) {
        if (typeof qb === 'function') {
            qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(new PgView({
            pgConfig: this.config,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: aliasedSelection,
                query: qb.getSQL().inlineParams(),
            },
        }), selectionProxy);
    }
}
_b$y = entityKind;
ViewBuilder[_b$y] = 'PgViewBuilder';
class ManualViewBuilder extends DefaultViewBuilderCore {
    constructor(name, columns, schema) {
        super(name, schema);
        this.columns = getTableColumns(pgTable(name, columns));
    }
    existing() {
        return new Proxy(new PgView({
            pgConfig: undefined,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: undefined,
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
    as(query) {
        return new Proxy(new PgView({
            pgConfig: this.config,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: query.inlineParams(),
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
}
_c$8 = entityKind;
ManualViewBuilder[_c$8] = 'PgManualViewBuilder';
class MaterializedViewBuilderCore {
    constructor(name, schema) {
        this.name = name;
        this.schema = schema;
        this.config = {};
    }
    using(using) {
        this.config.using = using;
        return this;
    }
    with(config) {
        this.config.with = config;
        return this;
    }
    tablespace(tablespace) {
        this.config.tablespace = tablespace;
        return this;
    }
    withNoData() {
        this.config.withNoData = true;
        return this;
    }
}
_d$6 = entityKind;
MaterializedViewBuilderCore[_d$6] = 'PgMaterializedViewBuilderCore';
class MaterializedViewBuilder extends MaterializedViewBuilderCore {
    as(qb) {
        if (typeof qb === 'function') {
            qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(new PgMaterializedView({
            pgConfig: {
                with: this.config.with,
                using: this.config.using,
                tablespace: this.config.tablespace,
                withNoData: this.config.withNoData,
            },
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: aliasedSelection,
                query: qb.getSQL().inlineParams(),
            },
        }), selectionProxy);
    }
}
_e$1 = entityKind;
MaterializedViewBuilder[_e$1] = 'PgMaterializedViewBuilder';
class ManualMaterializedViewBuilder extends MaterializedViewBuilderCore {
    constructor(name, columns, schema) {
        super(name, schema);
        this.columns = getTableColumns(pgTable(name, columns));
    }
    existing() {
        return new Proxy(new PgMaterializedView({
            pgConfig: undefined,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: undefined,
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
    as(query) {
        return new Proxy(new PgMaterializedView({
            pgConfig: undefined,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: query.inlineParams(),
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
}
_f$1 = entityKind;
ManualMaterializedViewBuilder[_f$1] = 'PgManualMaterializedViewBuilder';
class PgViewBase extends View {
}
_g = entityKind;
PgViewBase[_g] = 'PgViewBase';
const PgViewConfig = Symbol.for('drizzle:PgViewConfig');
class PgView extends PgViewBase {
    constructor({ pgConfig, config }) {
        super(config);
        if (pgConfig) {
            this[PgViewConfig] = {
                with: pgConfig.with,
            };
        }
    }
}
_h = entityKind;
PgView[_h] = 'PgView';
const PgMaterializedViewConfig = Symbol.for('drizzle:PgMaterializedViewConfig');
class PgMaterializedView extends PgViewBase {
    constructor({ pgConfig, config }) {
        super(config);
        this[PgMaterializedViewConfig] = {
            with: pgConfig?.with,
            using: pgConfig?.using,
            tablespace: pgConfig?.tablespace,
            withNoData: pgConfig?.withNoData,
        };
    }
}
_j = entityKind;
PgMaterializedView[_j] = 'PgMaterializedView';
/** @internal */
function pgViewWithSchema(name, selection, schema) {
    if (selection) {
        return new ManualViewBuilder(name, selection, schema);
    }
    return new ViewBuilder(name, schema);
}
/** @internal */
function pgMaterializedViewWithSchema(name, selection, schema) {
    if (selection) {
        return new ManualMaterializedViewBuilder(name, selection, schema);
    }
    return new MaterializedViewBuilder(name, schema);
}
function pgView(name, columns) {
    return pgViewWithSchema(name, columns, undefined);
}
function pgMaterializedView(name, columns) {
    return pgMaterializedViewWithSchema(name, columns, undefined);
}

function getTableConfig(table) {
    const columns = Object.values(table[Table.Symbol.Columns]);
    const indexes = [];
    const checks = [];
    const primaryKeys = [];
    const foreignKeys = Object.values(table[PgTable.Symbol.InlineForeignKeys]);
    const uniqueConstraints = [];
    const name = table[Table.Symbol.Name];
    const schema = table[Table.Symbol.Schema];
    const extraConfigBuilder = table[PgTable.Symbol.ExtraConfigBuilder];
    if (extraConfigBuilder !== undefined) {
        const extraConfig = extraConfigBuilder(table[Table.Symbol.Columns]);
        for (const builder of Object.values(extraConfig)) {
            if (is(builder, IndexBuilder)) {
                indexes.push(builder.build(table));
            }
            else if (is(builder, CheckBuilder)) {
                checks.push(builder.build(table));
            }
            else if (is(builder, UniqueConstraintBuilder)) {
                uniqueConstraints.push(builder.build(table));
            }
            else if (is(builder, PrimaryKeyBuilder)) {
                primaryKeys.push(builder.build(table));
            }
            else if (is(builder, ForeignKeyBuilder)) {
                foreignKeys.push(builder.build(table));
            }
        }
    }
    return {
        columns,
        indexes,
        foreignKeys,
        checks,
        primaryKeys,
        uniqueConstraints,
        name,
        schema,
    };
}
function getViewConfig(view) {
    return {
        ...view[ViewBaseConfig],
        ...view[PgViewConfig],
    };
}
function getMaterializedViewConfig(view) {
    return {
        ...view[ViewBaseConfig],
        ...view[PgMaterializedViewConfig],
    };
}
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
    for (let i = startFrom; i < arrayString.length; i++) {
        const char = arrayString[i];
        if (char === '\\') {
            i++;
            continue;
        }
        if (char === '"') {
            return [arrayString.slice(startFrom, i).replace(/\\/g, ''), i + 1];
        }
        if (inQuotes) {
            continue;
        }
        if (char === ',' || char === '}') {
            return [arrayString.slice(startFrom, i).replace(/\\/g, ''), i];
        }
    }
    return [arrayString.slice(startFrom).replace(/\\/g, ''), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
    const result = [];
    let i = startFrom;
    let lastCharIsComma = false;
    while (i < arrayString.length) {
        const char = arrayString[i];
        if (char === ',') {
            if (lastCharIsComma || i === startFrom) {
                result.push('');
            }
            lastCharIsComma = true;
            i++;
            continue;
        }
        lastCharIsComma = false;
        if (char === '\\') {
            i += 2;
            continue;
        }
        if (char === '"') {
            const [value, startFrom] = parsePgArrayValue(arrayString, i + 1, true);
            result.push(value);
            i = startFrom;
            continue;
        }
        if (char === '}') {
            return [result, i + 1];
        }
        if (char === '{') {
            const [value, startFrom] = parsePgNestedArray(arrayString, i + 1);
            result.push(value);
            i = startFrom;
            continue;
        }
        const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
        result.push(value);
        i = newStartFrom;
    }
    return [result, i];
}
function parsePgArray(arrayString) {
    const [result] = parsePgNestedArray(arrayString, 1);
    return result;
}
function makePgArray(array) {
    return `{${array.map((item) => {
        if (Array.isArray(item)) {
            return makePgArray(item);
        }
        if (typeof item === 'string' && item.includes(',')) {
            return `"${item.replace(/"/g, '\\"')}"`;
        }
        return `${item}`;
    }).join(',')}}`;
}

var _a$B;
// To understand how to use `ColumnBuilder` and `AnyColumnBuilder`, see `Column` and `AnyColumn` documentation.
class ColumnBuilder {
    constructor(name) {
        this.config = {
            name,
            notNull: false,
            default: undefined,
            primaryKey: false,
        };
    }
    $type() {
        return this;
    }
    notNull() {
        this.config.notNull = true;
        return this;
    }
    default(value) {
        this.config.default = value;
        this.config.hasDefault = true;
        return this;
    }
    primaryKey() {
        this.config.primaryKey = true;
        this.config.notNull = true;
        return this;
    }
}
_a$B = entityKind;
ColumnBuilder[_a$B] = 'ColumnBuilder';

var _a$A, _b$x;
class PgColumnBuilder extends ColumnBuilder {
    constructor() {
        super(...arguments);
        this.foreignKeyConfigs = [];
    }
    array(size) {
        return new PgArrayBuilder(this.config.name, this, size);
    }
    references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
    }
    unique(name, config) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        this.config.uniqueType = config?.nulls;
        return this;
    }
    /** @internal */
    buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
            return ((ref, actions) => {
                const builder = new ForeignKeyBuilder(() => {
                    const foreignColumn = ref();
                    return { columns: [column], foreignColumns: [foreignColumn] };
                });
                if (actions.onUpdate) {
                    builder.onUpdate(actions.onUpdate);
                }
                if (actions.onDelete) {
                    builder.onDelete(actions.onDelete);
                }
                return builder.build(table);
            })(ref, actions);
        });
    }
}
_a$A = entityKind;
PgColumnBuilder[_a$A] = 'PgColumnBuilder';
// To understand how to use `PgColumn` and `AnyPgColumn`, see `Column` and `AnyColumn` documentation.
class PgColumn extends Column {
    constructor(table, config) {
        if (!config.uniqueName) {
            config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        this.table = table;
    }
}
_b$x = entityKind;
PgColumn[_b$x] = 'PgColumn';

var _a$z, _b$w;
class PgArrayBuilder extends PgColumnBuilder {
    constructor(name, baseBuilder, size) {
        super(name);
        this.config.baseBuilder = baseBuilder;
        this.config.size = size;
    }
    /** @internal */
    build(table) {
        const baseColumn = this.config.baseBuilder.build(table);
        return new PgArray(table, this.config, baseColumn);
    }
}
_a$z = entityKind;
PgArrayBuilder[_a$z] = 'PgArrayBuilder';
class PgArray extends PgColumn {
    constructor(table, config, baseColumn, range) {
        super(table, config);
        this.baseColumn = baseColumn;
        this.range = range;
        this.size = config.size;
    }
    getSQLType() {
        return `${this.baseColumn.getSQLType()}[${typeof this.size === 'number' ? this.size : ''}]`;
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            // Thank you node-postgres for not parsing enum arrays
            value = parsePgArray(value);
        }
        return value.map((v) => this.baseColumn.mapFromDriverValue(v));
    }
    mapToDriverValue(value, isNestedArray = false) {
        const a = value.map((v) => v === null
            ? null
            : is(this.baseColumn, PgArray)
                ? this.baseColumn.mapToDriverValue(v, true)
                : this.baseColumn.mapToDriverValue(v));
        if (isNestedArray)
            return a;
        return makePgArray(a);
    }
}
_b$w = entityKind;
PgArray[_b$w] = 'PgArray';

var _a$y, _b$v, _c$7, _d$5;
class PgBigInt53Builder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgBigInt53(table, this.config);
    }
}
_a$y = entityKind;
PgBigInt53Builder[_a$y] = 'PgBigInt53Builder';
class PgBigInt53 extends PgColumn {
    getSQLType() {
        return 'bigint';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'number') {
            return value;
        }
        return Number(value);
    }
}
_b$v = entityKind;
PgBigInt53[_b$v] = 'PgBigInt53';
class PgBigInt64Builder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgBigInt64(table, this.config);
    }
}
_c$7 = entityKind;
PgBigInt64Builder[_c$7] = 'PgBigInt64Builder';
class PgBigInt64 extends PgColumn {
    getSQLType() {
        return 'bigint';
    }
    // eslint-disable-next-line unicorn/prefer-native-coercion-functions
    mapFromDriverValue(value) {
        return BigInt(value);
    }
}
_d$5 = entityKind;
PgBigInt64[_d$5] = 'PgBigInt64';
function bigint(name, config) {
    if (config.mode === 'number') {
        return new PgBigInt53Builder(name);
    }
    return new PgBigInt64Builder(name);
}

var _a$x, _b$u, _c$6, _d$4;
class PgBigSerial53Builder extends PgColumnBuilder {
    constructor(name) {
        super(name);
        this.config.hasDefault = true;
        this.config.notNull = true;
    }
    /** @internal */
    build(table) {
        return new PgBigSerial53(table, this.config);
    }
}
_a$x = entityKind;
PgBigSerial53Builder[_a$x] = 'PgBigSerial53Builder';
class PgBigSerial53 extends PgColumn {
    getSQLType() {
        return 'bigserial';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'number') {
            return value;
        }
        return Number(value);
    }
}
_b$u = entityKind;
PgBigSerial53[_b$u] = 'PgBigSerial53';
class PgBigSerial64Builder extends PgColumnBuilder {
    constructor(name) {
        super(name);
        this.config.hasDefault = true;
    }
    /** @internal */
    build(table) {
        return new PgBigSerial64(table, this.config);
    }
}
_c$6 = entityKind;
PgBigSerial64Builder[_c$6] = 'PgBigSerial64Builder';
class PgBigSerial64 extends PgColumn {
    getSQLType() {
        return 'bigserial';
    }
    // eslint-disable-next-line unicorn/prefer-native-coercion-functions
    mapFromDriverValue(value) {
        return BigInt(value);
    }
}
_d$4 = entityKind;
PgBigSerial64[_d$4] = 'PgBigSerial64';
function bigserial(name, { mode }) {
    if (mode === 'number') {
        return new PgBigSerial53Builder(name);
    }
    return new PgBigSerial64Builder(name);
}

var _a$w, _b$t;
class PgBooleanBuilder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgBoolean(table, this.config);
    }
}
_a$w = entityKind;
PgBooleanBuilder[_a$w] = 'PgBooleanBuilder';
class PgBoolean extends PgColumn {
    getSQLType() {
        return 'boolean';
    }
}
_b$t = entityKind;
PgBoolean[_b$t] = 'PgBoolean';
function boolean(name) {
    return new PgBooleanBuilder(name);
}

var _a$v, _b$s;
class PgCharBuilder extends PgColumnBuilder {
    constructor(name, config) {
        super(name);
        this.config.length = config.length;
        this.config.enumValues = (config.enum ?? []);
    }
    /** @internal */
    build(table) {
        return new PgChar(table, this.config);
    }
}
_a$v = entityKind;
PgCharBuilder[_a$v] = 'PgCharBuilder';
class PgChar extends PgColumn {
    constructor() {
        super(...arguments);
        this.length = this.config.length;
        this.enumValues = this.config.enumValues;
    }
    getSQLType() {
        return this.length === undefined ? `char` : `char(${this.length})`;
    }
}
_b$s = entityKind;
PgChar[_b$s] = 'PgChar';
function char(name, config = {}) {
    return new PgCharBuilder(name, config);
}

var _a$u, _b$r;
class PgCidrBuilder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgCidr(table, this.config);
    }
}
_a$u = entityKind;
PgCidrBuilder[_a$u] = 'PgCidrBuilder';
class PgCidr extends PgColumn {
    getSQLType() {
        return 'cidr';
    }
}
_b$r = entityKind;
PgCidr[_b$r] = 'PgCidr';
function cidr(name) {
    return new PgCidrBuilder(name);
}

var _a$t, _b$q;
class PgCustomColumnBuilder extends PgColumnBuilder {
    constructor(name, fieldConfig, customTypeParams) {
        super(name);
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
    }
    /** @internal */
    build(table) {
        return new PgCustomColumn(table, this.config);
    }
}
_a$t = entityKind;
PgCustomColumnBuilder[_a$t] = 'PgCustomColumnBuilder';
class PgCustomColumn extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
        this.mapTo = config.customTypeParams.toDriver;
        this.mapFrom = config.customTypeParams.fromDriver;
    }
    getSQLType() {
        return this.sqlName;
    }
    mapFromDriverValue(value) {
        return typeof this.mapFrom === 'function' ? this.mapFrom(value) : value;
    }
    mapToDriverValue(value) {
        return typeof this.mapTo === 'function' ? this.mapTo(value) : value;
    }
}
_b$q = entityKind;
PgCustomColumn[_b$q] = 'PgCustomColumn';
/**
 * Custom pg database data type generator
 */
function customType(customTypeParams) {
    return (dbName, fieldConfig) => {
        return new PgCustomColumnBuilder(dbName, fieldConfig, customTypeParams);
    };
}

var _a$s;
class PgDateColumnBaseBuilder extends PgColumnBuilder {
    defaultNow() {
        return this.default(sql `now()`);
    }
}
_a$s = entityKind;
PgDateColumnBaseBuilder[_a$s] = 'PgDateColumnBaseBuilder';

var _a$r, _b$p, _c$5, _d$3;
class PgDateBuilder extends PgDateColumnBaseBuilder {
    /** @internal */
    build(table) {
        return new PgDate(table, this.config);
    }
}
_a$r = entityKind;
PgDateBuilder[_a$r] = 'PgDateBuilder';
class PgDate extends PgColumn {
    getSQLType() {
        return 'date';
    }
    mapFromDriverValue(value) {
        return new Date(value);
    }
    mapToDriverValue(value) {
        return value.toISOString();
    }
}
_b$p = entityKind;
PgDate[_b$p] = 'PgDate';
class PgDateStringBuilder extends PgDateColumnBaseBuilder {
    /** @internal */
    build(table) {
        return new PgDateString(table, this.config);
    }
}
_c$5 = entityKind;
PgDateStringBuilder[_c$5] = 'PgDateStringBuilder';
class PgDateString extends PgColumn {
    getSQLType() {
        return 'date';
    }
}
_d$3 = entityKind;
PgDateString[_d$3] = 'PgDateString';
function date(name, config) {
    if (config?.mode === 'date') {
        return new PgDateBuilder(name);
    }
    return new PgDateStringBuilder(name);
}

var _a$q, _b$o;
class PgDoublePrecisionBuilder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgDoublePrecision(table, this.config);
    }
}
_a$q = entityKind;
PgDoublePrecisionBuilder[_a$q] = 'PgDoublePrecisionBuilder';
class PgDoublePrecision extends PgColumn {
    getSQLType() {
        return 'double precision';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            return Number.parseFloat(value);
        }
        return value;
    }
}
_b$o = entityKind;
PgDoublePrecision[_b$o] = 'PgDoublePrecision';
function doublePrecision(name) {
    return new PgDoublePrecisionBuilder(name);
}

var _a$p, _b$n;
const isPgEnumSym = Symbol.for('drizzle:isPgEnum');
function isPgEnum(obj) {
    return !!obj && typeof obj === 'function' && isPgEnumSym in obj;
}
class PgEnumColumnBuilder extends PgColumnBuilder {
    constructor(name, enumInstance) {
        super(name);
        this.config.enum = enumInstance;
    }
    /** @internal */
    build(table) {
        return new PgEnumColumn(table, this.config);
    }
}
_a$p = entityKind;
PgEnumColumnBuilder[_a$p] = 'PgEnumColumnBuilder';
class PgEnumColumn extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.enum = this.config.enum;
        this.enumValues = this.config.enum.enumValues;
        this.enum = config.enum;
    }
    getSQLType() {
        return this.enum.enumName;
    }
}
_b$n = entityKind;
PgEnumColumn[_b$n] = 'PgEnumColumn';
// Gratitude to zod for the enum function types
function pgEnum(enumName, values) {
    const enumInstance = Object.assign((name) => new PgEnumColumnBuilder(name, enumInstance), {
        enumName,
        enumValues: values,
        [isPgEnumSym]: true,
    });
    return enumInstance;
}

var _a$o, _b$m;
class PgInetBuilder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgInet(table, this.config);
    }
}
_a$o = entityKind;
PgInetBuilder[_a$o] = 'PgInetBuilder';
class PgInet extends PgColumn {
    getSQLType() {
        return 'inet';
    }
}
_b$m = entityKind;
PgInet[_b$m] = 'PgInet';
function inet(name) {
    return new PgInetBuilder(name);
}

var _a$n, _b$l;
class PgIntegerBuilder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgInteger(table, this.config);
    }
}
_a$n = entityKind;
PgIntegerBuilder[_a$n] = 'PgIntegerBuilder';
class PgInteger extends PgColumn {
    getSQLType() {
        return 'integer';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            return Number.parseInt(value);
        }
        return value;
    }
}
_b$l = entityKind;
PgInteger[_b$l] = 'PgInteger';
function integer(name) {
    return new PgIntegerBuilder(name);
}

var _a$m, _b$k;
class PgIntervalBuilder extends PgColumnBuilder {
    constructor(name, intervalConfig) {
        super(name);
        this.config.intervalConfig = intervalConfig;
    }
    /** @internal */
    build(table) {
        return new PgInterval(table, this.config);
    }
}
_a$m = entityKind;
PgIntervalBuilder[_a$m] = 'PgIntervalBuilder';
class PgInterval extends PgColumn {
    constructor() {
        super(...arguments);
        this.fields = this.config.intervalConfig.fields;
        this.precision = this.config.intervalConfig.precision;
    }
    getSQLType() {
        const fields = this.fields ? ` ${this.fields}` : '';
        const precision = this.precision ? `(${this.precision})` : '';
        return `interval${fields}${precision}`;
    }
}
_b$k = entityKind;
PgInterval[_b$k] = 'PgInterval';
function interval(name, config = {}) {
    return new PgIntervalBuilder(name, config);
}

var _a$l, _b$j;
class PgJsonBuilder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgJson(table, this.config);
    }
}
_a$l = entityKind;
PgJsonBuilder[_a$l] = 'PgJsonBuilder';
class PgJson extends PgColumn {
    constructor(table, config) {
        super(table, config);
    }
    getSQLType() {
        return 'json';
    }
    mapToDriverValue(value) {
        return JSON.stringify(value);
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            try {
                return JSON.parse(value);
            }
            catch {
                return value;
            }
        }
        return value;
    }
}
_b$j = entityKind;
PgJson[_b$j] = 'PgJson';
function json(name) {
    return new PgJsonBuilder(name);
}

var _a$k, _b$i;
class PgJsonbBuilder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgJsonb(table, this.config);
    }
}
_a$k = entityKind;
PgJsonbBuilder[_a$k] = 'PgJsonbBuilder';
class PgJsonb extends PgColumn {
    constructor(table, config) {
        super(table, config);
    }
    getSQLType() {
        return 'jsonb';
    }
    mapToDriverValue(value) {
        return JSON.stringify(value);
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            try {
                return JSON.parse(value);
            }
            catch {
                return value;
            }
        }
        return value;
    }
}
_b$i = entityKind;
PgJsonb[_b$i] = 'PgJsonb';
function jsonb(name) {
    return new PgJsonbBuilder(name);
}

var _a$j, _b$h;
class PgMacaddrBuilder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgMacaddr(table, this.config);
    }
}
_a$j = entityKind;
PgMacaddrBuilder[_a$j] = 'PgMacaddrBuilder';
class PgMacaddr extends PgColumn {
    getSQLType() {
        return 'macaddr';
    }
}
_b$h = entityKind;
PgMacaddr[_b$h] = 'PgMacaddr';
function macaddr(name) {
    return new PgMacaddrBuilder(name);
}

var _a$i, _b$g;
class PgMacaddr8Builder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgMacaddr8(table, this.config);
    }
}
_a$i = entityKind;
PgMacaddr8Builder[_a$i] = 'PgMacaddr8Builder';
class PgMacaddr8 extends PgColumn {
    getSQLType() {
        return 'macaddr8';
    }
}
_b$g = entityKind;
PgMacaddr8[_b$g] = 'PgMacaddr8';
function macaddr8(name) {
    return new PgMacaddr8Builder(name);
}

var _a$h, _b$f;
class PgNumericBuilder extends PgColumnBuilder {
    constructor(name, precision, scale) {
        super(name);
        this.config.precision = precision;
        this.config.scale = scale;
    }
    /** @internal */
    build(table) {
        return new PgNumeric(table, this.config);
    }
}
_a$h = entityKind;
PgNumericBuilder[_a$h] = 'PgNumericBuilder';
class PgNumeric extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.precision = config.precision;
        this.scale = config.scale;
    }
    getSQLType() {
        if (this.precision !== undefined && this.scale !== undefined) {
            return `numeric(${this.precision}, ${this.scale})`;
        }
        else if (this.precision === undefined) {
            return 'numeric';
        }
        else {
            return `numeric(${this.precision})`;
        }
    }
}
_b$f = entityKind;
PgNumeric[_b$f] = 'PgNumeric';
function numeric(name, config) {
    return new PgNumericBuilder(name, config?.precision, config?.scale);
}
const decimal = numeric;

var _a$g, _b$e;
class PgRealBuilder extends PgColumnBuilder {
    constructor(name, length) {
        super(name);
        this.config.length = length;
    }
    /** @internal */
    build(table) {
        return new PgReal(table, this.config);
    }
}
_a$g = entityKind;
PgRealBuilder[_a$g] = 'PgRealBuilder';
class PgReal extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.mapFromDriverValue = (value) => {
            if (typeof value === 'string') {
                return Number.parseFloat(value);
            }
            return value;
        };
    }
    getSQLType() {
        return 'real';
    }
}
_b$e = entityKind;
PgReal[_b$e] = 'PgReal';
function real(name) {
    return new PgRealBuilder(name);
}

var _a$f, _b$d;
class PgSerialBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name);
        this.config.hasDefault = true;
        this.config.notNull = true;
    }
    /** @internal */
    build(table) {
        return new PgSerial(table, this.config);
    }
}
_a$f = entityKind;
PgSerialBuilder[_a$f] = 'PgSerialBuilder';
class PgSerial extends PgColumn {
    getSQLType() {
        return 'serial';
    }
}
_b$d = entityKind;
PgSerial[_b$d] = 'PgSerial';
function serial(name) {
    return new PgSerialBuilder(name);
}

var _a$e, _b$c;
class PgSmallIntBuilder extends PgColumnBuilder {
    /** @internal */
    build(table) {
        return new PgSmallInt(table, this.config);
    }
}
_a$e = entityKind;
PgSmallIntBuilder[_a$e] = 'PgSmallIntBuilder';
class PgSmallInt extends PgColumn {
    constructor() {
        super(...arguments);
        this.mapFromDriverValue = (value) => {
            if (typeof value === 'string') {
                return Number(value);
            }
            return value;
        };
    }
    getSQLType() {
        return 'smallint';
    }
}
_b$c = entityKind;
PgSmallInt[_b$c] = 'PgSmallInt';
function smallint(name) {
    return new PgSmallIntBuilder(name);
}

var _a$d, _b$b;
class PgSmallSerialBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name);
        this.config.hasDefault = true;
        this.config.notNull = true;
    }
    /** @internal */
    build(table) {
        return new PgSmallSerial(table, this.config);
    }
}
_a$d = entityKind;
PgSmallSerialBuilder[_a$d] = 'PgSmallSerialBuilder';
class PgSmallSerial extends PgColumn {
    getSQLType() {
        return 'serial';
    }
}
_b$b = entityKind;
PgSmallSerial[_b$b] = 'PgSmallSerial';
function smallserial(name) {
    return new PgSmallSerialBuilder(name);
}

var _a$c, _b$a;
class PgTextBuilder extends PgColumnBuilder {
    constructor(name, config) {
        super(name);
        this.config.enumValues = (config.enum ?? []);
    }
    /** @internal */
    build(table) {
        return new PgText(table, this.config);
    }
}
_a$c = entityKind;
PgTextBuilder[_a$c] = 'PgTextBuilder';
class PgText extends PgColumn {
    constructor() {
        super(...arguments);
        this.enumValues = this.config.enumValues;
    }
    getSQLType() {
        return 'text';
    }
}
_b$a = entityKind;
PgText[_b$a] = 'PgText';
function text(name, config = {}) {
    return new PgTextBuilder(name, config);
}

var _a$b, _b$9;
class PgTimeBuilder extends PgDateColumnBaseBuilder {
    constructor(name, withTimezone, precision) {
        super(name);
        this.withTimezone = withTimezone;
        this.precision = precision;
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
    }
    /** @internal */
    build(table) {
        return new PgTime(table, this.config);
    }
}
_a$b = entityKind;
PgTimeBuilder[_a$b] = 'PgTimeBuilder';
class PgTime extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
    }
    getSQLType() {
        const precision = this.precision === undefined ? '' : `(${this.precision})`;
        return `time${precision}${this.withTimezone ? ' with time zone' : ''}`;
    }
}
_b$9 = entityKind;
PgTime[_b$9] = 'PgTime';
function time(name, config = {}) {
    return new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);
}

var _a$a, _b$8, _c$4, _d$2;
class PgTimestampBuilder extends PgDateColumnBaseBuilder {
    constructor(name, withTimezone, precision) {
        super(name);
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
    }
    /** @internal */
    build(table) {
        return new PgTimestamp(table, this.config);
    }
}
_a$a = entityKind;
PgTimestampBuilder[_a$a] = 'PgTimestampBuilder';
class PgTimestamp extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.mapFromDriverValue = (value) => {
            return new Date(this.withTimezone ? value : value + '+0000');
        };
        this.mapToDriverValue = (value) => {
            return this.withTimezone ? value.toUTCString() : value.toISOString();
        };
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
    }
    getSQLType() {
        const precision = this.precision === undefined ? '' : ` (${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;
    }
}
_b$8 = entityKind;
PgTimestamp[_b$8] = 'PgTimestamp';
class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
    constructor(name, withTimezone, precision) {
        super(name);
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
    }
    /** @internal */
    build(table) {
        return new PgTimestampString(table, this.config);
    }
}
_c$4 = entityKind;
PgTimestampStringBuilder[_c$4] = 'PgTimestampStringBuilder';
class PgTimestampString extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
    }
    getSQLType() {
        const precision = this.precision === undefined ? '' : `(${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;
    }
}
_d$2 = entityKind;
PgTimestampString[_d$2] = 'PgTimestampString';
function timestamp(name, config = {}) {
    if (config.mode === 'string') {
        return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
    }
    return new PgTimestampBuilder(name, config.withTimezone ?? false, config.precision);
}

var _a$9, _b$7;
class PgUUIDBuilder extends PgColumnBuilder {
    /**
     * Adds `default gen_random_uuid()` to the column definition.
     */
    defaultRandom() {
        return this.default(sql `gen_random_uuid()`);
    }
    /** @internal */
    build(table) {
        return new PgUUID(table, this.config);
    }
}
_a$9 = entityKind;
PgUUIDBuilder[_a$9] = 'PgUUIDBuilder';
class PgUUID extends PgColumn {
    getSQLType() {
        return 'uuid';
    }
}
_b$7 = entityKind;
PgUUID[_b$7] = 'PgUUID';
function uuid(name) {
    return new PgUUIDBuilder(name);
}

var _a$8, _b$6;
class PgVarcharBuilder extends PgColumnBuilder {
    constructor(name, config) {
        super(name);
        this.config.length = config.length;
        this.config.enumValues = (config.enum ?? []);
    }
    /** @internal */
    build(table) {
        return new PgVarchar(table, this.config);
    }
}
_a$8 = entityKind;
PgVarcharBuilder[_a$8] = 'PgVarcharBuilder';
class PgVarchar extends PgColumn {
    constructor() {
        super(...arguments);
        this.length = this.config.length;
        this.enumValues = this.config.enumValues;
    }
    getSQLType() {
        return this.length === undefined ? `varchar` : `varchar(${this.length})`;
    }
}
_b$6 = entityKind;
PgVarchar[_b$6] = 'PgVarchar';
function varchar(name, config = {}) {
    return new PgVarcharBuilder(name, config);
}

var _a$7, _b$5;
class RelationalQueryBuilder {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
    }
    findMany(config) {
        return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, 'many');
    }
    findFirst(config) {
        return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, 'first');
    }
}
_a$7 = entityKind;
RelationalQueryBuilder[_a$7] = 'PgRelationalQueryBuilder';
class PgRelationalQuery extends QueryPromise {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config;
        this.mode = mode;
    }
    _prepare(name) {
        return tracer.startActiveSpan('drizzle.prepareQuery', () => {
            const query = this.dialect.buildRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.config, this.tableConfig.tsName, [], true);
            const builtQuery = this.dialect.sqlToQuery(query.sql);
            return this.session.prepareQuery(builtQuery, undefined, name, (rawRows, mapColumnValue) => {
                const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
                if (this.mode === 'first') {
                    return rows[0];
                }
                return rows;
            });
        });
    }
    prepare(name) {
        return this._prepare(name);
    }
    execute() {
        return tracer.startActiveSpan('drizzle.operation', () => {
            return this._prepare().execute();
        });
    }
}
_b$5 = entityKind;
PgRelationalQuery[_b$5] = 'PgRelationalQuery';

var _a$6;
class PgDatabase {
    constructor(
    /** @internal */
    dialect, 
    /** @internal */
    session, schema) {
        this.dialect = dialect;
        this.session = session;
        this._ = schema
            ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap }
            : { schema: undefined, tableNamesMap: {} };
        this.query = {};
        if (this._.schema) {
            for (const [tableName, columns] of Object.entries(this._.schema)) {
                this.query[tableName] = new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
            }
        }
    }
    $with(alias) {
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(new QueryBuilder());
                }
                return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new PgSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
            });
        }
        return { select };
    }
    select(fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: this.session,
            dialect: this.dialect,
        });
    }
    selectDistinct(fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: this.session,
            dialect: this.dialect,
            distinct: true,
        });
    }
    selectDistinctOn(on, fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: this.session,
            dialect: this.dialect,
            distinct: { on },
        });
    }
    update(table) {
        return new PgUpdateBuilder(table, this.session, this.dialect);
    }
    insert(table) {
        return new PgInsertBuilder(table, this.session, this.dialect);
    }
    delete(table) {
        return new PgDelete(table, this.session, this.dialect);
    }
    refreshMaterializedView(view) {
        return new PgRefreshMaterializedView(view, this.session, this.dialect);
    }
    execute(query) {
        return this.session.execute(query.getSQL());
    }
    transaction(transaction, config) {
        return this.session.transaction(transaction, config);
    }
}
_a$6 = entityKind;
PgDatabase[_a$6] = 'PgDatabase';

var _a$5;
class PgSchema {
    constructor(schemaName) {
        this.schemaName = schemaName;
        this.table = ((name, columns, extraConfig) => {
            return pgTableWithSchema(name, columns, extraConfig, this.schemaName);
        });
        this.view = ((name, columns) => {
            return pgViewWithSchema(name, columns, this.schemaName);
        });
        this.materializedView = ((name, columns) => {
            return pgMaterializedViewWithSchema(name, columns, this.schemaName);
        });
    }
}
_a$5 = entityKind;
PgSchema[_a$5] = 'PgSchema';
function isPgSchema(obj) {
    return is(obj, PgSchema);
}
function pgSchema(name) {
    if (name === 'public') {
        throw new Error(`You can't specify 'public' as schema name. Postgres is using public schema by default. If you want to use 'public' schema, just use pgTable() instead of creating a schema`);
    }
    return new PgSchema(name);
}

var _a$4, _b$4;
class DrizzleError extends Error {
    constructor(message) {
        super(message);
        this.name = 'DrizzleError';
    }
    static wrap(error, message) {
        return error instanceof Error // eslint-disable-line no-instanceof/no-instanceof
            ? new DrizzleError(message ? `${message}: ${error.message}` : error.message)
            : new DrizzleError(message ?? String(error));
    }
}
_a$4 = entityKind;
DrizzleError[_a$4] = 'DrizzleError';
class TransactionRollbackError extends DrizzleError {
    constructor() {
        super('Rollback');
    }
}
_b$4 = entityKind;
TransactionRollbackError[_b$4] = 'TransactionRollbackError';

var _a$3, _b$3, _c$3;
class PreparedQuery {
}
_a$3 = entityKind;
PreparedQuery[_a$3] = 'PgPreparedQuery';
class PgSession {
    constructor(dialect) {
        this.dialect = dialect;
    }
    execute(query) {
        return tracer.startActiveSpan('drizzle.operation', () => {
            const prepared = tracer.startActiveSpan('drizzle.prepareQuery', () => {
                return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined);
            });
            return prepared.execute();
        });
    }
    all(query) {
        return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined).all();
    }
}
_b$3 = entityKind;
PgSession[_b$3] = 'PgSession';
class PgTransaction extends PgDatabase {
    constructor(dialect, session, schema, nestedIndex = 0) {
        super(dialect, session, schema);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
    }
    rollback() {
        throw new TransactionRollbackError();
    }
    /** @internal */
    getTransactionConfigSQL(config) {
        const chunks = [];
        if (config.isolationLevel) {
            chunks.push(`isolation level ${config.isolationLevel}`);
        }
        if (config.accessMode) {
            chunks.push(config.accessMode);
        }
        if (typeof config.deferrable === 'boolean') {
            chunks.push(config.deferrable ? 'deferrable' : 'not deferrable');
        }
        return sql.raw(chunks.join(' '));
    }
    setTransaction(config) {
        return this.session.execute(sql `set transaction ${this.getTransactionConfigSQL(config)}`);
    }
}
_c$3 = entityKind;
PgTransaction[_c$3] = 'PgTransaction';

var _a$2, _b$2, _c$2, _d$1;
class Relation {
    constructor(sourceTable, referencedTable, relationName) {
        this.sourceTable = sourceTable;
        this.referencedTable = referencedTable;
        this.relationName = relationName;
        this.referencedTableName = referencedTable[Table.Symbol.Name];
    }
}
_a$2 = entityKind;
Relation[_a$2] = 'Relation';
class Relations {
    constructor(table, config) {
        this.table = table;
        this.config = config;
    }
}
_b$2 = entityKind;
Relations[_b$2] = 'Relations';
class One extends Relation {
    constructor(sourceTable, referencedTable, config, isNullable) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
        this.isNullable = isNullable;
    }
    withFieldName(fieldName) {
        const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
        relation.fieldName = fieldName;
        return relation;
    }
}
_c$2 = entityKind;
One[_c$2] = 'One';
class Many extends Relation {
    constructor(sourceTable, referencedTable, config) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
    }
    withFieldName(fieldName) {
        const relation = new Many(this.sourceTable, this.referencedTable, this.config);
        relation.fieldName = fieldName;
        return relation;
    }
}
_d$1 = entityKind;
Many[_d$1] = 'Many';
const operators = {
    sql,
    eq,
    and,
    or,
};
const orderByOperators = {
    sql,
    asc,
    desc,
};
function extractTablesRelationalConfig(schema, configHelpers) {
    if (Object.keys(schema).length === 1 && 'default' in schema && !is(schema['default'], Table)) {
        schema = schema['default'];
    }
    // table DB name -> schema table key
    const tableNamesMap = {};
    // Table relations found before their tables - need to buffer them until we know the schema table key
    const relationsBuffer = {};
    const tablesConfig = {};
    for (const [key, value] of Object.entries(schema)) {
        if (isTable(value)) {
            const dbName = value[Table.Symbol.Name];
            const bufferedRelations = relationsBuffer[dbName];
            tableNamesMap[dbName] = key;
            tablesConfig[key] = {
                tsName: key,
                dbName: value[Table.Symbol.Name],
                columns: value[Table.Symbol.Columns],
                relations: bufferedRelations?.relations ?? {},
                primaryKey: bufferedRelations?.primaryKey ?? [],
            };
            // Fill in primary keys
            for (const column of Object.values(value[Table.Symbol.Columns])) {
                if (column.primary) {
                    tablesConfig[key].primaryKey.push(column);
                }
            }
            const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);
            if (extraConfig) {
                for (const configEntry of Object.values(extraConfig)) {
                    if (is(configEntry, PrimaryKeyBuilder)) {
                        tablesConfig[key].primaryKey.push(...configEntry.columns);
                    }
                }
            }
        }
        else if (is(value, Relations)) {
            const dbName = value.table[Table.Symbol.Name];
            const tableName = tableNamesMap[dbName];
            const relations = value.config(configHelpers(value.table));
            let primaryKey;
            for (const [relationName, relation] of Object.entries(relations)) {
                if (tableName) {
                    const tableConfig = tablesConfig[tableName];
                    tableConfig.relations[relationName] = relation;
                }
                else {
                    if (!(dbName in relationsBuffer)) {
                        relationsBuffer[dbName] = {
                            relations: {},
                            primaryKey,
                        };
                    }
                    relationsBuffer[dbName].relations[relationName] = relation;
                }
            }
        }
    }
    return { tables: tablesConfig, tableNamesMap };
}
function relations(table, relations) {
    return new Relations(table, (helpers) => Object.fromEntries(Object.entries(relations(helpers))
        .map(([key, value]) => [key, value.withFieldName(key)])));
}
function createOne(sourceTable) {
    return function one(table, config) {
        return new One(sourceTable, table, config, (config?.fields.reduce((res, f) => res && f.notNull, true) ?? false));
    };
}
function createMany(sourceTable) {
    return function many(referencedTable, config) {
        return new Many(sourceTable, referencedTable, config);
    };
}
function normalizeRelation(schema, tableNamesMap, relation) {
    if (is(relation, One) && relation.config) {
        return {
            fields: relation.config.fields,
            references: relation.config.references,
        };
    }
    const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
    if (!referencedTableTsName) {
        throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
    }
    const referencedTableFields = schema[referencedTableTsName];
    if (!referencedTableFields) {
        throw new Error(`Table "${referencedTableTsName}" not found in schema`);
    }
    const sourceTable = relation.sourceTable;
    const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
    if (!sourceTableTsName) {
        throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
    }
    const reverseRelations = [];
    for (const referencedTableRelation of Object.values(referencedTableFields.relations)) {
        if ((relation.relationName && relation !== referencedTableRelation
            && referencedTableRelation.relationName === relation.relationName)
            || (!relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable)) {
            reverseRelations.push(referencedTableRelation);
        }
    }
    if (reverseRelations.length > 1) {
        throw relation.relationName
            ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`)
            : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
    }
    if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
        return {
            fields: reverseRelations[0].config.references,
            references: reverseRelations[0].config.fields,
        };
    }
    throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
    return {
        one: createOne(sourceTable),
        many: createMany(sourceTable),
    };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
    const result = {};
    for (const [selectionItemIndex, selectionItem] of buildQueryResultSelection.entries()) {
        if (selectionItem.isJson) {
            const relation = tableConfig.relations[selectionItem.tsKey];
            const rawSubRows = row[selectionItemIndex];
            const subRows = typeof rawSubRows === 'string' ? JSON.parse(rawSubRows) : rawSubRows;
            if (is(relation, One)) {
                result[selectionItem.tsKey] = subRows[0]
                    ? mapRelationalRow(tablesConfig, tablesConfig[selectionItem.tableTsKey], subRows[0], selectionItem.selection, mapColumnValue)
                    : null;
            }
            else {
                result[selectionItem.tsKey] = subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.tableTsKey], subRow, selectionItem.selection, mapColumnValue));
            }
        }
        else {
            const value = mapColumnValue(row[selectionItemIndex]);
            const field = selectionItem.field;
            let decoder;
            if (is(field, Column)) {
                decoder = field;
            }
            else if (is(field, SQL)) {
                decoder = field.decoder;
            }
            else {
                decoder = field.sql.decoder;
            }
            result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
        }
    }
    return result;
}

function bindIfParam(value, column) {
    if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder)
        && !is(value, Column) && !is(value, Table) && !is(value, View)) {
        return new Param(value, column);
    }
    return value;
}
function eq(left, right) {
    return sql `${left} = ${bindIfParam(right, left)}`;
}
function ne(left, right) {
    return sql `${left} <> ${bindIfParam(right, left)}`;
}
function and(...unfilteredConditions) {
    const conditions = unfilteredConditions.filter((c) => c !== undefined);
    if (conditions.length === 0) {
        return undefined;
    }
    if (conditions.length === 1) {
        return conditions[0];
    }
    const chunks = [sql.raw('(')];
    for (const [index, condition] of conditions.entries()) {
        if (index === 0) {
            chunks.push(condition);
        }
        else {
            chunks.push(sql ` and `, condition);
        }
    }
    chunks.push(sql `)`);
    return sql.fromList(chunks);
}
function or(...unfilteredConditions) {
    const conditions = unfilteredConditions.filter((c) => c !== undefined);
    if (conditions.length === 0) {
        return undefined;
    }
    if (conditions.length === 1) {
        return conditions[0];
    }
    const chunks = [sql.raw('(')];
    for (const [index, condition] of conditions.entries()) {
        if (index === 0) {
            chunks.push(condition);
        }
        else {
            chunks.push(sql ` or `, condition);
        }
    }
    chunks.push(sql `)`);
    return sql.fromList(chunks);
}
/**
 * Negate the meaning of an expression using the `not` keyword.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars _not_ made by GM or Ford.
 * db.select().from(cars)
 *   .where(not(inArray(cars.make, ['GM', 'Ford'])))
 * ```
 */
function not(condition) {
    return sql `not ${condition}`;
}
function gt(left, right) {
    return sql `${left} > ${bindIfParam(right, left)}`;
}
function gte(left, right) {
    return sql `${left} >= ${bindIfParam(right, left)}`;
}
function lt(left, right) {
    return sql `${left} < ${bindIfParam(right, left)}`;
}
function lte(left, right) {
    return sql `${left} <= ${bindIfParam(right, left)}`;
}
function inArray(column, values) {
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('inArray requires at least one value');
        }
        return sql `${column} in ${values.map((v) => bindIfParam(v, column))}`;
    }
    return sql `${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
    if (isSQLWrapper(values)) {
        return sql `${column} not in ${values}`;
    }
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('inArray requires at least one value');
        }
        return sql `${column} not in ${values.map((v) => bindIfParam(v, column))}`;
    }
    return sql `${column} not in ${bindIfParam(values, column)}`;
}
/**
 * Test whether an expression is NULL. By the SQL standard,
 * NULL is neither equal nor not equal to itself, so
 * it's recommended to use `isNull` and `notIsNull` for
 * comparisons to NULL.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars that have no discontinuedAt date.
 * db.select().from(cars)
 *   .where(isNull(cars.discontinuedAt))
 * ```
 *
 * @see isNotNull for the inverse of this test
 */
function isNull(column) {
    return sql `${column} is null`;
}
/**
 * Test whether an expression is not NULL. By the SQL standard,
 * NULL is neither equal nor not equal to itself, so
 * it's recommended to use `isNull` and `notIsNull` for
 * comparisons to NULL.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars that have been discontinued.
 * db.select().from(cars)
 *   .where(isNotNull(cars.discontinuedAt))
 * ```
 *
 * @see isNull for the inverse of this test
 */
function isNotNull(column) {
    return sql `${column} is not null`;
}
/**
 * Test whether a subquery evaluates to have any rows.
 *
 * ## Examples
 *
 * ```ts
 * // Users whose `homeCity` column has a match in a cities
 * // table.
 * db
 *   .select()
 *   .from(users)
 *   .where(
 *     exists(db.select()
 *       .from(cities)
 *       .where(eq(users.homeCity, cities.id))),
 *   );
 * ```
 *
 * @see notExists for the inverse of this test
 */
function exists(subquery) {
    return sql `exists (${subquery})`;
}
/**
 * Test whether a subquery doesn't include any result
 * rows.
 *
 * ## Examples
 *
 * ```ts
 * // Users whose `homeCity` column doesn't match
 * // a row in the cities table.
 * db
 *   .select()
 *   .from(users)
 *   .where(
 *     notExists(db.select()
 *       .from(cities)
 *       .where(eq(users.homeCity, cities.id))),
 *   );
 * ```
 *
 * @see exists for the inverse of this test
 */
function notExists(subquery) {
    return sql `not exists (${subquery})`;
}
function between(column, min, max) {
    return sql `${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function notBetween(column, min, max) {
    return sql `${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
/**
 * Compare a column to a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars with 'Turbo' in their names.
 * db.select().from(cars)
 *   .where(like(cars.name, '%Turbo%'))
 * ```
 *
 * @see ilike for a case-insensitive version of this condition
 */
function like(column, value) {
    return sql `${column} like ${value}`;
}
/**
 * The inverse of like - this tests that a given column
 * does not match a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars that don't have "ROver" in their name.
 * db.select().from(cars)
 *   .where(notLike(cars.name, '%Rover%'))
 * ```
 *
 * @see like for the inverse condition
 * @see notIlike for a case-insensitive version of this condition
 */
function notLike(column, value) {
    return sql `${column} not like ${value}`;
}
/**
 * Case-insensitively compare a column to a pattern,
 * which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * Unlike like, this performs a case-insensitive comparison.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars with 'Turbo' in their names.
 * db.select().from(cars)
 *   .where(ilike(cars.name, '%Turbo%'))
 * ```
 *
 * @see like for a case-sensitive version of this condition
 */
function ilike(column, value) {
    return sql `${column} ilike ${value}`;
}
/**
 * The inverse of ilike - this case-insensitively tests that a given column
 * does not match a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars that don't have "Rover" in their name.
 * db.select().from(cars)
 *   .where(notLike(cars.name, '%Rover%'))
 * ```
 *
 * @see ilike for the inverse condition
 * @see notLike for a case-sensitive version of this condition
 */
function notIlike(column, value) {
    return sql `${column} not ilike ${value}`;
}

/**
 * Used in sorting, this specifies that the given
 * column or expression should be sorted in ascending
 * order. By the SQL standard, ascending order is the
 * default, so it is not usually necessary to specify
 * ascending sort order.
 *
 * ## Examples
 *
 * ```ts
 * // Return cars, starting with the oldest models
 * // and going in ascending order to the newest.
 * db.select().from(cars)
 *   .orderBy(asc(cars.year));
 * ```
 *
 * @see desc to sort in descending order
 */
function asc(column) {
    return sql `${column} asc`;
}
/**
 * Used in sorting, this specifies that the given
 * column or expression should be sorted in descending
 * order.
 *
 * ## Examples
 *
 * ```ts
 * // Select users, with the most recently created
 * // records coming first.
 * db.select().from(users)
 *   .orderBy(desc(users.createdAt));
 * ```
 *
 * @see asc to sort in ascending order
 */
function desc(column) {
    return sql `${column} desc`;
}

var _a$1, _b$1, _c$1, _d, _e, _f;
/**
 * This class is used to indicate a primitive param value that is used in `sql` tag.
 * It is only used on type level and is never instantiated at runtime.
 * If you see a value of this type in the code, its runtime value is actually the primitive param value.
 */
class FakePrimitiveParam {
}
_a$1 = entityKind;
FakePrimitiveParam[_a$1] = 'FakePrimitiveParam';
function isSQLWrapper(value) {
    return typeof value === 'object' && value !== null && 'getSQL' in value
        && typeof value.getSQL === 'function';
}
function mergeQueries(queries) {
    const result = { sql: '', params: [] };
    for (const query of queries) {
        result.sql += query.sql;
        result.params.push(...query.params);
        if (query.typings?.length) {
            result.typings = result.typings || [];
            result.typings.push(...query.typings);
        }
    }
    return result;
}
class StringChunk {
    constructor(value) {
        this.value = Array.isArray(value) ? value : [value];
    }
}
_b$1 = entityKind;
StringChunk[_b$1] = 'StringChunk';
class SQL {
    constructor(queryChunks) {
        this.queryChunks = queryChunks;
        /** @internal */
        this.decoder = noopDecoder;
        this.shouldInlineParams = false;
    }
    append(query) {
        this.queryChunks.push(...query.queryChunks);
        return this;
    }
    toQuery(config) {
        return tracer.startActiveSpan('drizzle.buildSQL', (span) => {
            const query = this.buildQueryFromSourceParams(this.queryChunks, config);
            span?.setAttributes({
                'drizzle.query.text': query.sql,
                'drizzle.query.params': JSON.stringify(query.params),
            });
            return query;
        });
    }
    buildQueryFromSourceParams(chunks, _config) {
        const config = Object.assign({}, _config, {
            inlineParams: _config.inlineParams || this.shouldInlineParams,
            paramStartIndex: _config.paramStartIndex || { value: 0 },
        });
        const { escapeName, escapeParam, prepareTyping, inlineParams, paramStartIndex, } = config;
        return mergeQueries(chunks.map((chunk) => {
            if (is(chunk, StringChunk)) {
                return { sql: chunk.value.join(''), params: [] };
            }
            if (is(chunk, Name)) {
                return { sql: escapeName(chunk.value), params: [] };
            }
            if (chunk === undefined) {
                return { sql: '', params: [] };
            }
            if (Array.isArray(chunk)) {
                const result = [new StringChunk('(')];
                for (const [i, p] of chunk.entries()) {
                    result.push(p);
                    if (i < chunk.length - 1) {
                        result.push(new StringChunk(', '));
                    }
                }
                result.push(new StringChunk(')'));
                return this.buildQueryFromSourceParams(result, config);
            }
            if (is(chunk, SQL)) {
                return this.buildQueryFromSourceParams(chunk.queryChunks, {
                    ...config,
                    inlineParams: inlineParams || chunk.shouldInlineParams,
                });
            }
            if (is(chunk, Table)) {
                const schemaName = chunk[Table.Symbol.Schema];
                const tableName = chunk[Table.Symbol.Name];
                return {
                    sql: schemaName === undefined
                        ? escapeName(tableName)
                        : escapeName(schemaName) + '.' + escapeName(tableName),
                    params: [],
                };
            }
            if (is(chunk, Column)) {
                return { sql: escapeName(chunk.table[Table.Symbol.Name]) + '.' + escapeName(chunk.name), params: [] };
            }
            if (is(chunk, View)) {
                const schemaName = chunk[ViewBaseConfig].schema;
                const viewName = chunk[ViewBaseConfig].name;
                return {
                    sql: schemaName === undefined
                        ? escapeName(viewName)
                        : escapeName(schemaName) + '.' + escapeName(viewName),
                    params: [],
                };
            }
            if (is(chunk, Param)) {
                const mappedValue = (chunk.value === null) ? null : chunk.encoder.mapToDriverValue(chunk.value);
                if (is(mappedValue, SQL)) {
                    return this.buildQueryFromSourceParams([mappedValue], config);
                }
                if (inlineParams) {
                    return { sql: this.mapInlineParam(mappedValue, config), params: [] };
                }
                let typings;
                if (prepareTyping !== undefined) {
                    typings = [prepareTyping(chunk.encoder)];
                }
                return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
            }
            if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
                return { sql: escapeName(chunk.fieldAlias), params: [] };
            }
            if (is(chunk, Subquery)) {
                if (chunk[SubqueryConfig].isWith) {
                    return { sql: escapeName(chunk[SubqueryConfig].alias), params: [] };
                }
                return this.buildQueryFromSourceParams([
                    new StringChunk('('),
                    chunk[SubqueryConfig].sql,
                    new StringChunk(') '),
                    new Name(chunk[SubqueryConfig].alias),
                ], config);
            }
            if (isSQLWrapper(chunk)) {
                return this.buildQueryFromSourceParams([
                    new StringChunk('('),
                    chunk.getSQL(),
                    new StringChunk(')'),
                ], config);
            }
            if (is(chunk, Relation)) {
                return this.buildQueryFromSourceParams([
                    chunk.sourceTable,
                    new StringChunk('.'),
                    sql.identifier(chunk.fieldName),
                ], config);
            }
            if (inlineParams) {
                return { sql: this.mapInlineParam(chunk, config), params: [] };
            }
            return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
        }));
    }
    mapInlineParam(chunk, { escapeString }) {
        if (chunk === null) {
            return 'null';
        }
        if (typeof chunk === 'number' || typeof chunk === 'boolean') {
            return chunk.toString();
        }
        if (typeof chunk === 'string') {
            return escapeString(chunk);
        }
        if (typeof chunk === 'object') {
            const mappedValueAsString = chunk.toString();
            if (mappedValueAsString === '[object Object]') {
                return escapeString(JSON.stringify(chunk));
            }
            return escapeString(mappedValueAsString);
        }
        throw new Error('Unexpected param value: ' + chunk);
    }
    getSQL() {
        return this;
    }
    as(alias) {
        // TODO: remove with deprecated overloads
        if (alias === undefined) {
            return this;
        }
        return new SQL.Aliased(this, alias);
    }
    mapWith(decoder) {
        this.decoder = typeof decoder === 'function' ? { mapFromDriverValue: decoder } : decoder;
        return this;
    }
    inlineParams() {
        this.shouldInlineParams = true;
        return this;
    }
}
_c$1 = entityKind;
SQL[_c$1] = 'SQL';
/**
 * Any DB name (table, column, index etc.)
 */
class Name {
    constructor(value) {
        this.value = value;
    }
}
_d = entityKind;
Name[_d] = 'Name';
/**
 * Any DB name (table, column, index etc.)
 * @deprecated Use `sql.identifier` instead.
 */
function name(value) {
    return new Name(value);
}
function isDriverValueEncoder(value) {
    return typeof value === 'object' && value !== null && 'mapToDriverValue' in value
        && typeof value.mapToDriverValue === 'function';
}
const noopDecoder = {
    mapFromDriverValue: (value) => value,
};
const noopEncoder = {
    mapToDriverValue: (value) => value,
};
const noopMapper = {
    ...noopDecoder,
    ...noopEncoder,
};
/** Parameter value that is optionally bound to an encoder (for example, a column). */
class Param {
    /**
     * @param value - Parameter value
     * @param encoder - Encoder to convert the value to a driver parameter
     */
    constructor(value, encoder = noopEncoder) {
        this.value = value;
        this.encoder = encoder;
    }
}
_e = entityKind;
Param[_e] = 'Param';
function param(value, encoder) {
    return new Param(value, encoder);
}
/*
    The type of `params` is specified as `SQLSourceParam[]`, but that's slightly incorrect -
    in runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values
    which will be wrapped in `Param` using `buildChunksFromParam(...)`. That's why the overload
    specify `params` as `any[]` and not as `SQLSourceParam[]`. This type is used to make our lives easier and
    the type checker happy.
*/
function sql(strings, ...params) {
    const queryChunks = [];
    if (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {
        queryChunks.push(new StringChunk(strings[0]));
    }
    for (const [paramIndex, param] of params.entries()) {
        queryChunks.push(param, new StringChunk(strings[paramIndex + 1]));
    }
    return new SQL(queryChunks);
}
(function (sql) {
    function empty() {
        return new SQL([]);
    }
    sql.empty = empty;
    function fromList(list) {
        return new SQL(list);
    }
    sql.fromList = fromList;
    /**
     * Convenience function to create an SQL query from a raw string.
     * @param str The raw SQL query string.
     */
    function raw(str) {
        return new SQL([new StringChunk(str)]);
    }
    sql.raw = raw;
    /**
     * Convenience function to join a list of SQL chunks with a separator.
     */
    function join(chunks, separator) {
        const result = [];
        for (const [i, chunk] of chunks.entries()) {
            if (i > 0) {
                result.push(separator);
            }
            result.push(chunk);
        }
        return sql.fromList(result);
    }
    sql.join = join;
    /**
     *  Any DB identifier (table name, column name, index name etc.)
     */
    function identifier(value) {
        return name(value);
    }
    sql.identifier = identifier;
})(sql || (sql = {}));
(function (SQL) {
    var _g;
    class Aliased {
        constructor(sql, fieldAlias) {
            this.sql = sql;
            this.fieldAlias = fieldAlias;
            /** @internal */
            this.isSelectionField = false;
        }
        getSQL() {
            return this.sql;
        }
        /** @internal */
        clone() {
            return new Aliased(this.sql, this.fieldAlias);
        }
    }
    _g = entityKind;
    Aliased[_g] = 'SQL.Aliased';
    SQL.Aliased = Aliased;
})(SQL || (SQL = {}));
class Placeholder {
    constructor(name) {
        this.name = name;
    }
}
_f = entityKind;
Placeholder[_f] = 'Placeholder';
function placeholder(name) {
    return new Placeholder(name);
}
function fillPlaceholders(params, values) {
    return params.map((p) => {
        if (is(p, Placeholder)) {
            if (!(p.name in values)) {
                throw new Error(`No value for placeholder "${p.name}" was provided`);
            }
            return values[p.name];
        }
        return p;
    });
}

var _a, _b, _c;
class ColumnAliasProxyHandler {
    constructor(table) {
        this.table = table;
    }
    get(columnObj, prop) {
        if (prop === 'table') {
            return this.table;
        }
        return columnObj[prop];
    }
}
_a = entityKind;
ColumnAliasProxyHandler[_a] = 'ColumnAliasProxyHandler';
class TableAliasProxyHandler {
    constructor(alias, replaceOriginalName) {
        this.alias = alias;
        this.replaceOriginalName = replaceOriginalName;
    }
    get(target, prop) {
        if (prop === Table.Symbol.IsAlias) {
            return true;
        }
        if (prop === Table.Symbol.Name) {
            return this.alias;
        }
        if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
            return this.alias;
        }
        if (prop === ViewBaseConfig) {
            return {
                ...target[ViewBaseConfig],
                name: this.alias,
                isAlias: true,
            };
        }
        if (prop === Table.Symbol.Columns) {
            const columns = target[Table.Symbol.Columns];
            if (!columns) {
                return columns;
            }
            const proxiedColumns = {};
            Object.keys(columns).map((key) => {
                proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
            });
            return proxiedColumns;
        }
        const value = target[prop];
        if (is(value, Column)) {
            return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
        }
        return value;
    }
}
_b = entityKind;
TableAliasProxyHandler[_b] = 'TableAliasProxyHandler';
class RelationTableAliasProxyHandler {
    constructor(alias) {
        this.alias = alias;
    }
    get(target, prop) {
        if (prop === 'sourceTable') {
            return aliasedTable(target.sourceTable, this.alias);
        }
        return target[prop];
    }
}
_c = entityKind;
RelationTableAliasProxyHandler[_c] = 'RelationTableAliasProxyHandler';
function aliasedTable(table, tableAlias) {
    return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedRelation(relation, tableAlias) {
    return new Proxy(relation, new RelationTableAliasProxyHandler(tableAlias));
}
function aliasedTableColumn(column, tableAlias) {
    return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
    return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
    return sql.fromList(query.queryChunks.map((c) => {
        if (is(c, Column)) {
            return aliasedTableColumn(c, alias);
        }
        if (is(c, SQL)) {
            return mapColumnsInSQLToAlias(c, alias);
        }
        if (is(c, SQL.Aliased)) {
            return mapColumnsInAliasedSQLToAlias(c, alias);
        }
        return c;
    }));
}

exports.BaseName = BaseName;
exports.Check = Check;
exports.CheckBuilder = CheckBuilder;
exports.Column = Column;
exports.ColumnAliasProxyHandler = ColumnAliasProxyHandler;
exports.ColumnBuilder = ColumnBuilder;
exports.Columns = Columns;
exports.DefaultViewBuilderCore = DefaultViewBuilderCore;
exports.DrizzleError = DrizzleError;
exports.ExtraConfigBuilder = ExtraConfigBuilder;
exports.FakePrimitiveParam = FakePrimitiveParam;
exports.ForeignKey = ForeignKey;
exports.ForeignKeyBuilder = ForeignKeyBuilder;
exports.Index = Index;
exports.IndexBuilder = IndexBuilder;
exports.IndexBuilderOn = IndexBuilderOn;
exports.InlineForeignKeys = InlineForeignKeys;
exports.IsAlias = IsAlias;
exports.ManualMaterializedViewBuilder = ManualMaterializedViewBuilder;
exports.ManualViewBuilder = ManualViewBuilder;
exports.Many = Many;
exports.MaterializedViewBuilder = MaterializedViewBuilder;
exports.MaterializedViewBuilderCore = MaterializedViewBuilderCore;
exports.Name = Name;
exports.One = One;
exports.OriginalName = OriginalName;
exports.Param = Param;
exports.PgArray = PgArray;
exports.PgArrayBuilder = PgArrayBuilder;
exports.PgBigInt53 = PgBigInt53;
exports.PgBigInt53Builder = PgBigInt53Builder;
exports.PgBigInt64 = PgBigInt64;
exports.PgBigInt64Builder = PgBigInt64Builder;
exports.PgBigSerial53 = PgBigSerial53;
exports.PgBigSerial53Builder = PgBigSerial53Builder;
exports.PgBigSerial64 = PgBigSerial64;
exports.PgBigSerial64Builder = PgBigSerial64Builder;
exports.PgBoolean = PgBoolean;
exports.PgBooleanBuilder = PgBooleanBuilder;
exports.PgChar = PgChar;
exports.PgCharBuilder = PgCharBuilder;
exports.PgCidr = PgCidr;
exports.PgCidrBuilder = PgCidrBuilder;
exports.PgColumn = PgColumn;
exports.PgColumnBuilder = PgColumnBuilder;
exports.PgCustomColumn = PgCustomColumn;
exports.PgCustomColumnBuilder = PgCustomColumnBuilder;
exports.PgDatabase = PgDatabase;
exports.PgDate = PgDate;
exports.PgDateBuilder = PgDateBuilder;
exports.PgDateString = PgDateString;
exports.PgDateStringBuilder = PgDateStringBuilder;
exports.PgDelete = PgDelete;
exports.PgDialect = PgDialect;
exports.PgDoublePrecision = PgDoublePrecision;
exports.PgDoublePrecisionBuilder = PgDoublePrecisionBuilder;
exports.PgEnumColumn = PgEnumColumn;
exports.PgEnumColumnBuilder = PgEnumColumnBuilder;
exports.PgInet = PgInet;
exports.PgInetBuilder = PgInetBuilder;
exports.PgInsert = PgInsert;
exports.PgInsertBuilder = PgInsertBuilder;
exports.PgInteger = PgInteger;
exports.PgIntegerBuilder = PgIntegerBuilder;
exports.PgInterval = PgInterval;
exports.PgIntervalBuilder = PgIntervalBuilder;
exports.PgJson = PgJson;
exports.PgJsonBuilder = PgJsonBuilder;
exports.PgJsonb = PgJsonb;
exports.PgJsonbBuilder = PgJsonbBuilder;
exports.PgMacaddr = PgMacaddr;
exports.PgMacaddr8 = PgMacaddr8;
exports.PgMacaddr8Builder = PgMacaddr8Builder;
exports.PgMacaddrBuilder = PgMacaddrBuilder;
exports.PgMaterializedView = PgMaterializedView;
exports.PgMaterializedViewConfig = PgMaterializedViewConfig;
exports.PgNumeric = PgNumeric;
exports.PgNumericBuilder = PgNumericBuilder;
exports.PgReal = PgReal;
exports.PgRealBuilder = PgRealBuilder;
exports.PgRefreshMaterializedView = PgRefreshMaterializedView;
exports.PgSchema = PgSchema;
exports.PgSelect = PgSelect;
exports.PgSelectBuilder = PgSelectBuilder;
exports.PgSelectQueryBuilder = PgSelectQueryBuilder;
exports.PgSerial = PgSerial;
exports.PgSerialBuilder = PgSerialBuilder;
exports.PgSession = PgSession;
exports.PgSmallInt = PgSmallInt;
exports.PgSmallIntBuilder = PgSmallIntBuilder;
exports.PgSmallSerial = PgSmallSerial;
exports.PgSmallSerialBuilder = PgSmallSerialBuilder;
exports.PgTable = PgTable;
exports.PgText = PgText;
exports.PgTextBuilder = PgTextBuilder;
exports.PgTime = PgTime;
exports.PgTimeBuilder = PgTimeBuilder;
exports.PgTimestamp = PgTimestamp;
exports.PgTimestampBuilder = PgTimestampBuilder;
exports.PgTimestampString = PgTimestampString;
exports.PgTimestampStringBuilder = PgTimestampStringBuilder;
exports.PgTransaction = PgTransaction;
exports.PgUUID = PgUUID;
exports.PgUUIDBuilder = PgUUIDBuilder;
exports.PgUpdate = PgUpdate;
exports.PgUpdateBuilder = PgUpdateBuilder;
exports.PgVarchar = PgVarchar;
exports.PgVarcharBuilder = PgVarcharBuilder;
exports.PgView = PgView;
exports.PgViewBase = PgViewBase;
exports.PgViewConfig = PgViewConfig;
exports.Placeholder = Placeholder;
exports.PreparedQuery = PreparedQuery;
exports.PrimaryKey = PrimaryKey;
exports.PrimaryKeyBuilder = PrimaryKeyBuilder;
exports.QueryBuilder = QueryBuilder;
exports.QueryPromise = QueryPromise;
exports.Relation = Relation;
exports.RelationTableAliasProxyHandler = RelationTableAliasProxyHandler;
exports.Relations = Relations;
exports.SQL = SQL;
exports.Schema = Schema;
exports.SelectionProxyHandler = SelectionProxyHandler;
exports.StringChunk = StringChunk;
exports.Subquery = Subquery;
exports.SubqueryConfig = SubqueryConfig;
exports.Table = Table;
exports.TableAliasProxyHandler = TableAliasProxyHandler;
exports.TableName = TableName;
exports.TransactionRollbackError = TransactionRollbackError;
exports.TypedQueryBuilder = TypedQueryBuilder;
exports.UniqueConstraint = UniqueConstraint;
exports.UniqueConstraintBuilder = UniqueConstraintBuilder;
exports.UniqueOnConstraintBuilder = UniqueOnConstraintBuilder;
exports.View = View;
exports.ViewBaseConfig = ViewBaseConfig;
exports.ViewBuilder = ViewBuilder;
exports.WithSubquery = WithSubquery;
exports.aliasedRelation = aliasedRelation;
exports.aliasedTable = aliasedTable;
exports.aliasedTableColumn = aliasedTableColumn;
exports.and = and;
exports.applyMixins = applyMixins;
exports.asc = asc;
exports.between = between;
exports.bigint = bigint;
exports.bigserial = bigserial;
exports.bindIfParam = bindIfParam;
exports.boolean = boolean;
exports.char = char;
exports.check = check;
exports.cidr = cidr;
exports.createMany = createMany;
exports.createOne = createOne;
exports.createTableRelationsHelpers = createTableRelationsHelpers;
exports.customType = customType;
exports.date = date;
exports.decimal = decimal;
exports.desc = desc;
exports.doublePrecision = doublePrecision;
exports.entityKind = entityKind;
exports.eq = eq;
exports.exists = exists;
exports.extractTablesRelationalConfig = extractTablesRelationalConfig;
exports.fillPlaceholders = fillPlaceholders;
exports.foreignKey = foreignKey;
exports.getMaterializedViewConfig = getMaterializedViewConfig;
exports.getTableColumns = getTableColumns;
exports.getTableConfig = getTableConfig;
exports.getTableLikeName = getTableLikeName;
exports.getTableName = getTableName;
exports.getViewConfig = getViewConfig;
exports.gt = gt;
exports.gte = gte;
exports.hasOwnEntityKind = hasOwnEntityKind;
exports.iife = iife;
exports.ilike = ilike;
exports.inArray = inArray;
exports.index = index;
exports.inet = inet;
exports.integer = integer;
exports.interval = interval;
exports.is = is;
exports.isDriverValueEncoder = isDriverValueEncoder;
exports.isNotNull = isNotNull;
exports.isNull = isNull;
exports.isPgEnum = isPgEnum;
exports.isPgSchema = isPgSchema;
exports.isSQLWrapper = isSQLWrapper;
exports.isTable = isTable;
exports.json = json;
exports.jsonb = jsonb;
exports.like = like;
exports.lt = lt;
exports.lte = lte;
exports.macaddr = macaddr;
exports.macaddr8 = macaddr8;
exports.makePgArray = makePgArray;
exports.mapColumnsInAliasedSQLToAlias = mapColumnsInAliasedSQLToAlias;
exports.mapColumnsInSQLToAlias = mapColumnsInSQLToAlias;
exports.mapRelationalRow = mapRelationalRow;
exports.mapResultRow = mapResultRow;
exports.mapUpdateSet = mapUpdateSet;
exports.name = name;
exports.ne = ne;
exports.noopDecoder = noopDecoder;
exports.noopEncoder = noopEncoder;
exports.noopMapper = noopMapper;
exports.normalizeRelation = normalizeRelation;
exports.not = not;
exports.notBetween = notBetween;
exports.notExists = notExists;
exports.notIlike = notIlike;
exports.notInArray = notInArray;
exports.notLike = notLike;
exports.numeric = numeric;
exports.operators = operators;
exports.or = or;
exports.orderByOperators = orderByOperators;
exports.orderSelectedFields = orderSelectedFields;
exports.param = param;
exports.parsePgArray = parsePgArray;
exports.parsePgNestedArray = parsePgNestedArray;
exports.pgEnum = pgEnum;
exports.pgMaterializedView = pgMaterializedView;
exports.pgMaterializedViewWithSchema = pgMaterializedViewWithSchema;
exports.pgSchema = pgSchema;
exports.pgTable = pgTable;
exports.pgTableCreator = pgTableCreator;
exports.pgTableWithSchema = pgTableWithSchema;
exports.pgView = pgView;
exports.pgViewWithSchema = pgViewWithSchema;
exports.placeholder = placeholder;
exports.primaryKey = primaryKey;
exports.real = real;
exports.relations = relations;
exports.serial = serial;
exports.smallint = smallint;
exports.smallserial = smallserial;
exports.sql = sql;
exports.text = text;
exports.time = time;
exports.timestamp = timestamp;
exports.tracer = tracer;
exports.unique = unique;
exports.uniqueIndex = uniqueIndex;
exports.uniqueKeyName = uniqueKeyName;
exports.uuid = uuid;
exports.varchar = varchar;
//# sourceMappingURL=alias-72a4082c.cjs.map
