'use strict';

var alias = require('./alias-72a4082c.cjs');

var _a$m, _b$j, _c$9;
/** @internal */
const InlineForeignKeys = Symbol.for('drizzle:SQLiteInlineForeignKeys');
class SQLiteTable extends alias.Table {
    constructor() {
        super(...arguments);
        /** @internal */
        this[_b$j] = [];
        /** @internal */
        this[_c$9] = undefined;
    }
}
_a$m = alias.entityKind, alias.Table.Symbol.Columns, _b$j = InlineForeignKeys, _c$9 = alias.Table.Symbol.ExtraConfigBuilder;
SQLiteTable[_a$m] = 'SQLiteTable';
/** @internal */
SQLiteTable.Symbol = Object.assign({}, alias.Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys,
});
function sqliteTableBase(name, columns, extraConfig, schema, baseName = name) {
    const rawTable = new SQLiteTable(name, schema, baseName);
    const builtColumns = Object.fromEntries(Object.entries(columns).map(([name, colBuilder]) => {
        const column = colBuilder.build(rawTable);
        rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
        return [name, column];
    }));
    const table = Object.assign(rawTable, builtColumns);
    table[alias.Table.Symbol.Columns] = builtColumns;
    if (extraConfig) {
        table[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
    }
    return table;
}
const sqliteTable = (name, columns, extraConfig) => {
    return sqliteTableBase(name, columns, extraConfig);
};
function sqliteTableCreator(customizeTableName) {
    return (name, columns, extraConfig) => {
        return sqliteTableBase(customizeTableName(name), columns, extraConfig, undefined, name);
    };
}

var _a$l;
class SQLiteDelete {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.run = (placeholderValues) => {
            return this.prepare(true).run(placeholderValues);
        };
        this.all = (placeholderValues) => {
            return this.prepare(true).all(placeholderValues);
        };
        this.get = (placeholderValues) => {
            return this.prepare(true).get(placeholderValues);
        };
        this.values = (placeholderValues) => {
            return this.prepare(true).values(placeholderValues);
        };
        this.config = { table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = alias.orderSelectedFields(fields);
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare(isOneTimeQuery) {
        return this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
    }
}
_a$l = alias.entityKind;
SQLiteDelete[_a$l] = 'SQLiteDelete';

var _a$k, _b$i;
class SQLiteInsertBuilder {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
            throw new Error('values() must be called with at least one value');
        }
        const mappedValues = values.map((entry) => {
            const result = {};
            const cols = this.table[alias.Table.Symbol.Columns];
            for (const colKey of Object.keys(entry)) {
                const colValue = entry[colKey];
                result[colKey] = alias.is(colValue, alias.SQL) ? colValue : new alias.Param(colValue, cols[colKey]);
            }
            return result;
        });
        return new SQLiteInsert(this.table, mappedValues, this.session, this.dialect);
    }
}
_a$k = alias.entityKind;
SQLiteInsertBuilder[_a$k] = 'SQLiteInsertBuilder';
class SQLiteInsert {
    constructor(table, values, session, dialect) {
        this.session = session;
        this.dialect = dialect;
        this.run = (placeholderValues) => {
            return this.prepare(true).run(placeholderValues);
        };
        this.all = (placeholderValues) => {
            return this.prepare(true).all(placeholderValues);
        };
        this.get = (placeholderValues) => {
            return this.prepare(true).get(placeholderValues);
        };
        this.values = (placeholderValues) => {
            return this.prepare(true).values(placeholderValues);
        };
        this.config = { table, values };
    }
    returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = alias.orderSelectedFields(fields);
        return this;
    }
    onConflictDoNothing(config = {}) {
        if (config.target === undefined) {
            this.config.onConflict = alias.sql `do nothing`;
        }
        else {
            const targetSql = Array.isArray(config.target) ? alias.sql `${config.target}` : alias.sql `${[config.target]}`;
            const whereSql = config.where ? alias.sql ` where ${config.where}` : alias.sql ``;
            this.config.onConflict = alias.sql `${targetSql}${whereSql} do nothing`;
        }
        return this;
    }
    onConflictDoUpdate(config) {
        const targetSql = Array.isArray(config.target) ? alias.sql `${config.target}` : alias.sql `${[config.target]}`;
        const whereSql = config.where ? alias.sql ` where ${config.where}` : alias.sql ``;
        const setSql = this.dialect.buildUpdateSet(this.config.table, alias.mapUpdateSet(this.config.table, config.set));
        this.config.onConflict = alias.sql `${targetSql}${whereSql} do update set ${setSql}`;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildInsertQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare(isOneTimeQuery) {
        return this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
    }
}
_b$i = alias.entityKind;
SQLiteInsert[_b$i] = 'SQLiteInsert';

var _a$j, _b$h, _c$8, _d$2, _e$2;
class ViewBuilderCore {
    constructor(name) {
        this.name = name;
        this.config = {};
    }
}
_a$j = alias.entityKind;
ViewBuilderCore[_a$j] = 'SQLiteViewBuilderCore';
class ViewBuilder extends ViewBuilderCore {
    as(qb) {
        if (typeof qb === 'function') {
            qb = qb(new QueryBuilder());
        }
        const selectionProxy = new alias.SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        });
        // const aliasedSelectedFields = new Proxy(qb.getSelectedFields(), selectionProxy);
        const aliasedSelectedFields = qb.getSelectedFields();
        return new Proxy(new SQLiteView({
            sqliteConfig: this.config,
            config: {
                name: this.name,
                schema: undefined,
                selectedFields: aliasedSelectedFields,
                query: qb.getSQL().inlineParams(),
            },
        }), selectionProxy);
    }
}
_b$h = alias.entityKind;
ViewBuilder[_b$h] = 'SQLiteViewBuilder';
class ManualViewBuilder extends ViewBuilderCore {
    constructor(name, columns) {
        super(name);
        this.columns = alias.getTableColumns(sqliteTable(name, columns));
    }
    existing() {
        return new Proxy(new SQLiteView({
            sqliteConfig: undefined,
            config: {
                name: this.name,
                schema: undefined,
                selectedFields: this.columns,
                query: undefined,
            },
        }), new alias.SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
    as(query) {
        return new Proxy(new SQLiteView({
            sqliteConfig: this.config,
            config: {
                name: this.name,
                schema: undefined,
                selectedFields: this.columns,
                query: query.inlineParams(),
            },
        }), new alias.SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
}
_c$8 = alias.entityKind;
ManualViewBuilder[_c$8] = 'SQLiteManualViewBuilder';
class SQLiteViewBase extends alias.View {
}
_d$2 = alias.entityKind;
SQLiteViewBase[_d$2] = 'SQLiteViewBase';
const SQLiteViewConfig = Symbol.for('drizzle:SQLiteViewConfig');
class SQLiteView extends SQLiteViewBase {
    constructor({ sqliteConfig, config }) {
        super(config);
        this[SQLiteViewConfig] = sqliteConfig;
    }
}
_e$2 = alias.entityKind;
SQLiteView[_e$2] = 'SQLiteView';
function sqliteView(name, selection) {
    if (selection) {
        return new ManualViewBuilder(name, selection);
    }
    return new ViewBuilder(name);
}
const view = sqliteView;

var _a$i, _b$g, _c$7;
class SQLiteDialect {
    escapeName(name) {
        return `"${name}"`;
    }
    escapeParam(_num) {
        return '?';
    }
    escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
    }
    buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning
            ? alias.sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? alias.sql ` where ${where}` : undefined;
        return alias.sql `delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
        const setEntries = Object.entries(set);
        const setSize = setEntries.length;
        return alias.sql.fromList(setEntries
            .flatMap(([colName, value], i) => {
            const col = table[alias.Table.Symbol.Columns][colName];
            const res = alias.sql `${alias.name(col.name)} = ${value}`;
            if (i < setSize - 1) {
                return [res, alias.sql.raw(', ')];
            }
            return [res];
        }));
    }
    buildUpdateQuery({ table, set, where, returning }) {
        const setSql = this.buildUpdateSet(table, set);
        const returningSql = returning
            ? alias.sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? alias.sql ` where ${where}` : undefined;
        return alias.sql `update ${table} set ${setSql}${whereSql}${returningSql}`;
    }
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields
            .flatMap(({ field }, i) => {
            const chunk = [];
            if (alias.is(field, alias.SQL.Aliased) && field.isSelectionField) {
                chunk.push(alias.sql.identifier(field.fieldAlias));
            }
            else if (alias.is(field, alias.SQL.Aliased) || alias.is(field, alias.SQL)) {
                const query = alias.is(field, alias.SQL.Aliased) ? field.sql : field;
                if (isSingleTable) {
                    chunk.push(new alias.SQL(query.queryChunks.map((c) => {
                        if (alias.is(c, alias.Column)) {
                            return alias.name(c.name);
                        }
                        return c;
                    })));
                }
                else {
                    chunk.push(query);
                }
                if (alias.is(field, alias.SQL.Aliased)) {
                    chunk.push(alias.sql ` as ${alias.name(field.fieldAlias)}`);
                }
            }
            else if (alias.is(field, alias.Column)) {
                const tableName = field.table[alias.Table.Symbol.Name];
                const columnName = field.name;
                if (isSingleTable) {
                    chunk.push(alias.name(columnName));
                }
                else {
                    chunk.push(alias.sql `${alias.name(tableName)}.${alias.name(columnName)}`);
                }
            }
            if (i < columnsLen - 1) {
                chunk.push(alias.sql `, `);
            }
            return chunk;
        });
        return alias.sql.fromList(chunks);
    }
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, distinct }) {
        const fieldsList = fieldsFlat ?? alias.orderSelectedFields(fields);
        for (const f of fieldsList) {
            if (alias.is(f.field, alias.Column)
                && alias.getTableName(f.field.table)
                    !== (alias.is(table, alias.Subquery)
                        ? table[alias.SubqueryConfig].alias
                        : alias.is(table, SQLiteViewBase)
                            ? table[alias.ViewBaseConfig].name
                            : alias.is(table, alias.SQL)
                                ? undefined
                                : alias.getTableName(table))
                && !((table) => joins.some(({ alias: alias$1 }) => alias$1 === (table[alias.Table.Symbol.IsAlias] ? alias.getTableName(table) : table[alias.Table.Symbol.BaseName])))(f.field.table)) {
                const tableName = alias.getTableName(f.field.table);
                throw new Error(`Your "${f.path.join('->')}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
            }
        }
        const isSingleTable = joins.length === 0;
        let withSql;
        if (withList?.length) {
            const withSqlChunks = [alias.sql `with `];
            for (const [i, w] of withList.entries()) {
                withSqlChunks.push(alias.sql `${alias.name(w[alias.SubqueryConfig].alias)} as (${w[alias.SubqueryConfig].sql})`);
                if (i < withList.length - 1) {
                    withSqlChunks.push(alias.sql `, `);
                }
            }
            withSqlChunks.push(alias.sql ` `);
            withSql = alias.sql.fromList(withSqlChunks);
        }
        const distinctSql = distinct ? alias.sql ` distinct` : undefined;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
            if (alias.is(table, alias.Table) && table[alias.Table.Symbol.OriginalName] !== table[alias.Table.Symbol.Name]) {
                return alias.sql `${alias.name(table[alias.Table.Symbol.OriginalName])} ${alias.name(table[alias.Table.Symbol.Name])}`;
            }
            return table;
        })();
        const joinsArray = [];
        for (const [index, joinMeta] of joins.entries()) {
            if (index === 0) {
                joinsArray.push(alias.sql ` `);
            }
            const table = joinMeta.table;
            if (alias.is(table, SQLiteTable)) {
                const tableName = table[SQLiteTable.Symbol.Name];
                const tableSchema = table[SQLiteTable.Symbol.Schema];
                const origTableName = table[SQLiteTable.Symbol.OriginalName];
                const alias$1 = tableName === origTableName ? undefined : joinMeta.alias;
                joinsArray.push(alias.sql `${alias.sql.raw(joinMeta.joinType)} join ${tableSchema ? alias.sql `${alias.sql.identifier(tableSchema)}.` : undefined}${alias.name(origTableName)}${alias$1 && alias.sql ` ${alias.name(alias$1)}`} on ${joinMeta.on}`);
            }
            else {
                joinsArray.push(alias.sql `${alias.sql.raw(joinMeta.joinType)} join ${table} on ${joinMeta.on}`);
            }
            if (index < joins.length - 1) {
                joinsArray.push(alias.sql ` `);
            }
        }
        const joinsSql = alias.sql.fromList(joinsArray);
        const whereSql = where ? alias.sql ` where ${where}` : undefined;
        const havingSql = having ? alias.sql ` having ${having}` : undefined;
        const orderByList = [];
        for (const [index, orderByValue] of orderBy.entries()) {
            orderByList.push(orderByValue);
            if (index < orderBy.length - 1) {
                orderByList.push(alias.sql `, `);
            }
        }
        const groupByList = [];
        for (const [index, groupByValue] of groupBy.entries()) {
            groupByList.push(groupByValue);
            if (index < groupBy.length - 1) {
                groupByList.push(alias.sql `, `);
            }
        }
        const groupBySql = groupByList.length > 0 ? alias.sql ` group by ${alias.sql.fromList(groupByList)}` : undefined;
        const orderBySql = orderByList.length > 0 ? alias.sql ` order by ${alias.sql.fromList(orderByList)}` : undefined;
        const limitSql = limit ? alias.sql ` limit ${limit}` : undefined;
        const offsetSql = offset ? alias.sql ` offset ${offset}` : undefined;
        return alias.sql `${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
    }
    buildInsertQuery({ table, values, onConflict, returning }) {
        const isSingleValue = values.length === 1;
        const valuesSqlList = [];
        const columns = table[alias.Table.Symbol.Columns];
        const colEntries = isSingleValue
            ? Object.keys(values[0]).map((fieldName) => [fieldName, columns[fieldName]])
            : Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => alias.name(column.name));
        for (const [valueIndex, value] of values.entries()) {
            const valueList = [];
            for (const [fieldName, col] of colEntries) {
                const colValue = value[fieldName];
                if (colValue === undefined || (alias.is(colValue, alias.Param) && colValue.value === undefined)) {
                    let defaultValue;
                    if (col.default !== null && col.default !== undefined) {
                        defaultValue = alias.is(col.default, alias.SQL) ? col.default : alias.param(col.default, col);
                    }
                    else {
                        defaultValue = alias.sql `null`;
                    }
                    valueList.push(defaultValue);
                }
                else {
                    valueList.push(colValue);
                }
            }
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
                valuesSqlList.push(alias.sql `, `);
            }
        }
        const valuesSql = alias.sql.fromList(valuesSqlList);
        const returningSql = returning
            ? alias.sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const onConflictSql = onConflict ? alias.sql ` on conflict ${onConflict}` : undefined;
        return alias.sql `insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
    }
    sqlToQuery(sql) {
        return sql.toQuery({
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
            escapeString: this.escapeString,
        });
    }
    buildRelationalQuery(fullSchema, schema, tableNamesMap, table, tableConfig, config, tableAlias, relationColumns, isRoot = false) {
        if (config === true) {
            const selectionEntries = Object.entries(tableConfig.columns);
            const selection = selectionEntries.map(([key, value]) => ({
                dbKey: value.name,
                tsKey: key,
                field: value,
                tableTsKey: undefined,
                isJson: false,
                selection: [],
            }));
            return {
                tableTsKey: tableConfig.tsName,
                sql: table,
                selection,
            };
        }
        const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, alias.aliasedTableColumn(value, tableAlias)]));
        const aliasedRelations = Object.fromEntries(Object.entries(tableConfig.relations).map(([key, value]) => [key, alias.aliasedRelation(value, tableAlias)]));
        const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
        const fieldsSelection = {};
        let selectedColumns = [];
        let selectedExtras = [];
        let selectedRelations = [];
        if (config.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config.columns)) {
                if (value === undefined) {
                    continue;
                }
                if (field in tableConfig.columns) {
                    if (!isIncludeMode && value === true) {
                        isIncludeMode = true;
                    }
                    selectedColumns.push(field);
                }
            }
            if (selectedColumns.length > 0) {
                selectedColumns = isIncludeMode
                    ? selectedColumns.filter((c) => config.columns?.[c] === true)
                    : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
            }
        }
        if (config.with) {
            selectedRelations = Object.entries(config.with)
                .filter((entry) => !!entry[1])
                .map(([key, value]) => ({ key, value }));
        }
        if (!config.columns) {
            selectedColumns = Object.keys(tableConfig.columns);
        }
        if (config.extras) {
            const extrasOrig = typeof config.extras === 'function'
                ? config.extras(aliasedFields, { sql: alias.sql })
                : config.extras;
            selectedExtras = Object.entries(extrasOrig).map(([key, value]) => ({
                key,
                value: alias.mapColumnsInAliasedSQLToAlias(value, tableAlias),
            }));
        }
        for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection[field] = column;
        }
        for (const { key, value } of selectedExtras) {
            fieldsSelection[key] = value;
        }
        let where;
        if (config.where) {
            const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, alias.operators) : config.where;
            where = whereSql && alias.mapColumnsInSQLToAlias(whereSql, tableAlias);
        }
        const groupBy = (tableConfig.primaryKey.length ? tableConfig.primaryKey : Object.values(tableConfig.columns)).map((c) => alias.aliasedTableColumn(c, tableAlias));
        let orderByOrig = typeof config.orderBy === 'function'
            ? config.orderBy(aliasedFields, alias.orderByOperators)
            : config.orderBy ?? [];
        if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
        }
        const orderBy = orderByOrig.map((orderByValue) => {
            if (alias.is(orderByValue, alias.Column)) {
                return alias.aliasedTableColumn(orderByValue, tableAlias);
            }
            return alias.mapColumnsInSQLToAlias(orderByValue, tableAlias);
        });
        const builtRelations = [];
        const builtRelationFields = [];
        let result;
        let selectedRelationIndex = 0;
        for (const { key: selectedRelationKey, value: selectedRelationValue } of selectedRelations) {
            let relation;
            for (const [relationKey, relationValue] of Object.entries(tableConfig.relations)) {
                if (alias.is(relationValue, alias.Relation) && relationKey === selectedRelationKey) {
                    relation = relationValue;
                    break;
                }
            }
            if (!relation) {
                throw new Error(`Relation ${selectedRelationKey} not found`);
            }
            const normalizedRelation = alias.normalizeRelation(schema, tableNamesMap, relation);
            const relationAlias = `${tableAlias}_${selectedRelationKey}`;
            const builtRelation = this.buildRelationalQuery(fullSchema, schema, tableNamesMap, fullSchema[tableNamesMap[relation.referencedTable[alias.Table.Symbol.Name]]], schema[tableNamesMap[relation.referencedTable[alias.Table.Symbol.Name]]], selectedRelationValue, relationAlias, normalizedRelation.references);
            builtRelations.push({ key: selectedRelationKey, value: builtRelation });
            let relationWhere;
            if (typeof selectedRelationValue === 'object' && selectedRelationValue.limit) {
                const field = alias.sql `${alias.sql.identifier(relationAlias)}.${alias.sql.identifier('__drizzle_row_number')}`;
                relationWhere = alias.and(relationWhere, alias.or(alias.and(alias.sql `${field} <= ${selectedRelationValue.limit}`), alias.sql `(${field} is null)`));
            }
            const join = {
                table: alias.is(builtRelation.sql, alias.Table)
                    ? alias.aliasedTable(builtRelation.sql, relationAlias)
                    : new alias.Subquery(builtRelation.sql, {}, relationAlias),
                alias: relationAlias,
                on: alias.and(...normalizedRelation.fields.map((field, i) => alias.eq(alias.aliasedTableColumn(field, tableAlias), alias.aliasedTableColumn(normalizedRelation.references[i], relationAlias)))),
                joinType: 'left',
            };
            const elseField = alias.sql `json_group_array(json_array(${alias.sql.join(builtRelation.selection.map(({ dbKey: key, isJson }) => {
                const field = alias.sql `${alias.sql.identifier(relationAlias)}.${alias.sql.identifier(key)}`;
                return isJson ? alias.sql `json(${field})` : field;
            }), alias.sql `, `)}))`;
            const countSql = normalizedRelation.references.length === 1
                ? alias.aliasedTableColumn(normalizedRelation.references[0], relationAlias)
                : alias.sql.fromList([
                    alias.sql `coalesce(`,
                    alias.sql.join(normalizedRelation.references.map((c) => alias.aliasedTableColumn(c, relationAlias)), alias.sql.raw(', ')),
                    alias.sql.raw(')'),
                ]);
            const field = alias.sql `case when count(${countSql}) = 0 then '[]' else ${elseField} end`.as(selectedRelationKey);
            const builtRelationField = {
                path: [selectedRelationKey],
                field,
            };
            result = this.buildSelectQuery({
                table: result ? new alias.Subquery(result, {}, tableAlias) : alias.aliasedTable(table, tableAlias),
                fields: {},
                fieldsFlat: [
                    {
                        path: [],
                        field: alias.sql `${alias.sql.identifier(tableAlias)}.*`,
                    },
                    ...(selectedRelationIndex === selectedRelations.length - 1
                        ? selectedExtras.map(({ key, value }) => ({
                            path: [key],
                            field: value,
                        }))
                        : []),
                    builtRelationField,
                ],
                where: relationWhere,
                groupBy,
                orderBy: selectedRelationIndex === selectedRelations.length - 1 ? orderBy : [],
                joins: [join],
            });
            builtRelationFields.push(builtRelationField);
            selectedRelationIndex++;
        }
        const finalFieldsSelection = Object.entries(fieldsSelection).map(([key, value]) => {
            return {
                path: [key],
                field: alias.is(value, alias.Column) ? alias.aliasedTableColumn(value, tableAlias) : value,
            };
        });
        const finalFieldsFlat = isRoot
            ? [
                ...finalFieldsSelection.map(({ path, field }) => ({
                    path,
                    field: alias.is(field, alias.SQL.Aliased) ? alias.sql `${alias.sql.identifier(field.fieldAlias)}` : field,
                })),
                ...builtRelationFields.map(({ path, field }) => ({
                    path,
                    field: alias.sql `json(${alias.sql.identifier(field.fieldAlias)})`,
                })),
            ]
            : [
                ...Object.entries(tableConfig.columns).map(([tsKey, column]) => ({
                    path: [tsKey],
                    field: alias.aliasedTableColumn(column, tableAlias),
                })),
                ...selectedExtras.map(({ key, value }) => ({
                    path: [key],
                    field: value,
                })),
                ...builtRelationFields.map(({ path, field }) => ({
                    path,
                    field: alias.sql `${alias.sql.identifier(tableAlias)}.${alias.sql.identifier(field.fieldAlias)}`,
                })),
            ];
        if (finalFieldsFlat.length === 0) {
            finalFieldsFlat.push({
                path: [],
                field: alias.sql.raw('1'),
            });
        }
        if (!isRoot && !config.limit && orderBy.length > 0) {
            finalFieldsFlat.push({
                path: ['__drizzle_row_number'],
                field: alias.sql `row_number() over(order by ${alias.sql.join(orderBy, alias.sql `, `)})`,
            });
        }
        let limit, offset;
        if (config.limit !== undefined || config.offset !== undefined) {
            if (isRoot) {
                limit = config.limit;
                offset = config.offset;
            }
            else {
                finalFieldsFlat.push({
                    path: ['__drizzle_row_number'],
                    field: alias.sql `row_number() over(partition by ${relationColumns.map((c) => alias.aliasedTableColumn(c, tableAlias))}${(orderBy.length > 0 && !isRoot) ? alias.sql ` order by ${alias.sql.join(orderBy, alias.sql `, `)}` : undefined})`
                        .as('__drizzle_row_number'),
                });
            }
        }
        result = this.buildSelectQuery({
            table: result ? new alias.Subquery(result, {}, tableAlias) : alias.aliasedTable(table, tableAlias),
            fields: {},
            fieldsFlat: finalFieldsFlat,
            where,
            groupBy: [],
            orderBy: isRoot ? orderBy : [],
            joins: [],
            limit,
            offset: offset,
        });
        return {
            tableTsKey: tableConfig.tsName,
            sql: result,
            selection: [
                ...finalFieldsSelection.map(({ path, field }) => ({
                    dbKey: alias.is(field, alias.SQL.Aliased) ? field.fieldAlias : tableConfig.columns[path[0]].name,
                    tsKey: path[0],
                    field,
                    tableTsKey: undefined,
                    isJson: false,
                    selection: [],
                })),
                ...builtRelations.map(({ key, value }) => ({
                    dbKey: key,
                    tsKey: key,
                    field: undefined,
                    tableTsKey: value.tableTsKey,
                    isJson: true,
                    selection: value.selection,
                })),
            ],
        };
    }
}
_a$i = alias.entityKind;
SQLiteDialect[_a$i] = 'SQLiteDialect';
class SQLiteSyncDialect extends SQLiteDialect {
    migrate(migrations, session) {
        const migrationTableCreate = alias.sql `
			CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        session.run(migrationTableCreate);
        const dbMigrations = session.values(alias.sql `SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
        const lastDbMigration = dbMigrations[0] ?? undefined;
        session.run(alias.sql `BEGIN`);
        try {
            for (const migration of migrations) {
                if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
                    for (const stmt of migration.sql) {
                        session.run(alias.sql.raw(stmt));
                    }
                    session.run(alias.sql `INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
                }
            }
            session.run(alias.sql `COMMIT`);
        }
        catch (e) {
            session.run(alias.sql `ROLLBACK`);
            throw e;
        }
    }
}
_b$g = alias.entityKind;
SQLiteSyncDialect[_b$g] = 'SQLiteSyncDialect';
class SQLiteAsyncDialect extends SQLiteDialect {
    async migrate(migrations, session) {
        const migrationTableCreate = alias.sql `
			CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        await session.run(migrationTableCreate);
        const dbMigrations = await session.values(alias.sql `SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
        const lastDbMigration = dbMigrations[0] ?? undefined;
        await session.transaction(async (tx) => {
            for (const migration of migrations) {
                if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
                    for (const stmt of migration.sql) {
                        await tx.run(alias.sql.raw(stmt));
                    }
                    await tx.run(alias.sql `INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
                }
            }
        });
    }
}
_c$7 = alias.entityKind;
SQLiteAsyncDialect[_c$7] = 'SQLiteAsyncDialect';

var _a$h, _b$f, _c$6;
class SQLiteSelectBuilder {
    constructor(config) {
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        this.withList = config.withList;
        this.distinct = config.distinct;
    }
    from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
            fields = this.fields;
        }
        else if (alias.is(source, alias.Subquery)) {
            // This is required to use the proxy handler to get the correct field values from the subquery
            fields = Object.fromEntries(Object.keys(source[alias.SubqueryConfig].selection).map((key) => [key, source[key]]));
        }
        else if (alias.is(source, SQLiteViewBase)) {
            fields = source[alias.ViewBaseConfig].selectedFields;
        }
        else if (alias.is(source, alias.SQL)) {
            fields = {};
        }
        else {
            fields = alias.getTableColumns(source);
        }
        return new SQLiteSelect({
            table: source,
            fields,
            isPartialSelect,
            session: this.session,
            dialect: this.dialect,
            withList: this.withList,
            distinct: this.distinct,
        });
    }
}
_a$h = alias.entityKind;
SQLiteSelectBuilder[_a$h] = 'SQLiteSelectBuilder';
class SQLiteSelectQueryBuilder extends alias.TypedQueryBuilder {
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.leftJoin = this.createJoin('left');
        this.rightJoin = this.createJoin('right');
        this.innerJoin = this.createJoin('inner');
        this.fullJoin = this.createJoin('full');
        this.config = {
            withList,
            table,
            fields: { ...fields },
            joins: [],
            orderBy: [],
            groupBy: [],
            distinct,
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
            selectedFields: fields,
        };
        this.tableName = alias.getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};
    }
    createJoin(joinType) {
        return (table, on) => {
            const baseTableName = this.tableName;
            const tableName = alias.getTableLikeName(table);
            if (typeof tableName === 'string' && this.config.joins.some((join) => join.alias === tableName)) {
                throw new Error(`Alias "${tableName}" is already used in this query`);
            }
            if (!this.isPartialSelect) {
                // If this is the first join and this is not a partial select and we're not selecting from raw SQL, "move" the fields from the main table to the nested object
                if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {
                    this.config.fields = {
                        [baseTableName]: this.config.fields,
                    };
                }
                if (typeof tableName === 'string' && !alias.is(table, alias.SQL)) {
                    const selection = alias.is(table, alias.Subquery)
                        ? table[alias.SubqueryConfig].selection
                        : alias.is(table, alias.View)
                            ? table[alias.ViewBaseConfig].selectedFields
                            : table[alias.Table.Symbol.Columns];
                    this.config.fields[tableName] = selection;
                }
            }
            if (typeof on === 'function') {
                on = on(new Proxy(this.config.fields, new alias.SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
            }
            this.config.joins.push({ on, table, joinType, alias: tableName });
            if (typeof tableName === 'string') {
                switch (joinType) {
                    case 'left': {
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                    case 'right': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'inner': {
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'full': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                }
            }
            return this;
        };
    }
    where(where) {
        if (typeof where === 'function') {
            where = where(new Proxy(this.config.fields, new alias.SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.where = where;
        return this;
    }
    having(having) {
        if (typeof having === 'function') {
            having = having(new Proxy(this.config.fields, new alias.SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.having = having;
        return this;
    }
    groupBy(...columns) {
        if (typeof columns[0] === 'function') {
            const groupBy = columns[0](new Proxy(this.config.fields, new alias.SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        }
        else {
            this.config.groupBy = columns;
        }
        return this;
    }
    orderBy(...columns) {
        if (typeof columns[0] === 'function') {
            const orderBy = columns[0](new Proxy(this.config.fields, new alias.SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
        }
        else {
            this.config.orderBy = columns;
        }
        return this;
    }
    limit(limit) {
        this.config.limit = limit;
        return this;
    }
    offset(offset) {
        this.config.offset = offset;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildSelectQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    as(alias$1) {
        return new Proxy(new alias.Subquery(this.getSQL(), this.config.fields, alias$1), new alias.SelectionProxyHandler({ alias: alias$1, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
    }
    getSelectedFields() {
        return new Proxy(this.config.fields, new alias.SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
    }
}
_b$f = alias.entityKind;
SQLiteSelectQueryBuilder[_b$f] = 'SQLiteSelectQueryBuilder';
class SQLiteSelect extends SQLiteSelectQueryBuilder {
    constructor() {
        super(...arguments);
        this.run = (placeholderValues) => {
            return this.prepare(true).run(placeholderValues);
        };
        this.all = (placeholderValues) => {
            return this.prepare(true).all(placeholderValues);
        };
        this.get = (placeholderValues) => {
            return this.prepare(true).get(placeholderValues);
        };
        this.values = (placeholderValues) => {
            return this.prepare(true).values(placeholderValues);
        };
    }
    prepare(isOneTimeQuery) {
        if (!this.session) {
            throw new Error('Cannot execute a query on a query builder. Please use a database instance instead.');
        }
        const fieldsList = alias.orderSelectedFields(this.config.fields);
        const query = this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), fieldsList);
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
    }
}
_c$6 = alias.entityKind;
SQLiteSelect[_c$6] = 'SQLiteSelect';

var _a$g;
class QueryBuilder {
    $with(alias$1) {
        const queryBuilder = this;
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(queryBuilder);
                }
                return new Proxy(new alias.WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias$1, true), new alias.SelectionProxyHandler({ alias: alias$1, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
                distinct: true,
            });
        }
        return { select, selectDistinct };
    }
    select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: undefined, dialect: this.getDialect() });
    }
    selectDistinct(fields) {
        return new SQLiteSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
            distinct: true,
        });
    }
    // Lazy load dialect to avoid circular dependency
    getDialect() {
        if (!this.dialect) {
            this.dialect = new SQLiteSyncDialect();
        }
        return this.dialect;
    }
}
_a$g = alias.entityKind;
QueryBuilder[_a$g] = 'SQLiteQueryBuilder';

var _a$f, _b$e;
class SQLiteUpdateBuilder {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    set(values) {
        return new SQLiteUpdate(this.table, alias.mapUpdateSet(this.table, values), this.session, this.dialect);
    }
}
_a$f = alias.entityKind;
SQLiteUpdateBuilder[_a$f] = 'SQLiteUpdateBuilder';
class SQLiteUpdate {
    constructor(table, set, session, dialect) {
        this.session = session;
        this.dialect = dialect;
        this.run = (placeholderValues) => {
            return this.prepare(true).run(placeholderValues);
        };
        this.all = (placeholderValues) => {
            return this.prepare(true).all(placeholderValues);
        };
        this.get = (placeholderValues) => {
            return this.prepare(true).get(placeholderValues);
        };
        this.values = (placeholderValues) => {
            return this.prepare(true).values(placeholderValues);
        };
        this.config = { set, table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = alias.orderSelectedFields(fields);
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare(isOneTimeQuery) {
        return this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
    }
}
_b$e = alias.entityKind;
SQLiteUpdate[_b$e] = 'SQLiteUpdate';

var _a$e, _b$d, _c$5;
class AsyncRelationalQueryBuilder {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
    }
    findMany(config) {
        return new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, 'many');
    }
    findFirst(config) {
        return new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, 'first');
    }
}
_a$e = alias.entityKind;
AsyncRelationalQueryBuilder[_a$e] = 'SQLiteAsyncRelationalQueryBuilder';
class SyncRelationalQueryBuilder {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
    }
    prepareFindMany(config) {
        const query = new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, 'many').prepare();
        return {
            execute: query.all.bind(query),
        };
    }
    findMany(config) {
        return this.prepareFindMany(config).execute();
    }
    prepareFindFirst(config) {
        const query = new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, 'first').prepare();
        return {
            execute: query.get.bind(query),
        };
    }
    findFirst(config) {
        return this.prepareFindFirst(config).execute();
    }
}
_b$d = alias.entityKind;
SyncRelationalQueryBuilder[_b$d] = 'SQLiteSyncRelationalQueryBuilder';
class SQLiteRelationalQuery {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config;
        this.mode = mode;
    }
    prepare() {
        const query = this.dialect.buildRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.config, this.tableConfig.tsName, [], true);
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return this.session.prepareQuery(builtQuery, undefined, (rawRows, mapColumnValue) => {
            const rows = rawRows.map((row) => alias.mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
            if (this.mode === 'first') {
                return rows[0];
            }
            return rows;
        });
    }
    execute() {
        if (this.mode === 'first') {
            return this.prepare().get();
        }
        return this.prepare().all();
    }
}
_c$5 = alias.entityKind;
SQLiteRelationalQuery[_c$5] = 'SQLiteRelationalQuery';
alias.applyMixins(SQLiteRelationalQuery, [alias.QueryPromise]);

var _a$d;
class BaseSQLiteDatabase {
    constructor(resultKind, 
    /** @internal */
    dialect, 
    /** @internal */
    session, schema) {
        this.dialect = dialect;
        this.session = session;
        this._ = schema
            ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap }
            : { schema: undefined, tableNamesMap: {} };
        this.query = {};
        if (this._.schema) {
            for (const [tableName, columns] of Object.entries(this._.schema)) {
                this.query[tableName] =
                    new (resultKind === 'async' ? AsyncRelationalQueryBuilder : SyncRelationalQueryBuilder)(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
            }
        }
    }
    $with(alias$1) {
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(new QueryBuilder());
                }
                return new Proxy(new alias.WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias$1, true), new alias.SelectionProxyHandler({ alias: alias$1, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
                distinct: true,
            });
        }
        return { select, selectDistinct };
    }
    select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: this.session, dialect: this.dialect });
    }
    selectDistinct(fields) {
        return new SQLiteSelectBuilder({
            fields: fields ?? undefined,
            session: this.session,
            dialect: this.dialect,
            distinct: true,
        });
    }
    update(table) {
        return new SQLiteUpdateBuilder(table, this.session, this.dialect);
    }
    insert(into) {
        return new SQLiteInsertBuilder(into, this.session, this.dialect);
    }
    delete(from) {
        return new SQLiteDelete(from, this.session, this.dialect);
    }
    run(query) {
        return this.session.run(query.getSQL());
    }
    all(query) {
        return this.session.all(query.getSQL());
    }
    get(query) {
        return this.session.get(query.getSQL());
    }
    values(query) {
        return this.session.values(query.getSQL());
    }
    transaction(transaction, config) {
        return this.session.transaction(transaction, config);
    }
}
_a$d = alias.entityKind;
BaseSQLiteDatabase[_a$d] = 'BaseSQLiteDatabase';

var _a$c, _b$c;
class CheckBuilder {
    constructor(name, value) {
        this.name = name;
        this.value = value;
    }
    build(table) {
        return new Check(table, this);
    }
}
_a$c = alias.entityKind;
CheckBuilder[_a$c] = 'SQLiteCheckBuilder';
class Check {
    constructor(table, builder) {
        this.table = table;
        this.name = builder.name;
        this.value = builder.value;
    }
}
_b$c = alias.entityKind;
Check[_b$c] = 'SQLiteCheck';
function check(name, value) {
    return new CheckBuilder(name, value);
}

var _a$b, _b$b;
class ForeignKeyBuilder {
    constructor(config, actions) {
        this.reference = () => {
            const { columns, foreignColumns } = config();
            return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
            this._onUpdate = actions.onUpdate;
            this._onDelete = actions.onDelete;
        }
    }
    onUpdate(action) {
        this._onUpdate = action;
        return this;
    }
    onDelete(action) {
        this._onDelete = action;
        return this;
    }
    /** @internal */
    build(table) {
        return new ForeignKey(table, this);
    }
}
_a$b = alias.entityKind;
ForeignKeyBuilder[_a$b] = 'SQLiteForeignKeyBuilder';
class ForeignKey {
    constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
    }
    getName() {
        const { columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
            this.table[SQLiteTable.Symbol.Name],
            ...columnNames,
            foreignColumns[0].table[SQLiteTable.Symbol.Name],
            ...foreignColumnNames,
        ];
        return `${chunks.join('_')}_fk`;
    }
}
_b$b = alias.entityKind;
ForeignKey[_b$b] = 'SQLiteForeignKey';
function foreignKey(config) {
    function mappedConfig() {
        const { columns, foreignColumns } = config();
        return {
            columns,
            foreignColumns,
        };
    }
    return new ForeignKeyBuilder(mappedConfig);
}

var _a$a, _b$a, _c$4;
function uniqueKeyName(table, columns) {
    return `${table[SQLiteTable.Symbol.Name]}_${columns.join('_')}_unique`;
}
function unique(name) {
    return new UniqueOnConstraintBuilder(name);
}
class UniqueConstraintBuilder {
    constructor(columns, name) {
        this.name = name;
        this.columns = columns;
    }
    /** @internal */
    build(table) {
        return new UniqueConstraint(table, this.columns, this.name);
    }
}
_a$a = alias.entityKind;
UniqueConstraintBuilder[_a$a] = 'SQLiteUniqueConstraintBuilder';
class UniqueOnConstraintBuilder {
    constructor(name) {
        this.name = name;
    }
    on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
    }
}
_b$a = alias.entityKind;
UniqueOnConstraintBuilder[_b$a] = 'SQLiteUniqueOnConstraintBuilder';
class UniqueConstraint {
    constructor(table, columns, name) {
        this.table = table;
        this.columns = columns;
        this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    }
    getName() {
        return this.name;
    }
}
_c$4 = alias.entityKind;
UniqueConstraint[_c$4] = 'SQLiteUniqueConstraint';

var _a$9, _b$9;
class SQLiteColumnBuilder extends alias.ColumnBuilder {
    constructor() {
        super(...arguments);
        this.foreignKeyConfigs = [];
    }
    references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
    }
    unique(name) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        return this;
    }
    /** @internal */
    buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
            return ((ref, actions) => {
                const builder = new ForeignKeyBuilder(() => {
                    const foreignColumn = ref();
                    return { columns: [column], foreignColumns: [foreignColumn] };
                });
                if (actions.onUpdate) {
                    builder.onUpdate(actions.onUpdate);
                }
                if (actions.onDelete) {
                    builder.onDelete(actions.onDelete);
                }
                return builder.build(table);
            })(ref, actions);
        });
    }
}
_a$9 = alias.entityKind;
SQLiteColumnBuilder[_a$9] = 'SQLiteColumnBuilder';
// To understand how to use `SQLiteColumn` and `AnySQLiteColumn`, see `Column` and `AnyColumn` documentation.
class SQLiteColumn extends alias.Column {
    constructor(table, config) {
        if (!config.uniqueName) {
            config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        this.table = table;
    }
}
_b$9 = alias.entityKind;
SQLiteColumn[_b$9] = 'SQLiteColumn';

var _a$8, _b$8, _c$3, _d$1, _e$1, _f$1;
class SQLiteBigIntBuilder extends SQLiteColumnBuilder {
    /** @internal */
    build(table) {
        return new SQLiteBigInt(table, this.config);
    }
}
_a$8 = alias.entityKind;
SQLiteBigIntBuilder[_a$8] = 'SQLiteBigIntBuilder';
class SQLiteBigInt extends SQLiteColumn {
    getSQLType() {
        return 'blob';
    }
    mapFromDriverValue(value) {
        return BigInt(value.toString());
    }
    mapToDriverValue(value) {
        return Buffer.from(value.toString());
    }
}
_b$8 = alias.entityKind;
SQLiteBigInt[_b$8] = 'SQLiteBigInt';
class SQLiteBlobJsonBuilder extends SQLiteColumnBuilder {
    /** @internal */
    build(table) {
        return new SQLiteBlobJson(table, this.config);
    }
}
_c$3 = alias.entityKind;
SQLiteBlobJsonBuilder[_c$3] = 'SQLiteBlobJsonBuilder';
class SQLiteBlobJson extends SQLiteColumn {
    getSQLType() {
        return 'blob';
    }
    mapFromDriverValue(value) {
        return JSON.parse(value.toString());
    }
    mapToDriverValue(value) {
        return Buffer.from(JSON.stringify(value));
    }
}
_d$1 = alias.entityKind;
SQLiteBlobJson[_d$1] = 'SQLiteBlobJson';
class SQLiteBlobBufferBuilder extends SQLiteColumnBuilder {
    /** @internal */
    build(table) {
        return new SQLiteBlobBuffer(table, this.config);
    }
}
_e$1 = alias.entityKind;
SQLiteBlobBufferBuilder[_e$1] = 'SQLiteBlobBufferBuilder';
class SQLiteBlobBuffer extends SQLiteColumn {
    getSQLType() {
        return 'blob';
    }
}
_f$1 = alias.entityKind;
SQLiteBlobBuffer[_f$1] = 'SQLiteBlobBuffer';
function blob(name, config) {
    if (config?.mode === 'json') {
        return new SQLiteBlobJsonBuilder(name);
    }
    if (config?.mode === 'bigint') {
        return new SQLiteBigIntBuilder(name);
    }
    return new SQLiteBlobBufferBuilder(name);
}

var _a$7, _b$7;
class SQLiteCustomColumnBuilder extends SQLiteColumnBuilder {
    constructor(name, fieldConfig, customTypeParams) {
        super(name);
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
    }
    /** @internal */
    build(table) {
        return new SQLiteCustomColumn(table, this.config);
    }
}
_a$7 = alias.entityKind;
SQLiteCustomColumnBuilder[_a$7] = 'SQLiteCustomColumnBuilder';
class SQLiteCustomColumn extends SQLiteColumn {
    constructor(table, config) {
        super(table, config);
        this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
        this.mapTo = config.customTypeParams.toDriver;
        this.mapFrom = config.customTypeParams.fromDriver;
    }
    getSQLType() {
        return this.sqlName;
    }
    mapFromDriverValue(value) {
        return typeof this.mapFrom === 'function' ? this.mapFrom(value) : value;
    }
    mapToDriverValue(value) {
        return typeof this.mapTo === 'function' ? this.mapTo(value) : value;
    }
}
_b$7 = alias.entityKind;
SQLiteCustomColumn[_b$7] = 'SQLiteCustomColumn';
/**
 * Custom sqlite database data type generator
 */
function customType(customTypeParams) {
    return (dbName, fieldConfig) => {
        return new SQLiteCustomColumnBuilder(dbName, fieldConfig, customTypeParams);
    };
}

var _a$6, _b$6, _c$2, _d, _e, _f, _g, _h;
class SQLiteBaseIntegerBuilder extends SQLiteColumnBuilder {
    constructor(name) {
        super(name);
        this.config.autoIncrement = false;
    }
    primaryKey(config) {
        if (config?.autoIncrement) {
            this.config.autoIncrement = true;
        }
        this.config.hasDefault = true;
        return super.primaryKey();
    }
}
_a$6 = alias.entityKind;
SQLiteBaseIntegerBuilder[_a$6] = 'SQLiteBaseIntegerBuilder';
class SQLiteBaseInteger extends SQLiteColumn {
    constructor() {
        super(...arguments);
        this.autoIncrement = this.config.autoIncrement;
    }
    getSQLType() {
        return 'integer';
    }
}
_b$6 = alias.entityKind;
SQLiteBaseInteger[_b$6] = 'SQLiteBaseInteger';
class SQLiteIntegerBuilder extends SQLiteBaseIntegerBuilder {
    build(table) {
        return new SQLiteInteger(table, this.config);
    }
}
_c$2 = alias.entityKind;
SQLiteIntegerBuilder[_c$2] = 'SQLiteIntegerBuilder';
class SQLiteInteger extends SQLiteBaseInteger {
}
_d = alias.entityKind;
SQLiteInteger[_d] = 'SQLiteInteger';
class SQLiteTimestampBuilder extends SQLiteBaseIntegerBuilder {
    constructor(name, mode) {
        super(name);
        this.config.mode = mode;
    }
    /**
     * @deprecated Use `default()` with your own expression instead.
     *
     * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
     */
    defaultNow() {
        return this.default(alias.sql `(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
    }
    build(table) {
        return new SQLiteTimestamp(table, this.config);
    }
}
_e = alias.entityKind;
SQLiteTimestampBuilder[_e] = 'SQLiteTimestampBuilder';
class SQLiteTimestamp extends SQLiteBaseInteger {
    constructor() {
        super(...arguments);
        this.mode = this.config.mode;
    }
    mapFromDriverValue(value) {
        if (this.config.mode === 'timestamp') {
            return new Date(value * 1000);
        }
        return new Date(value);
    }
    mapToDriverValue(value) {
        const unix = value.getTime();
        if (this.config.mode === 'timestamp') {
            return Math.floor(unix / 1000);
        }
        return unix;
    }
}
_f = alias.entityKind;
SQLiteTimestamp[_f] = 'SQLiteTimestamp';
class SQLiteBooleanBuilder extends SQLiteBaseIntegerBuilder {
    constructor(name, mode) {
        super(name);
        this.config.mode = mode;
    }
    build(table) {
        return new SQLiteBoolean(table, this.config);
    }
}
_g = alias.entityKind;
SQLiteBooleanBuilder[_g] = 'SQLiteBooleanBuilder';
class SQLiteBoolean extends SQLiteBaseInteger {
    constructor() {
        super(...arguments);
        this.mode = this.config.mode;
    }
    mapFromDriverValue(value) {
        return Number(value) === 1;
    }
    mapToDriverValue(value) {
        return value ? 1 : 0;
    }
}
_h = alias.entityKind;
SQLiteBoolean[_h] = 'SQLiteBoolean';
function integer(name, config) {
    if (config?.mode === 'timestamp' || config?.mode === 'timestamp_ms') {
        return new SQLiteTimestampBuilder(name, config.mode);
    }
    if (config?.mode === 'boolean') {
        return new SQLiteBooleanBuilder(name, config.mode);
    }
    return new SQLiteIntegerBuilder(name);
}
const int = integer;

var _a$5, _b$5;
class SQLiteNumericBuilder extends SQLiteColumnBuilder {
    /** @internal */
    build(table) {
        return new SQLiteNumeric(table, this.config);
    }
}
_a$5 = alias.entityKind;
SQLiteNumericBuilder[_a$5] = 'SQLiteNumericBuilder';
class SQLiteNumeric extends SQLiteColumn {
    getSQLType() {
        return 'numeric';
    }
}
_b$5 = alias.entityKind;
SQLiteNumeric[_b$5] = 'SQLiteNumeric';
function numeric(name) {
    return new SQLiteNumericBuilder(name);
}

var _a$4, _b$4;
class SQLiteRealBuilder extends SQLiteColumnBuilder {
    /** @internal */
    build(table) {
        return new SQLiteReal(table, this.config);
    }
}
_a$4 = alias.entityKind;
SQLiteRealBuilder[_a$4] = 'SQLiteRealBuilder';
class SQLiteReal extends SQLiteColumn {
    getSQLType() {
        return 'real';
    }
}
_b$4 = alias.entityKind;
SQLiteReal[_b$4] = 'SQLiteReal';
function real(name) {
    return new SQLiteRealBuilder(name);
}

var _a$3, _b$3;
class SQLiteTextBuilder extends SQLiteColumnBuilder {
    constructor(name, config) {
        super(name);
        this.config.enumValues = (config.enum ?? []);
        this.config.length = config.length;
    }
    /** @internal */
    build(table) {
        return new SQLiteText(table, this.config);
    }
}
_a$3 = alias.entityKind;
SQLiteTextBuilder[_a$3] = 'SQLiteTextBuilder';
class SQLiteText extends SQLiteColumn {
    constructor(table, config) {
        super(table, config);
        this.enumValues = this.config.enumValues;
        this.length = this.config.length;
    }
    getSQLType() {
        return `text${this.config.length ? `(${this.config.length})` : ''}`;
    }
}
_b$3 = alias.entityKind;
SQLiteText[_b$3] = 'SQLiteText';
function text(name, config = {}) {
    return new SQLiteTextBuilder(name, config);
}

var _a$2, _b$2, _c$1;
class IndexBuilderOn {
    constructor(name, unique) {
        this.name = name;
        this.unique = unique;
    }
    on(...columns) {
        return new IndexBuilder(this.name, columns, this.unique);
    }
}
_a$2 = alias.entityKind;
IndexBuilderOn[_a$2] = 'SQLiteIndexBuilderOn';
class IndexBuilder {
    constructor(name, columns, unique) {
        this.config = {
            name,
            columns,
            unique,
            where: undefined,
        };
    }
    /**
     * Condition for partial index.
     */
    where(condition) {
        this.config.where = condition;
        return this;
    }
    /** @internal */
    build(table) {
        return new Index(this.config, table);
    }
}
_b$2 = alias.entityKind;
IndexBuilder[_b$2] = 'SQLiteIndexBuilder';
class Index {
    constructor(config, table) {
        this.config = { ...config, table };
    }
}
_c$1 = alias.entityKind;
Index[_c$1] = 'SQLiteIndex';
function index(name) {
    return new IndexBuilderOn(name, false);
}
function uniqueIndex(name) {
    return new IndexBuilderOn(name, true);
}

var _a$1, _b$1;
function primaryKey(...columns) {
    return new PrimaryKeyBuilder(columns);
}
class PrimaryKeyBuilder {
    constructor(columns) {
        this.columns = columns;
    }
    /** @internal */
    build(table) {
        return new PrimaryKey(table, this.columns);
    }
}
_a$1 = alias.entityKind;
PrimaryKeyBuilder[_a$1] = 'SQLitePrimaryKeyBuilder';
class PrimaryKey {
    constructor(table, columns) {
        this.table = table;
        this.columns = columns;
    }
    getName() {
        return `${this.table[SQLiteTable.Symbol.Name]}_${this.columns.map((column) => column.name).join('_')}_pk`;
    }
}
_b$1 = alias.entityKind;
PrimaryKey[_b$1] = 'SQLitePrimaryKey';

var _a, _b, _c;
let PreparedQuery$1 = class PreparedQuery {
};
_a = alias.entityKind;
PreparedQuery$1[_a] = 'PreparedQuery';
class SQLiteSession {
    constructor(
    /** @internal */
    dialect) {
        this.dialect = dialect;
    }
    prepareOneTimeQuery(query, fields) {
        return this.prepareQuery(query, fields);
    }
    run(query) {
        const staticQuery = this.dialect.sqlToQuery(query);
        try {
            return this.prepareOneTimeQuery(staticQuery, undefined).run();
        }
        catch (err) {
            throw alias.DrizzleError.wrap(err, `Failed to run the query '${staticQuery.sql}'`);
        }
    }
    all(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined).all();
    }
    get(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined).get();
    }
    values(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined).values();
    }
}
_b = alias.entityKind;
SQLiteSession[_b] = 'SQLiteSession';
class SQLiteTransaction extends BaseSQLiteDatabase {
    constructor(resultType, dialect, session, schema, nestedIndex = 0) {
        super(resultType, dialect, session, schema);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
    }
    rollback() {
        throw new alias.TransactionRollbackError();
    }
}
_c = alias.entityKind;
SQLiteTransaction[_c] = 'SQLiteTransaction';

exports.BaseSQLiteDatabase = BaseSQLiteDatabase;
exports.Check = Check;
exports.CheckBuilder = CheckBuilder;
exports.ForeignKey = ForeignKey;
exports.ForeignKeyBuilder = ForeignKeyBuilder;
exports.Index = Index;
exports.IndexBuilder = IndexBuilder;
exports.IndexBuilderOn = IndexBuilderOn;
exports.InlineForeignKeys = InlineForeignKeys;
exports.ManualViewBuilder = ManualViewBuilder;
exports.PreparedQuery = PreparedQuery$1;
exports.PrimaryKey = PrimaryKey;
exports.PrimaryKeyBuilder = PrimaryKeyBuilder;
exports.QueryBuilder = QueryBuilder;
exports.SQLiteAsyncDialect = SQLiteAsyncDialect;
exports.SQLiteBaseInteger = SQLiteBaseInteger;
exports.SQLiteBaseIntegerBuilder = SQLiteBaseIntegerBuilder;
exports.SQLiteBigInt = SQLiteBigInt;
exports.SQLiteBigIntBuilder = SQLiteBigIntBuilder;
exports.SQLiteBlobBuffer = SQLiteBlobBuffer;
exports.SQLiteBlobBufferBuilder = SQLiteBlobBufferBuilder;
exports.SQLiteBlobJson = SQLiteBlobJson;
exports.SQLiteBlobJsonBuilder = SQLiteBlobJsonBuilder;
exports.SQLiteBoolean = SQLiteBoolean;
exports.SQLiteBooleanBuilder = SQLiteBooleanBuilder;
exports.SQLiteColumn = SQLiteColumn;
exports.SQLiteColumnBuilder = SQLiteColumnBuilder;
exports.SQLiteCustomColumn = SQLiteCustomColumn;
exports.SQLiteCustomColumnBuilder = SQLiteCustomColumnBuilder;
exports.SQLiteDelete = SQLiteDelete;
exports.SQLiteDialect = SQLiteDialect;
exports.SQLiteInsert = SQLiteInsert;
exports.SQLiteInsertBuilder = SQLiteInsertBuilder;
exports.SQLiteInteger = SQLiteInteger;
exports.SQLiteIntegerBuilder = SQLiteIntegerBuilder;
exports.SQLiteNumeric = SQLiteNumeric;
exports.SQLiteNumericBuilder = SQLiteNumericBuilder;
exports.SQLiteReal = SQLiteReal;
exports.SQLiteRealBuilder = SQLiteRealBuilder;
exports.SQLiteSelect = SQLiteSelect;
exports.SQLiteSelectBuilder = SQLiteSelectBuilder;
exports.SQLiteSelectQueryBuilder = SQLiteSelectQueryBuilder;
exports.SQLiteSession = SQLiteSession;
exports.SQLiteSyncDialect = SQLiteSyncDialect;
exports.SQLiteTable = SQLiteTable;
exports.SQLiteText = SQLiteText;
exports.SQLiteTextBuilder = SQLiteTextBuilder;
exports.SQLiteTimestamp = SQLiteTimestamp;
exports.SQLiteTimestampBuilder = SQLiteTimestampBuilder;
exports.SQLiteTransaction = SQLiteTransaction;
exports.SQLiteUpdate = SQLiteUpdate;
exports.SQLiteUpdateBuilder = SQLiteUpdateBuilder;
exports.SQLiteView = SQLiteView;
exports.SQLiteViewBase = SQLiteViewBase;
exports.SQLiteViewConfig = SQLiteViewConfig;
exports.UniqueConstraint = UniqueConstraint;
exports.UniqueConstraintBuilder = UniqueConstraintBuilder;
exports.UniqueOnConstraintBuilder = UniqueOnConstraintBuilder;
exports.ViewBuilder = ViewBuilder;
exports.ViewBuilderCore = ViewBuilderCore;
exports.blob = blob;
exports.check = check;
exports.customType = customType;
exports.foreignKey = foreignKey;
exports.index = index;
exports.int = int;
exports.integer = integer;
exports.numeric = numeric;
exports.primaryKey = primaryKey;
exports.real = real;
exports.sqliteTable = sqliteTable;
exports.sqliteTableCreator = sqliteTableCreator;
exports.sqliteView = sqliteView;
exports.text = text;
exports.unique = unique;
exports.uniqueIndex = uniqueIndex;
exports.uniqueKeyName = uniqueKeyName;
exports.view = view;
//# sourceMappingURL=session-60cba450.cjs.map
