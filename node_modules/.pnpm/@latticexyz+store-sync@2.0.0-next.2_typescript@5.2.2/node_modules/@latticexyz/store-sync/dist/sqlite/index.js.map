{"version":3,"sources":["../../src/sqlite/createSqliteTable.ts","../../src/sqlite/buildSqliteColumn.ts","../../src/sqlite/columnTypes.ts","../../src/sqlite/getTableName.ts","../../src/sqlite/getTables.ts","../../src/sqlite/internalTables.ts","../../src/sqlite/schemaVersion.ts","../../src/sqlite/sqliteStorage.ts","../../src/sqlite/sqliteTableToSql.ts","../../src/sqlite/debug.ts","../../src/sqlite/syncToSqlite.ts"],"sourcesContent":["import { AnySQLiteColumnBuilder, SQLiteTableWithColumns, sqliteTable } from \"drizzle-orm/sqlite-core\";\nimport { SchemaAbiType, StaticAbiType } from \"@latticexyz/schema-type\";\nimport { buildSqliteColumn } from \"./buildSqliteColumn\";\nimport { Address } from \"viem\";\nimport { getTableName } from \"./getTableName\";\n\nexport const metaColumns = {\n  __key: buildSqliteColumn(\"__key\", \"bytes\").notNull().primaryKey(),\n  __lastUpdatedBlockNumber: buildSqliteColumn(\"__lastUpdatedBlockNumber\", \"uint256\").notNull(),\n  // TODO: last updated block hash?\n  __isDeleted: buildSqliteColumn(\"__isDeleted\", \"bool\").notNull(),\n} as const satisfies Record<string, AnySQLiteColumnBuilder>;\n\ntype SQLiteTableFromSchema<\n  TKeySchema extends Record<string, StaticAbiType>,\n  TValueSchema extends Record<string, SchemaAbiType>\n> = SQLiteTableWithColumns<{\n  name: string;\n  schema: string | undefined;\n  columns: {\n    // TODO: figure out column types\n    [metaColumn in keyof typeof metaColumns]: any;\n  } & {\n    // TODO: figure out column types\n    [keyColumn in keyof TKeySchema]: any;\n  } & {\n    // TODO: figure out column types\n    [valueColumn in keyof TValueSchema]: any;\n  };\n}>;\n\ntype CreateSqliteTableOptions<\n  TKeySchema extends Record<string, StaticAbiType>,\n  TValueSchema extends Record<string, SchemaAbiType>\n> = {\n  address: Address;\n  namespace: string;\n  name: string;\n  keySchema: TKeySchema;\n  valueSchema: TValueSchema;\n};\n\ntype CreateSqliteTableResult<\n  TKeySchema extends Record<string, StaticAbiType>,\n  TValueSchema extends Record<string, SchemaAbiType>\n> = SQLiteTableFromSchema<TKeySchema, TValueSchema>;\n\nexport function createSqliteTable<\n  TKeySchema extends Record<string, StaticAbiType>,\n  TValueSchema extends Record<string, SchemaAbiType>\n>({\n  address,\n  namespace,\n  name,\n  keySchema,\n  valueSchema,\n}: CreateSqliteTableOptions<TKeySchema, TValueSchema>): CreateSqliteTableResult<TKeySchema, TValueSchema> {\n  const tableName = getTableName(address, namespace, name);\n\n  const keyColumns = Object.fromEntries(\n    Object.entries(keySchema).map(([name, type]) => [name, buildSqliteColumn(name, type).notNull()])\n  );\n\n  const valueColumns = Object.fromEntries(\n    Object.entries(valueSchema).map(([name, type]) => [name, buildSqliteColumn(name, type).notNull()])\n  );\n\n  // TODO: unique constraint on key columns?\n\n  // TODO: make sure there are no meta columns that overlap with key/value columns\n  // TODO: index meta columns?\n\n  const columns = {\n    ...keyColumns,\n    ...valueColumns,\n    ...metaColumns,\n  };\n\n  const table = sqliteTable(tableName, columns);\n\n  return table as SQLiteTableFromSchema<TKeySchema, TValueSchema>;\n}\n","import { AnySQLiteColumnBuilder, blob, integer, text } from \"drizzle-orm/sqlite-core\";\nimport { SchemaAbiType } from \"@latticexyz/schema-type\";\nimport { assertExhaustive } from \"@latticexyz/common/utils\";\nimport { address, json } from \"./columnTypes\";\n\nexport function buildSqliteColumn(name: string, schemaAbiType: SchemaAbiType): AnySQLiteColumnBuilder {\n  switch (schemaAbiType) {\n    case \"bool\":\n      return integer(name, { mode: \"boolean\" });\n\n    case \"uint8\":\n    case \"uint16\":\n    case \"uint24\":\n    case \"uint32\":\n    case \"uint40\":\n    case \"uint48\":\n    case \"int8\":\n    case \"int16\":\n    case \"int24\":\n    case \"int32\":\n    case \"int40\":\n    case \"int48\":\n      return integer(name, { mode: \"number\" });\n\n    case \"uint56\":\n    case \"uint64\":\n    case \"uint72\":\n    case \"uint80\":\n    case \"uint88\":\n    case \"uint96\":\n    case \"uint104\":\n    case \"uint112\":\n    case \"uint120\":\n    case \"uint128\":\n    case \"uint136\":\n    case \"uint144\":\n    case \"uint152\":\n    case \"uint160\":\n    case \"uint168\":\n    case \"uint176\":\n    case \"uint184\":\n    case \"uint192\":\n    case \"uint200\":\n    case \"uint208\":\n    case \"uint216\":\n    case \"uint224\":\n    case \"uint232\":\n    case \"uint240\":\n    case \"uint248\":\n    case \"uint256\":\n    case \"int56\":\n    case \"int64\":\n    case \"int72\":\n    case \"int80\":\n    case \"int88\":\n    case \"int96\":\n    case \"int104\":\n    case \"int112\":\n    case \"int120\":\n    case \"int128\":\n    case \"int136\":\n    case \"int144\":\n    case \"int152\":\n    case \"int160\":\n    case \"int168\":\n    case \"int176\":\n    case \"int184\":\n    case \"int192\":\n    case \"int200\":\n    case \"int208\":\n    case \"int216\":\n    case \"int224\":\n    case \"int232\":\n    case \"int240\":\n    case \"int248\":\n    case \"int256\":\n      return blob(name, { mode: \"bigint\" });\n\n    case \"bytes1\":\n    case \"bytes2\":\n    case \"bytes3\":\n    case \"bytes4\":\n    case \"bytes5\":\n    case \"bytes6\":\n    case \"bytes7\":\n    case \"bytes8\":\n    case \"bytes9\":\n    case \"bytes10\":\n    case \"bytes11\":\n    case \"bytes12\":\n    case \"bytes13\":\n    case \"bytes14\":\n    case \"bytes15\":\n    case \"bytes16\":\n    case \"bytes17\":\n    case \"bytes18\":\n    case \"bytes19\":\n    case \"bytes20\":\n    case \"bytes21\":\n    case \"bytes22\":\n    case \"bytes23\":\n    case \"bytes24\":\n    case \"bytes25\":\n    case \"bytes26\":\n    case \"bytes27\":\n    case \"bytes28\":\n    case \"bytes29\":\n    case \"bytes30\":\n    case \"bytes31\":\n    case \"bytes32\":\n    case \"bytes\":\n      return text(name);\n\n    case \"address\":\n      return address(name);\n\n    case \"uint8[]\":\n    case \"uint16[]\":\n    case \"uint24[]\":\n    case \"uint32[]\":\n    case \"uint40[]\":\n    case \"uint48[]\":\n    case \"uint56[]\":\n    case \"uint64[]\":\n    case \"uint72[]\":\n    case \"uint80[]\":\n    case \"uint88[]\":\n    case \"uint96[]\":\n    case \"uint104[]\":\n    case \"uint112[]\":\n    case \"uint120[]\":\n    case \"uint128[]\":\n    case \"uint136[]\":\n    case \"uint144[]\":\n    case \"uint152[]\":\n    case \"uint160[]\":\n    case \"uint168[]\":\n    case \"uint176[]\":\n    case \"uint184[]\":\n    case \"uint192[]\":\n    case \"uint200[]\":\n    case \"uint208[]\":\n    case \"uint216[]\":\n    case \"uint224[]\":\n    case \"uint232[]\":\n    case \"uint240[]\":\n    case \"uint248[]\":\n    case \"uint256[]\":\n    case \"int8[]\":\n    case \"int16[]\":\n    case \"int24[]\":\n    case \"int32[]\":\n    case \"int40[]\":\n    case \"int48[]\":\n    case \"int56[]\":\n    case \"int64[]\":\n    case \"int72[]\":\n    case \"int80[]\":\n    case \"int88[]\":\n    case \"int96[]\":\n    case \"int104[]\":\n    case \"int112[]\":\n    case \"int120[]\":\n    case \"int128[]\":\n    case \"int136[]\":\n    case \"int144[]\":\n    case \"int152[]\":\n    case \"int160[]\":\n    case \"int168[]\":\n    case \"int176[]\":\n    case \"int184[]\":\n    case \"int192[]\":\n    case \"int200[]\":\n    case \"int208[]\":\n    case \"int216[]\":\n    case \"int224[]\":\n    case \"int232[]\":\n    case \"int240[]\":\n    case \"int248[]\":\n    case \"int256[]\":\n    case \"bytes1[]\":\n    case \"bytes2[]\":\n    case \"bytes3[]\":\n    case \"bytes4[]\":\n    case \"bytes5[]\":\n    case \"bytes6[]\":\n    case \"bytes7[]\":\n    case \"bytes8[]\":\n    case \"bytes9[]\":\n    case \"bytes10[]\":\n    case \"bytes11[]\":\n    case \"bytes12[]\":\n    case \"bytes13[]\":\n    case \"bytes14[]\":\n    case \"bytes15[]\":\n    case \"bytes16[]\":\n    case \"bytes17[]\":\n    case \"bytes18[]\":\n    case \"bytes19[]\":\n    case \"bytes20[]\":\n    case \"bytes21[]\":\n    case \"bytes22[]\":\n    case \"bytes23[]\":\n    case \"bytes24[]\":\n    case \"bytes25[]\":\n    case \"bytes26[]\":\n    case \"bytes27[]\":\n    case \"bytes28[]\":\n    case \"bytes29[]\":\n    case \"bytes30[]\":\n    case \"bytes31[]\":\n    case \"bytes32[]\":\n    case \"bool[]\":\n      return json(name);\n\n    // TODO: normalize like address column type\n    case \"address[]\":\n      return json(name);\n\n    case \"string\":\n      return text(name);\n\n    default:\n      assertExhaustive(schemaAbiType, `Missing SQLite column type for schema ABI type ${schemaAbiType}`);\n  }\n}\n","import { customType, SQLiteCustomColumnBuilder } from \"drizzle-orm/sqlite-core\";\nimport { ColumnBuilderBaseConfig } from \"drizzle-orm\";\nimport superjson from \"superjson\";\nimport { Address, getAddress } from \"viem\";\n\nexport const json = <TData>(name: string): SQLiteCustomColumnBuilder<ColumnBuilderBaseConfig & { data: TData }> =>\n  customType<{ data: TData; driverData: string }>({\n    dataType() {\n      return \"text\";\n    },\n    toDriver(data: TData): string {\n      return superjson.stringify(data);\n    },\n    fromDriver(driverData: string): TData {\n      return superjson.parse(driverData);\n    },\n  })(name);\n\nexport const address = (name: string): SQLiteCustomColumnBuilder<ColumnBuilderBaseConfig & { data: Address }> =>\n  customType<{ data: Address; driverData: string }>({\n    dataType() {\n      return \"text\";\n    },\n    toDriver(data: Address): string {\n      return data.toLowerCase();\n    },\n    fromDriver(driverData: string): Address {\n      return getAddress(driverData);\n    },\n  })(name);\n","import { getAddress } from \"viem\";\n\nexport function getTableName(address: string, namespace: string, tableName: string): string {\n  return `${getAddress(address)}__${namespace}__${tableName}`;\n}\n","import { BaseSQLiteDatabase } from \"drizzle-orm/sqlite-core\";\nimport { inArray } from \"drizzle-orm\";\nimport { Table } from \"../common\";\nimport { TableId } from \"@latticexyz/common/deprecated\";\nimport { getTableName } from \"./getTableName\";\nimport { mudStoreTables } from \"./internalTables\";\n\nexport function getTables(\n  db: BaseSQLiteDatabase<\"sync\", void>,\n  conditions: Pick<Table, \"address\" | \"namespace\" | \"name\">[] = []\n): Table[] {\n  const ids = Array.from(\n    new Set(conditions.map((condition) => getTableName(condition.address, condition.namespace, condition.name)))\n  );\n  const tables = db\n    .select()\n    .from(mudStoreTables)\n    .where(ids.length ? inArray(mudStoreTables.id, ids) : undefined)\n    .all();\n\n  return tables.map((table) => {\n    const tableId = new TableId(table.namespace, table.name).toHex();\n    return {\n      id: getTableName(table.address, table.namespace, table.name),\n      address: table.address,\n      tableId,\n      namespace: table.namespace,\n      name: table.name,\n      keySchema: table.keySchema,\n      valueSchema: table.valueSchema,\n      lastUpdatedBlockNumber: table.lastUpdatedBlockNumber,\n    };\n  });\n}\n","import { blob, integer, sqliteTable, text } from \"drizzle-orm/sqlite-core\";\nimport { address, json } from \"./columnTypes\";\nimport { DynamicAbiType, StaticAbiType } from \"@latticexyz/schema-type\";\n\nexport const chainState = sqliteTable(\"__chainState\", {\n  schemaVersion: integer(\"schema_version\").notNull().primaryKey(),\n  chainId: integer(\"chainId\").notNull().primaryKey(),\n  lastUpdatedBlockNumber: blob(\"last_updated_block_number\", { mode: \"bigint\" }),\n  // TODO: last block hash?\n  lastError: text(\"last_error\"),\n});\n\nexport const mudStoreTables = sqliteTable(\"__mudStoreTables\", {\n  schemaVersion: integer(\"schema_version\").primaryKey(),\n  id: text(\"id\").notNull().primaryKey(),\n  address: address(\"address\").notNull(),\n  tableId: text(\"table_id\").notNull(),\n  namespace: text(\"namespace\").notNull(),\n  name: text(\"name\").notNull(),\n  keySchema: json<Record<string, StaticAbiType>>(\"key_schema\").notNull(),\n  valueSchema: json<Record<string, StaticAbiType | DynamicAbiType>>(\"value_schema\").notNull(),\n  lastUpdatedBlockNumber: blob(\"last_updated_block_number\", { mode: \"bigint\" }),\n  // TODO: last block hash?\n  lastError: text(\"last_error\"),\n});\n","// When this is incremented, it forces all indexers to reindex from scratch the next time they start up.\n// Only use this when the schemas change, until we get proper schema migrations.\nexport const schemaVersion = 1;\n","import { PublicClient, concatHex, encodeAbiParameters, getAddress } from \"viem\";\nimport { BaseSQLiteDatabase } from \"drizzle-orm/sqlite-core\";\nimport { and, eq, sql } from \"drizzle-orm\";\nimport { sqliteTableToSql } from \"./sqliteTableToSql\";\nimport { createSqliteTable } from \"./createSqliteTable\";\nimport { schemaToDefaults } from \"../schemaToDefaults\";\nimport { TableId } from \"@latticexyz/common/deprecated\";\nimport { BlockLogsToStorageOptions } from \"../blockLogsToStorage\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { debug } from \"./debug\";\nimport { getTableName } from \"./getTableName\";\nimport { chainState, mudStoreTables } from \"./internalTables\";\nimport { getTables } from \"./getTables\";\nimport { schemaVersion } from \"./schemaVersion\";\n\nexport async function sqliteStorage<TConfig extends StoreConfig = StoreConfig>({\n  database,\n  publicClient,\n}: {\n  database: BaseSQLiteDatabase<\"sync\", void>;\n  publicClient: PublicClient;\n  config?: TConfig;\n}): Promise<BlockLogsToStorageOptions<TConfig>> {\n  const chainId = publicClient.chain?.id ?? (await publicClient.getChainId());\n\n  // TODO: should these run lazily before first `registerTables`?\n  database.run(sql.raw(sqliteTableToSql(chainState)));\n  database.run(sql.raw(sqliteTableToSql(mudStoreTables)));\n\n  return {\n    async registerTables({ blockNumber, tables }) {\n      await database.transaction(async (tx) => {\n        for (const table of tables) {\n          debug(`creating table ${table.namespace}:${table.name} for world ${chainId}:${table.address}`);\n\n          const sqliteTable = createSqliteTable({\n            address: table.address,\n            namespace: table.namespace,\n            name: table.name,\n            keySchema: table.keySchema,\n            valueSchema: table.valueSchema,\n          });\n\n          tx.run(sql.raw(sqliteTableToSql(sqliteTable)));\n\n          tx.insert(mudStoreTables)\n            .values({\n              schemaVersion,\n              id: getTableName(table.address, table.namespace, table.name),\n              address: table.address,\n              tableId: new TableId(table.namespace, table.name).toHex(),\n              namespace: table.namespace,\n              name: table.name,\n              keySchema: table.keySchema,\n              valueSchema: table.valueSchema,\n              lastUpdatedBlockNumber: blockNumber,\n            })\n            .onConflictDoNothing()\n            .run();\n        }\n      });\n    },\n    async getTables({ tables }) {\n      // TODO: fetch any missing schemas from RPC\n      // TODO: cache schemas in memory?\n      return getTables(database, tables);\n    },\n    async storeOperations({ blockNumber, operations }) {\n      // This is currently parallelized per world (each world has its own database).\n      // This may need to change if we decide to put multiple worlds into one DB (e.g. a namespace per world, but all under one DB).\n      // If so, we'll probably want to wrap the entire block worth of operations in a transaction.\n\n      const tables = getTables(\n        database,\n        Array.from(\n          new Set(\n            operations.map((operation) =>\n              JSON.stringify({\n                address: getAddress(operation.address),\n                namespace: operation.namespace,\n                name: operation.name,\n              })\n            )\n          )\n        ).map((json) => JSON.parse(json))\n      );\n\n      await database.transaction(async (tx) => {\n        for (const { address, namespace, name } of tables) {\n          tx.update(mudStoreTables)\n            .set({ lastUpdatedBlockNumber: blockNumber })\n            .where(\n              and(\n                eq(mudStoreTables.address, address),\n                eq(mudStoreTables.namespace, namespace),\n                eq(mudStoreTables.name, name)\n              )\n            )\n            .run();\n        }\n\n        for (const operation of operations) {\n          const table = tables.find(\n            (table) =>\n              table.address === getAddress(operation.address) &&\n              table.namespace === operation.namespace &&\n              table.name === operation.name\n          );\n          if (!table) {\n            debug(`table ${operation.namespace}:${operation.name} not found, skipping operation`, operation);\n            continue;\n          }\n\n          const sqliteTable = createSqliteTable(table);\n          const key = concatHex(\n            Object.entries(table.keySchema).map(([keyName, type]) =>\n              encodeAbiParameters([{ type }], [operation.key[keyName]])\n            )\n          );\n\n          if (operation.type === \"SetRecord\") {\n            debug(\"SetRecord\", operation);\n            tx.insert(sqliteTable)\n              .values({\n                __key: key,\n                __lastUpdatedBlockNumber: blockNumber,\n                __isDeleted: false,\n                ...operation.key,\n                ...operation.value,\n              })\n              .onConflictDoUpdate({\n                target: sqliteTable.__key,\n                set: {\n                  __lastUpdatedBlockNumber: blockNumber,\n                  __isDeleted: false,\n                  ...operation.value,\n                },\n              })\n              .run();\n          } else if (operation.type === \"SetField\") {\n            debug(\"SetField\", operation);\n            tx.insert(sqliteTable)\n              .values({\n                __key: key,\n                __lastUpdatedBlockNumber: blockNumber,\n                __isDeleted: false,\n                ...operation.key,\n                ...schemaToDefaults(table.valueSchema),\n                [operation.fieldName]: operation.fieldValue,\n              })\n              .onConflictDoUpdate({\n                target: sqliteTable.__key,\n                set: {\n                  __lastUpdatedBlockNumber: blockNumber,\n                  __isDeleted: false,\n                  [operation.fieldName]: operation.fieldValue,\n                },\n              })\n              .run();\n          } else if (operation.type === \"DeleteRecord\") {\n            // TODO: should we upsert so we at least have a DB record of when a thing was created/deleted within the same block?\n            debug(\"DeleteRecord\", operation);\n            tx.update(sqliteTable)\n              .set({\n                __lastUpdatedBlockNumber: blockNumber,\n                __isDeleted: true,\n              })\n              .where(eq(sqliteTable.__key, key))\n              .run();\n          }\n        }\n\n        tx.insert(chainState)\n          .values({\n            schemaVersion,\n            chainId,\n            lastUpdatedBlockNumber: blockNumber,\n          })\n          .onConflictDoUpdate({\n            target: [chainState.schemaVersion, chainState.chainId],\n            set: {\n              lastUpdatedBlockNumber: blockNumber,\n            },\n          })\n          .run();\n      });\n    },\n  } as BlockLogsToStorageOptions<TConfig>;\n}\n","import { AnySQLiteColumn, SQLiteTableWithColumns } from \"drizzle-orm/sqlite-core\";\nimport { ColumnDataType, Kysely, SqliteDialect } from \"kysely\";\nimport SqliteDatabase from \"better-sqlite3\";\nimport { getTableColumns, getTableName } from \"drizzle-orm\";\n\nconst db = new Kysely<any>({\n  dialect: new SqliteDialect({ database: new SqliteDatabase(\":memory:\") }),\n});\n\nexport function sqliteTableToSql(table: SQLiteTableWithColumns<any>): string {\n  const tableName = getTableName(table);\n\n  // TODO: should we allow this to fail (remove ifNotExists) so we can catch issues with our logic that creates tables?\n  let query = db.schema.createTable(tableName).ifNotExists();\n\n  const columns = Object.values(getTableColumns(table)) as AnySQLiteColumn[];\n  for (const column of columns) {\n    query = query.addColumn(column.name, column.getSQLType() as ColumnDataType, (col) => {\n      if (column.notNull) {\n        col = col.notNull();\n      }\n      if (column.hasDefault && typeof column.default !== \"undefined\") {\n        col = col.defaultTo(column.default);\n      }\n      return col;\n    });\n  }\n\n  const primaryKeys = columns.filter((column) => column.primary).map((column) => column.name);\n  if (primaryKeys.length) {\n    query = query.addPrimaryKeyConstraint(`${tableName}__primaryKey`, primaryKeys as any);\n  }\n\n  const { sql } = query.compile();\n  return sql;\n}\n","import { debug as parentDebug } from \"../debug\";\n\nexport const debug = parentDebug.extend(\"sqlite\");\n","import { StoreConfig } from \"@latticexyz/store\";\nimport { BaseSQLiteDatabase } from \"drizzle-orm/sqlite-core\";\nimport { SyncOptions, SyncResult } from \"../common\";\nimport { sqliteStorage } from \"./sqliteStorage\";\nimport { createStoreSync } from \"../createStoreSync\";\n\ntype SyncToSqliteOptions<TConfig extends StoreConfig = StoreConfig> = SyncOptions<TConfig> & {\n  /**\n   * [SQLite database object from Drizzle][0].\n   *\n   * [0]: https://orm.drizzle.team/docs/installation-and-db-connection/sqlite/better-sqlite3\n   */\n  database: BaseSQLiteDatabase<\"sync\", any>;\n};\n\ntype SyncToSqliteResult<TConfig extends StoreConfig = StoreConfig> = SyncResult<TConfig> & {\n  destroy: () => void;\n};\n\n/**\n * Creates an indexer to process and store blockchain events.\n *\n * @param {CreateIndexerOptions} options See `CreateIndexerOptions`.\n * @returns A function to unsubscribe from the block stream, effectively stopping the indexer.\n */\nexport async function syncToSqlite<TConfig extends StoreConfig = StoreConfig>({\n  config,\n  database,\n  publicClient,\n  address,\n  startBlock,\n  maxBlockRange,\n  indexerUrl,\n  initialState,\n}: SyncToSqliteOptions<TConfig>): Promise<SyncToSqliteResult<TConfig>> {\n  const storeSync = await createStoreSync({\n    storageAdapter: await sqliteStorage({ database, publicClient, config }),\n    config,\n    address,\n    publicClient,\n    startBlock,\n    maxBlockRange,\n    indexerUrl,\n    initialState,\n  });\n\n  // Start the sync\n  const sub = storeSync.blockStorageOperations$.subscribe();\n\n  return {\n    ...storeSync,\n    destroy: (): void => {\n      sub.unsubscribe();\n    },\n  };\n}\n"],"mappings":"sHAAA,OAAyD,eAAAA,MAAmB,0BCA5E,OAAiC,QAAAC,EAAM,WAAAC,EAAS,QAAAC,MAAY,0BAE5D,OAAS,oBAAAC,MAAwB,2BCFjC,OAAS,cAAAC,MAA6C,0BAEtD,OAAOC,MAAe,YACtB,OAAkB,cAAAC,MAAkB,OAE7B,IAAMC,EAAeC,GAC1BJ,EAAgD,CAC9C,UAAW,CACT,MAAO,MACT,EACA,SAASK,EAAqB,CAC5B,OAAOJ,EAAU,UAAUI,CAAI,CACjC,EACA,WAAWC,EAA2B,CACpC,OAAOL,EAAU,MAAMK,CAAU,CACnC,CACF,CAAC,EAAEF,CAAI,EAEIG,EAAWH,GACtBJ,EAAkD,CAChD,UAAW,CACT,MAAO,MACT,EACA,SAASK,EAAuB,CAC9B,OAAOA,EAAK,YAAY,CAC1B,EACA,WAAWC,EAA6B,CACtC,OAAOJ,EAAWI,CAAU,CAC9B,CACF,CAAC,EAAEF,CAAI,EDxBF,SAASI,EAAkBC,EAAcC,EAAsD,CACpG,OAAQA,EAAe,CACrB,IAAK,OACH,OAAOC,EAAQF,EAAM,CAAE,KAAM,SAAU,CAAC,EAE1C,IAAK,QACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,OACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,QACH,OAAOE,EAAQF,EAAM,CAAE,KAAM,QAAS,CAAC,EAEzC,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACH,OAAOG,EAAKH,EAAM,CAAE,KAAM,QAAS,CAAC,EAEtC,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,QACH,OAAOI,EAAKJ,CAAI,EAElB,IAAK,UACH,OAAOK,EAAQL,CAAI,EAErB,IAAK,UACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,SACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WA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","names":["sqliteTable","blob","integer","text","assertExhaustive","customType","superjson","getAddress","json","name","data","driverData","address","buildSqliteColumn","name","schemaAbiType","integer","blob","text","address","json","assertExhaustive","getAddress","getTableName","address","namespace","tableName","metaColumns","buildSqliteColumn","createSqliteTable","address","namespace","name","keySchema","valueSchema","tableName","getTableName","keyColumns","type","valueColumns","columns","sqliteTable","inArray","TableId","blob","integer","sqliteTable","text","chainState","sqliteTable","integer","blob","text","mudStoreTables","address","json","getTables","db","conditions","ids","condition","getTableName","mudStoreTables","inArray","table","tableId","TableId","schemaVersion","concatHex","encodeAbiParameters","getAddress","and","eq","sql","Kysely","SqliteDialect","SqliteDatabase","getTableColumns","getTableName","db","sqliteTableToSql","table","tableName","query","columns","column","col","primaryKeys","sql","TableId","debug","sqliteStorage","database","publicClient","chainId","sql","sqliteTableToSql","chainState","mudStoreTables","blockNumber","tables","tx","table","debug","sqliteTable","createSqliteTable","getTableName","TableId","getTables","operations","operation","getAddress","json","address","namespace","name","and","eq","key","concatHex","keyName","type","encodeAbiParameters","schemaToDefaults","syncToSqlite","config","database","publicClient","address","startBlock","maxBlockRange","indexerUrl","initialState","storeSync","createStoreSync","sqliteStorage","sub"]}