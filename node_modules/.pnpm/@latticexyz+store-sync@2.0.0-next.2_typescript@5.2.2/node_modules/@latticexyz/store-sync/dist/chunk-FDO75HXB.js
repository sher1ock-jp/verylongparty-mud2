import{decodeField as A,decodeKeyTuple as w,decodeRecord as k,hexToTableSchema as F,abiTypesToSchema as K}from"@latticexyz/protocol-parser";import{TableId as m}from"@latticexyz/common/deprecated";import{decodeAbiParameters as L,getAddress as i,parseAbiParameters as B}from"viem";import $ from"debug";var l=$("mud:store-sync");import{isDefined as S}from"@latticexyz/common/utils";var R=new m("mudstore","schema"),E=new m("mudstore","StoreMetadata"),u=new Map,g=new Map;function U({registerTables:N,getTables:h,storeOperations:v}){return async n=>{let d=new Set;n.logs.forEach(e=>{if(e.eventName!=="StoreSetRecord"||e.args.table!==R.toHex())return;let[s,...a]=e.args.key;a.length&&l("registerSchema event is expected to have only one key in key tuple, but got multiple",e);let o=m.fromHex(s),c=F(e.args.data),t=`${i(e.address)}:${o.namespace}:${o.name}`;u.has(t)||(u.set(t,{address:i(e.address),tableId:o,schema:c}),d.add(t))}),n.logs.forEach(e=>{if(e.eventName!=="StoreSetRecord"||e.args.table!==E.toHex())return;let[s,...a]=e.args.key;a.length&&l("setMetadata event is expected to have only one key in key tuple, but got multiple",e);let o=m.fromHex(s),[c,t]=k({staticFields:[],dynamicFields:["string","bytes"]},e.args.data),r=L(B("string[]"),t)[0],b=`${i(e.address)}:${o.namespace}:${c}`;g.has(b)||(g.set(b,{address:i(e.address),tableId:o,keyNames:[],valueNames:r}),d.add(b))});let x=Array.from(d).map(e=>{let[s,a,o]=e.split(":");return{address:s,tableId:new m(a,o)}});await N({blockNumber:n.blockNumber,tables:x.map(({address:e,tableId:s})=>{let a=Array.from(u.values()).find(({address:t,tableId:r})=>t===e&&r.toHex()===s.toHex()),o=Array.from(g.values()).find(({address:t,tableId:r})=>t===e&&r.toHex()===s.toHex());if(!a){l(`no schema registration found for table ${s.toString()} in block ${n.blockNumber}, skipping`);return}if(!o){l(`no metadata registration found for table ${s.toString()} in block ${n.blockNumber}, skipping`);return}let c=[...a.schema.valueSchema.staticFields,...a.schema.valueSchema.dynamicFields];return{address:e,tableId:a.tableId.toHex(),namespace:a.tableId.namespace,name:a.tableId.name,keySchema:Object.fromEntries(a.schema.keySchema.staticFields.map((t,r)=>[r,t])),valueSchema:Object.fromEntries(c.map((t,r)=>[o.valueNames[r],t]))}}).filter(S)});let C=Array.from(new Set(n.logs.map(e=>JSON.stringify({address:i(e.address),...m.fromHex(e.args.table)})))),I=Object.fromEntries((await h({blockNumber:n.blockNumber,tables:C.map(e=>JSON.parse(e))})).map(e=>[`${e.address}:${new m(e.namespace,e.name).toHex()}`,e])),T=n.logs.map(e=>{let s=m.fromHex(e.args.table),a=I[`${i(e.address)}:${e.args.table}`];if(!a){l("no table found for event, skipping",s.toString(),e);return}let o=Object.keys(a.keySchema),c=w({staticFields:Object.values(a.keySchema),dynamicFields:[]},e.args.key),t=Object.fromEntries(c.map((f,p)=>[o[p],f])),r=Object.values(a.valueSchema),b=K(r),y=Object.keys(a.valueSchema);if(e.eventName==="StoreSetRecord"||e.eventName==="StoreEphemeralRecord"){let f=k(b,e.args.data),p=Object.fromEntries(y.map((O,H)=>[O,f[H]]));return{log:e,address:i(e.address),type:"SetRecord",...s,key:t,value:p}}if(e.eventName==="StoreSetField"){let f=y[e.args.schemaIndex],p=A(r[e.args.schemaIndex],e.args.data);return{log:e,address:i(e.address),type:"SetField",...s,key:t,fieldName:f,fieldValue:p}}if(e.eventName==="StoreDeleteRecord")return{log:e,address:i(e.address),type:"DeleteRecord",...s,key:t};l("unknown store event or log, skipping",e)}).filter(S);return await v({blockNumber:n.blockNumber,operations:T}),{blockNumber:n.blockNumber,operations:T}}}var P=(d=>(d.INITIALIZE="initialize",d.SNAPSHOT="snapshot",d.RPC="rpc",d.LIVE="live",d))(P||{});export{l as a,R as b,E as c,U as d,P as e};
//# sourceMappingURL=chunk-FDO75HXB.js.map