{"version":3,"sources":["../src/blockLogsToStorage.ts","../src/debug.ts","../src/SyncStep.ts"],"sourcesContent":["import {\n  decodeField,\n  decodeKeyTuple,\n  decodeRecord,\n  hexToTableSchema,\n  abiTypesToSchema,\n  TableSchema,\n} from \"@latticexyz/protocol-parser\";\nimport { StoreConfig, ConfigToKeyPrimitives as Key, ConfigToValuePrimitives as Value } from \"@latticexyz/store\";\nimport { TableId } from \"@latticexyz/common/deprecated\";\nimport { Address, Hex, decodeAbiParameters, getAddress, parseAbiParameters } from \"viem\";\nimport { debug } from \"./debug\";\nimport { isDefined } from \"@latticexyz/common/utils\";\nimport { BlockLogs, StorageOperation, Table, TableName, TableNamespace } from \"./common\";\n\n// TODO: change table schema/metadata APIs once we get both schema and field names in the same event (https://github.com/latticexyz/mud/pull/1182)\n\n// TODO: export these from store or world\nexport const schemaTableId = new TableId(\"mudstore\", \"schema\");\nexport const metadataTableId = new TableId(\"mudstore\", \"StoreMetadata\");\n\nexport type BlockLogsToStorageOptions<TConfig extends StoreConfig = StoreConfig> = {\n  registerTables: (opts: { blockNumber: BlockLogs[\"blockNumber\"]; tables: Table[] }) => Promise<void>;\n  getTables: (opts: {\n    blockNumber: BlockLogs[\"blockNumber\"];\n    tables: Pick<Table, \"address\" | \"namespace\" | \"name\">[];\n  }) => Promise<Table[]>;\n  storeOperations: (opts: {\n    blockNumber: BlockLogs[\"blockNumber\"];\n    operations: StorageOperation<TConfig>[];\n  }) => Promise<void>;\n};\n\nexport type BlockStorageOperations<TConfig extends StoreConfig = StoreConfig> = {\n  blockNumber: BlockLogs[\"blockNumber\"];\n  operations: StorageOperation<TConfig>[];\n};\n\nexport type BlockLogsToStorageResult<TConfig extends StoreConfig = StoreConfig> = (\n  block: BlockLogs\n) => Promise<BlockStorageOperations<TConfig>>;\n\ntype TableKey = `${Address}:${TableNamespace}:${TableName}`;\n\n// hacky fix for schema registration + metadata events spanning multiple blocks\n// TODO: remove this once schema registration+metadata is one event or tx (https://github.com/latticexyz/mud/pull/1182)\nconst visitedSchemas = new Map<TableKey, { address: Address; tableId: TableId; schema: TableSchema }>();\nconst visitedMetadata = new Map<\n  TableKey,\n  { address: Address; tableId: TableId; keyNames: readonly string[]; valueNames: readonly string[] }\n>();\n\nexport function blockLogsToStorage<TConfig extends StoreConfig = StoreConfig>({\n  registerTables,\n  getTables,\n  storeOperations,\n}: BlockLogsToStorageOptions<TConfig>): BlockLogsToStorageResult<TConfig> {\n  return async (block) => {\n    const newTableKeys = new Set<TableKey>();\n\n    // First find all schema registration events.\n    block.logs.forEach((log) => {\n      if (log.eventName !== \"StoreSetRecord\") return;\n      if (log.args.table !== schemaTableId.toHex()) return;\n\n      const [tableForSchema, ...otherKeys] = log.args.key;\n      if (otherKeys.length) {\n        debug(\"registerSchema event is expected to have only one key in key tuple, but got multiple\", log);\n      }\n\n      const tableId = TableId.fromHex(tableForSchema);\n      const schema = hexToTableSchema(log.args.data);\n\n      const key: TableKey = `${getAddress(log.address)}:${tableId.namespace}:${tableId.name}`;\n      if (!visitedSchemas.has(key)) {\n        visitedSchemas.set(key, { address: getAddress(log.address), tableId, schema });\n        newTableKeys.add(key);\n      }\n    });\n\n    // Then find all metadata events. These should follow schema registration events and be in the same block (since they're in the same tx).\n    // TODO: rework contracts so schemas+tables are combined and immutable (https://github.com/latticexyz/mud/pull/1182)\n    block.logs.forEach((log) => {\n      if (log.eventName !== \"StoreSetRecord\") return;\n      if (log.args.table !== metadataTableId.toHex()) return;\n\n      const [tableForSchema, ...otherKeys] = log.args.key;\n      if (otherKeys.length) {\n        debug(\"setMetadata event is expected to have only one key in key tuple, but got multiple\", log);\n      }\n\n      const tableId = TableId.fromHex(tableForSchema);\n      const [tableName, abiEncodedFieldNames] = decodeRecord(\n        // TODO: this is hardcoded for now while metadata is separate from table registration (https://github.com/latticexyz/mud/pull/1182)\n        { staticFields: [], dynamicFields: [\"string\", \"bytes\"] },\n        log.args.data\n      );\n      const valueNames = decodeAbiParameters(parseAbiParameters(\"string[]\"), abiEncodedFieldNames as Hex)[0];\n      // TODO: add key names to table registration when we refactor it (https://github.com/latticexyz/mud/pull/1182)\n      const key: TableKey = `${getAddress(log.address)}:${tableId.namespace}:${tableName}`;\n      if (!visitedMetadata.has(key)) {\n        visitedMetadata.set(key, { address: getAddress(log.address), tableId, keyNames: [], valueNames });\n        newTableKeys.add(key);\n      }\n    });\n\n    const newTableIds = Array.from(newTableKeys).map((tableKey) => {\n      const [address, namespace, name] = tableKey.split(\":\");\n      return { address: address as Hex, tableId: new TableId(namespace, name) };\n    });\n\n    await registerTables({\n      blockNumber: block.blockNumber,\n      tables: newTableIds\n        .map(({ address, tableId }) => {\n          const schema = Array.from(visitedSchemas.values()).find(\n            ({ address: schemaAddress, tableId: schemaTableId }) =>\n              schemaAddress === address && schemaTableId.toHex() === tableId.toHex()\n          );\n          const metadata = Array.from(visitedMetadata.values()).find(\n            ({ address: metadataAddress, tableId: metadataTableId }) =>\n              metadataAddress === address && metadataTableId.toHex() === tableId.toHex()\n          );\n          if (!schema) {\n            debug(\n              `no schema registration found for table ${tableId.toString()} in block ${block.blockNumber}, skipping`\n            );\n            return;\n          }\n          if (!metadata) {\n            debug(\n              `no metadata registration found for table ${tableId.toString()} in block ${block.blockNumber}, skipping`\n            );\n            return;\n          }\n\n          const valueAbiTypes = [...schema.schema.valueSchema.staticFields, ...schema.schema.valueSchema.dynamicFields];\n\n          return {\n            address,\n            tableId: schema.tableId.toHex(),\n            namespace: schema.tableId.namespace,\n            name: schema.tableId.name,\n            // TODO: replace with proper named key tuple (https://github.com/latticexyz/mud/pull/1182)\n            keySchema: Object.fromEntries(schema.schema.keySchema.staticFields.map((abiType, i) => [i, abiType])),\n            valueSchema: Object.fromEntries(valueAbiTypes.map((abiType, i) => [metadata.valueNames[i], abiType])),\n          };\n        })\n        .filter(isDefined),\n    });\n\n    const tableIds = Array.from(\n      new Set(\n        block.logs.map((log) =>\n          JSON.stringify({\n            address: getAddress(log.address),\n            ...TableId.fromHex(log.args.table),\n          })\n        )\n      )\n    );\n    // TODO: combine these once we refactor table registration (https://github.com/latticexyz/mud/pull/1182)\n    const tables = Object.fromEntries(\n      (\n        await getTables({\n          blockNumber: block.blockNumber,\n          tables: tableIds.map((json) => JSON.parse(json)),\n        })\n      ).map((table) => [`${table.address}:${new TableId(table.namespace, table.name).toHex()}`, table])\n    ) as Record<Hex, Table>;\n\n    const operations = block.logs\n      .map((log): StorageOperation<TConfig> | undefined => {\n        const tableId = TableId.fromHex(log.args.table);\n        const table = tables[`${getAddress(log.address)}:${log.args.table}`];\n        if (!table) {\n          debug(\"no table found for event, skipping\", tableId.toString(), log);\n          return;\n        }\n\n        const keyNames = Object.keys(table.keySchema);\n        const keyValues = decodeKeyTuple(\n          { staticFields: Object.values(table.keySchema), dynamicFields: [] },\n          log.args.key\n        );\n        const key = Object.fromEntries(keyValues.map((value, i) => [keyNames[i], value])) as Key<\n          TConfig,\n          keyof TConfig[\"tables\"]\n        >;\n\n        const valueAbiTypes = Object.values(table.valueSchema);\n        const valueSchema = abiTypesToSchema(valueAbiTypes);\n        const fieldNames = Object.keys(table.valueSchema);\n\n        if (log.eventName === \"StoreSetRecord\" || log.eventName === \"StoreEphemeralRecord\") {\n          const valueTuple = decodeRecord(valueSchema, log.args.data);\n          const value = Object.fromEntries(fieldNames.map((name, i) => [name, valueTuple[i]])) as Value<\n            TConfig,\n            keyof TConfig[\"tables\"]\n          >;\n          // TODO: decide if we should handle ephemeral records separately?\n          //       they'll eventually be turned into \"events\", but unclear if that should translate to client storage operations\n          return {\n            log,\n            address: getAddress(log.address),\n            type: \"SetRecord\",\n            ...tableId,\n            key,\n            value,\n          };\n        }\n\n        if (log.eventName === \"StoreSetField\") {\n          const fieldName = fieldNames[log.args.schemaIndex] as string & keyof Value<TConfig, keyof TConfig[\"tables\"]>;\n          const fieldValue = decodeField(valueAbiTypes[log.args.schemaIndex], log.args.data) as Value<\n            TConfig,\n            keyof TConfig[\"tables\"]\n          >[typeof fieldName];\n          return {\n            log,\n            address: getAddress(log.address),\n            type: \"SetField\",\n            ...tableId,\n            key,\n            fieldName,\n            fieldValue,\n          };\n        }\n\n        if (log.eventName === \"StoreDeleteRecord\") {\n          return {\n            log,\n            address: getAddress(log.address),\n            type: \"DeleteRecord\",\n            ...tableId,\n            key,\n          };\n        }\n\n        debug(\"unknown store event or log, skipping\", log);\n        return;\n      })\n      .filter(isDefined);\n\n    await storeOperations({ blockNumber: block.blockNumber, operations });\n\n    return {\n      blockNumber: block.blockNumber,\n      operations,\n    };\n  };\n}\n","import createDebug from \"debug\";\n\nexport const debug = createDebug(\"mud:store-sync\");\n","export enum SyncStep {\n  INITIALIZE = \"initialize\",\n  SNAPSHOT = \"snapshot\",\n  RPC = \"rpc\",\n  LIVE = \"live\",\n}\n"],"mappings":"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","names":["decodeField","decodeKeyTuple","decodeRecord","hexToTableSchema","abiTypesToSchema","TableId","decodeAbiParameters","getAddress","parseAbiParameters","createDebug","debug","isDefined","schemaTableId","TableId","metadataTableId","visitedSchemas","visitedMetadata","blockLogsToStorage","registerTables","getTables","storeOperations","block","newTableKeys","log","tableForSchema","otherKeys","debug","tableId","schema","hexToTableSchema","key","getAddress","tableName","abiEncodedFieldNames","decodeRecord","valueNames","decodeAbiParameters","parseAbiParameters","newTableIds","tableKey","address","namespace","name","schemaAddress","metadata","metadataAddress","valueAbiTypes","abiType","i","tableIds","tables","json","table","operations","keyNames","keyValues","decodeKeyTuple","value","valueSchema","abiTypesToSchema","fieldNames","valueTuple","fieldName","fieldValue","decodeField","SyncStep"]}