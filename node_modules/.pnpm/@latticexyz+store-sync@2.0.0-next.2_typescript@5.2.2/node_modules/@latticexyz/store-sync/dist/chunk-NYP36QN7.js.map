{"version":3,"sources":["../src/schemaToDefaults.ts","../src/createStoreSync.ts"],"sourcesContent":["import { schemaAbiTypeToDefaultValue } from \"@latticexyz/schema-type\";\nimport { ValueSchema, SchemaToPrimitives } from \"@latticexyz/store\";\n\nexport function schemaToDefaults<TSchema extends ValueSchema>(schema: TSchema): SchemaToPrimitives<TSchema> {\n  return Object.fromEntries(\n    Object.entries(schema).map(([key, abiType]) => [key, schemaAbiTypeToDefaultValue[abiType]])\n  ) as SchemaToPrimitives<TSchema>;\n}\n","import { ConfigToKeyPrimitives, ConfigToValuePrimitives, StoreConfig, storeEventsAbi } from \"@latticexyz/store\";\nimport { Hex, TransactionReceipt } from \"viem\";\nimport { SetRecordOperation, SyncOptions, SyncResult } from \"./common\";\nimport { createBlockStream, blockRangeToLogs, groupLogsByBlockNumber } from \"@latticexyz/block-logs-stream\";\nimport { filter, map, tap, mergeMap, from, concatMap, share, firstValueFrom } from \"rxjs\";\nimport { blockLogsToStorage } from \"./blockLogsToStorage\";\nimport { debug as parentDebug } from \"./debug\";\nimport { createIndexerClient } from \"./trpc-indexer\";\nimport { BlockLogsToStorageOptions } from \"./blockLogsToStorage\";\nimport { SyncStep } from \"./SyncStep\";\n\nconst debug = parentDebug.extend(\"createStoreSync\");\n\ntype CreateStoreSyncOptions<TConfig extends StoreConfig = StoreConfig> = SyncOptions<TConfig> & {\n  storageAdapter: BlockLogsToStorageOptions<TConfig>;\n  onProgress?: (opts: {\n    step: SyncStep;\n    percentage: number;\n    latestBlockNumber: bigint;\n    lastBlockNumberProcessed: bigint;\n  }) => void;\n};\n\ntype CreateStoreSyncResult<TConfig extends StoreConfig = StoreConfig> = SyncResult<TConfig>;\n\nexport async function createStoreSync<TConfig extends StoreConfig = StoreConfig>({\n  storageAdapter,\n  onProgress,\n  address,\n  publicClient,\n  startBlock = 0n,\n  maxBlockRange,\n  initialState,\n  indexerUrl,\n}: CreateStoreSyncOptions<TConfig>): Promise<CreateStoreSyncResult<TConfig>> {\n  if (indexerUrl != null && initialState == null) {\n    try {\n      const indexer = createIndexerClient({ url: indexerUrl });\n      const chainId = publicClient.chain?.id ?? (await publicClient.getChainId());\n      initialState = await indexer.findAll.query({ chainId, address });\n    } catch (error) {\n      debug(\"couldn't get initial state from indexer\", error);\n    }\n  }\n\n  if (initialState != null) {\n    const { blockNumber, tables } = initialState;\n    if (blockNumber != null) {\n      debug(\"hydrating from initial state to block\", initialState.blockNumber);\n      startBlock = blockNumber + 1n;\n\n      await storageAdapter.registerTables({ blockNumber, tables });\n\n      const numRecords = initialState.tables.reduce((sum, table) => sum + table.records.length, 0);\n      const recordsPerProgressUpdate = Math.floor(numRecords / 100);\n      let recordsProcessed = 0;\n      let recordsProcessedSinceLastUpdate = 0;\n\n      for (const table of initialState.tables) {\n        await storageAdapter.storeOperations({\n          blockNumber,\n          operations: table.records.map(\n            (record) =>\n              ({\n                type: \"SetRecord\",\n                address: table.address,\n                namespace: table.namespace,\n                name: table.name,\n                key: record.key as ConfigToKeyPrimitives<TConfig, typeof table.name>,\n                value: record.value as ConfigToValuePrimitives<TConfig, typeof table.name>,\n              } as const satisfies SetRecordOperation<TConfig>)\n          ),\n        });\n\n        recordsProcessed += table.records.length;\n        recordsProcessedSinceLastUpdate += table.records.length;\n\n        if (recordsProcessedSinceLastUpdate > recordsPerProgressUpdate) {\n          recordsProcessedSinceLastUpdate = 0;\n          onProgress?.({\n            step: SyncStep.SNAPSHOT,\n            percentage: (recordsProcessed / numRecords) * 100,\n            latestBlockNumber: 0n,\n            lastBlockNumberProcessed: blockNumber,\n          });\n        }\n\n        debug(`hydrated ${table.records.length} records for table ${table.namespace}:${table.name}`);\n      }\n    }\n  }\n\n  // TODO: if startBlock is still 0, find via deploy event\n\n  debug(\"starting sync from block\", startBlock);\n\n  const latestBlock$ = createBlockStream({ publicClient, blockTag: \"latest\" }).pipe(share());\n  const latestBlockNumber$ = latestBlock$.pipe(\n    map((block) => block.number),\n    share()\n  );\n\n  let latestBlockNumber: bigint | null = null;\n  const blockLogs$ = latestBlockNumber$.pipe(\n    tap((blockNumber) => {\n      debug(\"latest block number\", blockNumber);\n      latestBlockNumber = blockNumber;\n    }),\n    map((blockNumber) => ({ startBlock, endBlock: blockNumber })),\n    blockRangeToLogs({\n      publicClient,\n      address,\n      events: storeEventsAbi,\n      maxBlockRange,\n    }),\n    mergeMap(({ toBlock, logs }) => from(groupLogsByBlockNumber(logs, toBlock))),\n    share()\n  );\n\n  let lastBlockNumberProcessed: bigint | null = null;\n  const blockStorageOperations$ = blockLogs$.pipe(\n    concatMap(blockLogsToStorage(storageAdapter)),\n    tap(({ blockNumber, operations }) => {\n      debug(\"stored\", operations.length, \"operations for block\", blockNumber);\n      lastBlockNumberProcessed = blockNumber;\n\n      if (latestBlockNumber != null) {\n        if (blockNumber < latestBlockNumber) {\n          onProgress?.({\n            step: SyncStep.RPC,\n            percentage: Number((lastBlockNumberProcessed * 1000n) / (latestBlockNumber * 1000n)) / 100,\n            latestBlockNumber,\n            lastBlockNumberProcessed,\n          });\n        } else {\n          onProgress?.({\n            step: SyncStep.LIVE,\n            percentage: 100,\n            latestBlockNumber,\n            lastBlockNumberProcessed,\n          });\n        }\n      }\n    }),\n    share()\n  );\n\n  async function waitForTransaction(tx: Hex): Promise<{\n    receipt: TransactionReceipt;\n  }> {\n    // Wait for tx to be mined\n    const receipt = await publicClient.waitForTransactionReceipt({ hash: tx });\n\n    // If we haven't processed a block yet or we haven't processed the block for the tx, wait for it\n    if (lastBlockNumberProcessed == null || lastBlockNumberProcessed < receipt.blockNumber) {\n      await firstValueFrom(\n        blockStorageOperations$.pipe(\n          filter(({ blockNumber }) => blockNumber != null && blockNumber >= receipt.blockNumber)\n        )\n      );\n    }\n\n    return { receipt };\n  }\n\n  return {\n    latestBlock$,\n    latestBlockNumber$,\n    blockLogs$,\n    blockStorageOperations$,\n    waitForTransaction,\n  };\n}\n"],"mappings":"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","names":["schemaAbiTypeToDefaultValue","schemaToDefaults","schema","key","abiType","storeEventsAbi","createBlockStream","blockRangeToLogs","groupLogsByBlockNumber","filter","map","tap","mergeMap","from","concatMap","share","firstValueFrom","debug","createStoreSync","storageAdapter","onProgress","address","publicClient","startBlock","maxBlockRange","initialState","indexerUrl","indexer","createIndexerClient","chainId","error","blockNumber","tables","numRecords","sum","table","recordsPerProgressUpdate","recordsProcessed","recordsProcessedSinceLastUpdate","record","latestBlock$","createBlockStream","share","latestBlockNumber$","map","block","latestBlockNumber","blockLogs$","tap","blockRangeToLogs","storeEventsAbi","mergeMap","toBlock","logs","from","groupLogsByBlockNumber","lastBlockNumberProcessed","blockStorageOperations$","concatMap","blockLogsToStorage","operations","waitForTransaction","tx","receipt","firstValueFrom","filter"]}