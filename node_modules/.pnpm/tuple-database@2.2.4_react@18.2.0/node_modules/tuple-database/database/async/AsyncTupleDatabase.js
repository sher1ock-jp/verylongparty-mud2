"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncTupleDatabase = void 0;
const iterateTuples_1 = require("../../helpers/iterateTuples");
const randomId_1 = require("../../helpers/randomId");
const ConcurrencyLog_1 = require("../ConcurrencyLog");
const AsyncReactivityTracker_1 = require("./AsyncReactivityTracker");
class AsyncTupleDatabase {
    constructor(storage) {
        this.storage = storage;
        this.log = new ConcurrencyLog_1.ConcurrencyLog();
        this.reactivity = new AsyncReactivityTracker_1.AsyncReactivityTracker();
    }
    async scan(args = {}, txId) {
        const { reverse, limit, ...bounds } = args;
        if (txId)
            this.log.read(txId, bounds);
        return this.storage.scan({ ...bounds, reverse, limit });
    }
    async subscribe(args, callback) {
        return this.reactivity.subscribe(args, callback);
    }
    async commit(writes, txId) {
        // Note: commit is called for transactional reads as well!
        const emits = this.reactivity.computeReactivityEmits(writes);
        if (txId)
            this.log.commit(txId);
        for (const tuple of (0, iterateTuples_1.iterateWrittenTuples)(writes)) {
            this.log.write(txId, tuple);
        }
        await this.storage.commit(writes);
        return this.reactivity.emit(emits, txId || (0, randomId_1.randomId)());
    }
    async cancel(txId) {
        this.log.cancel(txId);
    }
    async close() {
        await this.storage.close();
    }
}
exports.AsyncTupleDatabase = AsyncTupleDatabase;
//# sourceMappingURL=../../../src/database/async/AsyncTupleDatabase.js.map