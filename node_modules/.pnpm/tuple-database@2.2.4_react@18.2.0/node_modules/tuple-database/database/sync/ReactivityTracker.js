"use strict";
/*

This file is generated from async/AsyncReactivityTracker.ts

*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactivityTracker = void 0;
const maybeWaitForPromises_1 = require("../../helpers/maybeWaitForPromises");
const randomId_1 = require("../../helpers/randomId");
const sortedTupleArray_1 = require("../../helpers/sortedTupleArray");
const InMemoryTupleStorage_1 = require("../../storage/InMemoryTupleStorage");
const types_1 = require("../../storage/types");
class ReactivityTracker {
    constructor() {
        this.listenersDb = new InMemoryTupleStorage_1.InMemoryTupleStorage();
    }
    subscribe(args, callback) {
        return subscribe(this.listenersDb, args, callback);
    }
    computeReactivityEmits(writes) {
        return getReactivityEmits(this.listenersDb, writes);
    }
    emit(emits, txId) {
        let promises = [];
        for (const [callback, writes] of emits.entries()) {
            try {
                // Catch sync callbacks.
                promises.push(callback(writes, txId));
            }
            catch (error) {
                console.error(error);
            }
        }
        // This trick allows us to return a Promise from a sync TupleDatabase#commit
        // when there are  callbacks. And this allows us to create an  client
        // on top of a sync client.
        return (0, maybeWaitForPromises_1.maybePromiseAll)(promises);
    }
}
exports.ReactivityTracker = ReactivityTracker;
function iterateTuplePrefixes(tuple) {
    const prefixes = [tuple];
    for (let i = 0; i < tuple.length; i++) {
        const prefix = tuple.slice(0, i);
        prefixes.push(prefix);
    }
    return prefixes;
}
/** Query the listenersDb based on tuple prefixes. */
function getListenersForTuplePrefix(listenersDb, tuple) {
    const listeners = [];
    // Look for listeners at each prefix of the tuple.
    for (const prefix of iterateTuplePrefixes(tuple)) {
        const results = listenersDb.scan({
            gte: [prefix],
            lte: [[...prefix, types_1.MIN]],
        });
        for (const { value } of results) {
            listeners.push(value);
        }
    }
    return listeners;
}
/** Query the listenersDb based on tuple prefixes, and additionally check for query bounds. */
function getListenerCallbacksForTuple(listenersDb, tuple) {
    const callbacks = [];
    // Check that the tuple is within the absolute bounds of the query.
    for (const listener of getListenersForTuplePrefix(listenersDb, tuple)) {
        const { callback, bounds } = listener;
        if ((0, sortedTupleArray_1.isTupleWithinBounds)(tuple, bounds)) {
            callbacks.push(callback);
        }
        else {
            // TODO: track how in-efficient listeners are here.
            // NOTE: the bounds may only partially span the prefix.
        }
    }
    return callbacks;
}
function getReactivityEmits(listenersDb, writes) {
    const emits = new Map();
    for (const { key, value } of writes.set || []) {
        const callbacks = getListenerCallbacksForTuple(listenersDb, key);
        for (const callback of callbacks) {
            if (!emits.has(callback))
                emits.set(callback, { set: [], remove: [] });
            emits.get(callback).set.push({ key, value });
        }
    }
    for (const tuple of writes.remove || []) {
        const callbacks = getListenerCallbacksForTuple(listenersDb, tuple);
        for (const callback of callbacks) {
            if (!emits.has(callback))
                emits.set(callback, { set: [], remove: [] });
            emits.get(callback).remove.push(tuple);
        }
    }
    return emits;
}
function subscribe(listenersDb, args, callback) {
    // this.log("db/subscribe", args)
    const prefix = (0, sortedTupleArray_1.getPrefixContainingBounds)(args);
    const id = (0, randomId_1.randomId)();
    const value = { callback, bounds: args };
    listenersDb.commit({ set: [{ key: [prefix, id], value }] });
    const unsubscribe = () => {
        // this.log("db/unsubscribe", args)
        listenersDb.commit({ remove: [[prefix, id]] });
    };
    return unsubscribe;
}
//# sourceMappingURL=../../../src/database/sync/ReactivityTracker.js.map