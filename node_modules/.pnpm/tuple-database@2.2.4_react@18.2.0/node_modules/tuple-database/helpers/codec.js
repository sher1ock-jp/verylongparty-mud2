"use strict";
// This codec is should create a component-wise lexicographically sortable array.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeTuple = exports.encodeTuple = exports.decodeValue = exports.encodingTypeOf = exports.encodeValue = exports.encodingRank = exports.encodingByte = void 0;
const elen = __importStar(require("elen"));
const lodash_1 = require("lodash");
const compare_1 = require("./compare");
const Unreachable_1 = require("./Unreachable");
// null < object < array < number < string < boolean
exports.encodingByte = {
    null: "b",
    object: "c",
    array: "d",
    number: "e",
    string: "f",
    boolean: "g",
};
exports.encodingRank = (0, lodash_1.sortBy)(Object.entries(exports.encodingByte), ([key, value]) => value).map(([key]) => key);
function encodeValue(value) {
    if (value === null) {
        return exports.encodingByte.null;
    }
    if (value === true || value === false) {
        return exports.encodingByte.boolean + value;
    }
    if (typeof value === "string") {
        return exports.encodingByte.string + value;
    }
    if (typeof value === "number") {
        return exports.encodingByte.number + elen.encode(value);
    }
    if (Array.isArray(value)) {
        return exports.encodingByte.array + encodeTuple(value);
    }
    if (typeof value === "object") {
        return exports.encodingByte.object + encodeObjectValue(value);
    }
    throw new Unreachable_1.UnreachableError(value, "Unknown value type");
}
exports.encodeValue = encodeValue;
function encodingTypeOf(value) {
    if (value === null) {
        return "null";
    }
    if (value === true || value === false) {
        return "boolean";
    }
    if (typeof value === "string") {
        return "string";
    }
    if (typeof value === "number") {
        return "number";
    }
    if (Array.isArray(value)) {
        return "array";
    }
    if (typeof value === "object") {
        return "object";
    }
    throw new Unreachable_1.UnreachableError(value, "Unknown value type");
}
exports.encodingTypeOf = encodingTypeOf;
const decodeType = (0, lodash_1.invert)(exports.encodingByte);
function decodeValue(str) {
    const encoding = decodeType[str[0]];
    const rest = str.slice(1);
    if (encoding === "null") {
        return null;
    }
    if (encoding === "boolean") {
        return JSON.parse(rest);
    }
    if (encoding === "string") {
        return rest;
    }
    if (encoding === "number") {
        return elen.decode(rest);
    }
    if (encoding === "array") {
        return decodeTuple(rest);
    }
    if (encoding === "object") {
        return decodeObjectValue(rest);
    }
    throw new Unreachable_1.UnreachableError(encoding, "Invalid encoding byte");
}
exports.decodeValue = decodeValue;
function encodeTuple(tuple) {
    return tuple
        .map((value, i) => {
        const encoded = encodeValue(value);
        return (encoded
            // B -> BB or \ -> \\
            .replace(/\x01/g, "\x01\x01")
            // A -> BA or x -> \x
            .replace(/\x00/g, "\x01\x00") + "\x00");
    })
        .join("");
}
exports.encodeTuple = encodeTuple;
function decodeTuple(str) {
    if (str === "") {
        return [];
    }
    // Capture all of the escaped BB and BA pairs and wait
    // til we find an exposed A.
    const re = /(\x01(\x01|\x00)|\x00)/g;
    const tuple = [];
    let start = 0;
    while (true) {
        const match = re.exec(str);
        if (match === null) {
            return tuple;
        }
        if (match[0][0] === "\x01") {
            // If we match a \x01\x01 or \x01\x00 then keep going.
            continue;
        }
        const end = match.index;
        const escaped = str.slice(start, end);
        const unescaped = escaped
            // BB -> B
            .replace(/\x01\x01/g, "\x01")
            // BA -> A
            .replace(/\x01\x00/g, "\x00");
        const decoded = decodeValue(unescaped);
        tuple.push(decoded);
        // Skip over the \x00.
        start = end + 1;
    }
}
exports.decodeTuple = decodeTuple;
function encodeObjectValue(obj) {
    if (!(0, lodash_1.isPlainObject)(obj)) {
        throw new Error("Cannot serialize this object.");
    }
    const entries = Object.entries(obj)
        .sort(([k1], [k2]) => (0, compare_1.compare)(k1, k2))
        // We allow undefined values in objects, but we want to strip them out before
        // serializing.
        .filter(([key, value]) => value !== undefined);
    return encodeTuple(entries);
}
function decodeObjectValue(str) {
    const entries = decodeTuple(str);
    const obj = {};
    for (const [key, value] of entries) {
        obj[key] = value;
    }
    return obj;
}
//# sourceMappingURL=../../src/helpers/codec.js.map