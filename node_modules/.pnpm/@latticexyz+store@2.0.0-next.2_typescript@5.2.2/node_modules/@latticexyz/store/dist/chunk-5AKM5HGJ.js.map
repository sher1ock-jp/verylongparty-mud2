{"version":3,"sources":["../ts/config/defaults.ts","../ts/config/storeConfig.ts"],"sourcesContent":["export const PATH_DEFAULTS = {\n  storeImportPath: \"@latticexyz/store/src/\",\n  userTypesPath: \"Types\",\n  codegenDirectory: \"codegen\",\n} as const;\n\nexport const DEFAULTS = {\n  namespace: \"\",\n  enums: {} as Record<string, never>,\n} as const;\n\nexport const TABLE_DEFAULTS = {\n  directory: \"tables\",\n  keySchema: { key: \"bytes32\" },\n  tableIdArgument: false,\n  storeArgument: true,\n  ephemeral: false,\n} as const;\n","import { AbiType, AbiTypes, StaticAbiType, StaticAbiTypes, StaticArray } from \"@latticexyz/schema-type/deprecated\";\nimport { RefinementCtx, z, ZodIssueCode } from \"zod\";\nimport type {\n  AsDependent,\n  ExtractUserTypes,\n  OrDefaults,\n  RequireKeys,\n  StringForUnion,\n} from \"@latticexyz/common/type-utils\";\nimport {\n  // validation utils\n  getDuplicates,\n  parseStaticArray,\n  STORE_SELECTOR_MAX_LENGTH,\n  // config\n  MUDCoreUserConfig,\n  // schemas\n  zObjectName,\n  zSelector,\n  zUserEnum,\n  zValueName,\n} from \"@latticexyz/config\";\nimport { DEFAULTS, PATH_DEFAULTS, TABLE_DEFAULTS } from \"./defaults\";\n\nconst zTableName = zObjectName;\nconst zKeyName = zValueName;\nconst zColumnName = zValueName;\nconst zUserEnumName = zObjectName;\n\n// Fields can use AbiType or one of user-defined wrapper types\n// (user types are refined later, based on the appropriate config options)\nconst zFieldData = z.string();\n\nexport type FieldData<UserTypes extends StringForUnion> = AbiType | StaticArray | UserTypes;\n\n// Primary keys allow only static types\n// (user types are refined later, based on the appropriate config options)\nconst zKeyElementSchema = z.string();\nconst zKeySchema = z.record(zKeyName, zKeyElementSchema).default(TABLE_DEFAULTS.keySchema);\n\ntype KeySchema<StaticUserTypes extends StringForUnion> = StaticAbiType | StaticUserTypes;\n\n/************************************************************************\n *\n *    TABLE SCHEMA\n *\n ************************************************************************/\n\nexport type FullSchemaConfig<UserTypes extends StringForUnion = StringForUnion> = Record<string, FieldData<UserTypes>>;\nexport type ShorthandSchemaConfig<UserTypes extends StringForUnion = StringForUnion> = FieldData<UserTypes>;\nexport type SchemaConfig<UserTypes extends StringForUnion = StringForUnion> =\n  | FullSchemaConfig<UserTypes>\n  | ShorthandSchemaConfig<UserTypes>;\n\nexport type ExpandSchemaConfig<TSchemaConfig extends SchemaConfig<string>> =\n  TSchemaConfig extends ShorthandSchemaConfig<string> ? { value: TSchemaConfig } : TSchemaConfig;\n\nconst zFullSchemaConfig = z\n  .record(zColumnName, zFieldData)\n  .refine((arg) => Object.keys(arg).length > 0, \"Table schema may not be empty\");\n\nconst zShorthandSchemaConfig = zFieldData.transform((fieldData) => {\n  return zFullSchemaConfig.parse({\n    value: fieldData,\n  });\n});\n\nexport const zSchemaConfig = zFullSchemaConfig.or(zShorthandSchemaConfig);\n\n/************************************************************************\n *\n *    TABLE\n *\n ************************************************************************/\n\nexport interface TableConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> {\n  /** Output directory path for the file. Default is \"tables\" */\n  directory?: string;\n  /** Make methods accept `tableId` argument instead of it being a hardcoded constant. Default is false */\n  tableIdArgument?: boolean;\n  /** Include methods that accept a manual `IStore` argument. Default is true. */\n  storeArgument?: boolean;\n  /** Include a data struct and methods for it. Default is false for 1-column tables; true for multi-column tables. */\n  dataStruct?: boolean;\n  /** Generate only `emitEphemeral` which emits an event without writing to storage. Default is false. */\n  ephemeral?: boolean;\n  /** Table's key schema names mapped to their types. Default is `{ key: \"bytes32\" }` */\n  keySchema?: Record<string, KeySchema<StaticUserTypes>>;\n  /** Table's column names mapped to their types. Table name's 1st letter should be lowercase. */\n  schema: SchemaConfig<UserTypes>;\n}\n\nexport type FullTableConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> = Required<TableConfig<UserTypes, StaticUserTypes>> & {\n  schema: FullSchemaConfig<UserTypes>;\n};\n\nexport interface ExpandTableConfig<T extends TableConfig<string, string>, TableName extends string>\n  extends OrDefaults<\n    T,\n    {\n      directory: typeof TABLE_DEFAULTS.directory;\n      name: TableName;\n      tableIdArgument: typeof TABLE_DEFAULTS.tableIdArgument;\n      storeArgument: typeof TABLE_DEFAULTS.storeArgument;\n      // dataStruct isn't expanded, because its value is conditional on the number of schema fields\n      dataStruct: boolean;\n      keySchema: typeof TABLE_DEFAULTS.keySchema;\n      ephemeral: typeof TABLE_DEFAULTS.ephemeral;\n    }\n  > {\n  schema: ExpandSchemaConfig<T[\"schema\"]>;\n}\n\nconst zFullTableConfig = z\n  .object({\n    directory: z.string().default(TABLE_DEFAULTS.directory),\n    name: zSelector.optional(),\n    tableIdArgument: z.boolean().default(TABLE_DEFAULTS.tableIdArgument),\n    storeArgument: z.boolean().default(TABLE_DEFAULTS.storeArgument),\n    dataStruct: z.boolean().optional(),\n    keySchema: zKeySchema,\n    schema: zSchemaConfig,\n    ephemeral: z.boolean().default(TABLE_DEFAULTS.ephemeral),\n  })\n  .transform((arg) => {\n    // default dataStruct value depends on schema's length\n    if (Object.keys(arg.schema).length === 1) {\n      arg.dataStruct ??= false;\n    } else {\n      arg.dataStruct ??= true;\n    }\n    return arg as RequireKeys<typeof arg, \"dataStruct\">;\n  });\n\nconst zShorthandTableConfig = zFieldData.transform((fieldData) => {\n  return zFullTableConfig.parse({\n    schema: {\n      value: fieldData,\n    },\n  });\n});\n\nexport const zTableConfig = zFullTableConfig.or(zShorthandTableConfig);\n\n/************************************************************************\n *\n *    TABLES\n *\n ************************************************************************/\n\nexport type TablesConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> = Record<string, TableConfig<UserTypes, StaticUserTypes> | FieldData<UserTypes>>;\n\nexport const zTablesConfig = z.record(zTableName, zTableConfig).transform((tables) => {\n  // default name depends on tableName\n  for (const tableName of Object.keys(tables)) {\n    const table = tables[tableName];\n    table.name = tableName.slice(0, STORE_SELECTOR_MAX_LENGTH);\n\n    tables[tableName] = table;\n  }\n  return tables as Record<string, RequireKeys<(typeof tables)[string], \"name\">>;\n});\n\nexport type FullTablesConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> = Record<string, FullTableConfig<UserTypes, StaticUserTypes>>;\n\nexport type ExpandTablesConfig<T extends TablesConfig<string, string>> = {\n  [TableName in keyof T]: T[TableName] extends FieldData<string>\n    ? ExpandTableConfig<{ schema: { value: T[TableName] } }, TableName extends string ? TableName : never>\n    : T[TableName] extends TableConfig<string, string>\n    ? ExpandTableConfig<T[TableName], TableName extends string ? TableName : never>\n    : // Weakly typed values get a weakly typed expansion.\n      // This shouldn't normally happen within `mudConfig`, but can be manually triggered via `ExpandMUDUserConfig`\n      ExpandTableConfig<TableConfig<string, string>, TableName extends string ? TableName : string>;\n};\n\n/************************************************************************\n *\n *    USER TYPES\n *\n ************************************************************************/\n\nexport type EnumsConfig<EnumNames extends StringForUnion> = never extends EnumNames\n  ? {\n      /**\n       * Enum names mapped to lists of their member names\n       *\n       * (enums are inferred to be absent)\n       */\n      enums?: Record<EnumNames, string[]>;\n    }\n  : StringForUnion extends EnumNames\n  ? {\n      /**\n       * Enum names mapped to lists of their member names\n       *\n       * (enums aren't inferred - use `mudConfig` or `storeConfig` helper, and `as const` for variables)\n       */\n      enums?: Record<EnumNames, string[]>;\n    }\n  : {\n      /**\n       * Enum names mapped to lists of their member names\n       *\n       * Enums defined here can be used as types in table schemas/keys\n       */\n      enums: Record<EnumNames, string[]>;\n    };\n\nexport type FullEnumsConfig<EnumNames extends StringForUnion> = {\n  enums: Record<EnumNames, string[]>;\n};\n\nexport const zEnumsConfig = z.object({\n  enums: z.record(zUserEnumName, zUserEnum).default(DEFAULTS.enums),\n});\n\n/************************************************************************\n *\n *    FINAL\n *\n ************************************************************************/\n\n// zod doesn't preserve doc comments\n/** MUDCoreUserConfig wrapper to use generics in some options for better type inference */\nexport type MUDUserConfig<\n  T extends MUDCoreUserConfig = MUDCoreUserConfig,\n  EnumNames extends StringForUnion = StringForUnion,\n  StaticUserTypes extends ExtractUserTypes<EnumNames> = ExtractUserTypes<EnumNames>\n> = T &\n  EnumsConfig<EnumNames> & {\n    /**\n     * Configuration for each table.\n     *\n     * The key is the table name (capitalized).\n     *\n     * The value:\n     *  - abi or user type for a single-value table.\n     *  - FullTableConfig object for multi-value tables (or for customizable options).\n     */\n    tables: TablesConfig<AsDependent<StaticUserTypes>, AsDependent<StaticUserTypes>>;\n    /** The namespace for table ids. Default is \"\" (ROOT) */\n    namespace?: string;\n    /** Path for store package imports. Default is \"@latticexyz/store/src/\" */\n    storeImportPath?: string;\n    /** Path to the file where common user types will be generated and imported from. Default is \"Types\" */\n    userTypesPath?: string;\n    /** Path to the directory where generated files will be placed. (Default is \"codegen\") */\n    codegenDirectory?: string;\n  };\n\nconst StoreConfigUnrefined = z\n  .object({\n    namespace: zSelector.default(DEFAULTS.namespace),\n    storeImportPath: z.string().default(PATH_DEFAULTS.storeImportPath),\n    tables: zTablesConfig,\n    userTypesPath: z.string().default(PATH_DEFAULTS.userTypesPath),\n    codegenDirectory: z.string().default(PATH_DEFAULTS.codegenDirectory),\n  })\n  .merge(zEnumsConfig);\n\n// finally validate global conditions\nexport const zStoreConfig = StoreConfigUnrefined.superRefine(validateStoreConfig);\n\nexport type StoreUserConfig = z.input<typeof zStoreConfig>;\nexport type StoreConfig = z.output<typeof zStoreConfig>;\n\n// Catchall preserves other plugins' options\nexport const zPluginStoreConfig = StoreConfigUnrefined.catchall(z.any()).superRefine(validateStoreConfig);\n\n/************************************************************************\n *\n *    HELPERS\n *\n ************************************************************************/\n\n// Validate conditions that check multiple different config options simultaneously\nfunction validateStoreConfig(config: z.output<typeof StoreConfigUnrefined>, ctx: RefinementCtx) {\n  // Local table variables must be unique within the table\n  for (const table of Object.values(config.tables)) {\n    const keySchemaNames = Object.keys(table.keySchema);\n    const fieldNames = Object.keys(table.schema);\n    const duplicateVariableNames = getDuplicates([...keySchemaNames, ...fieldNames]);\n    if (duplicateVariableNames.length > 0) {\n      ctx.addIssue({\n        code: ZodIssueCode.custom,\n        message: `Field and key names within one table must be unique: ${duplicateVariableNames.join(\", \")}`,\n      });\n    }\n  }\n  // Global names must be unique\n  const tableLibraryNames = Object.keys(config.tables);\n  const staticUserTypeNames = Object.keys(config.enums);\n  const userTypeNames = staticUserTypeNames;\n  const globalNames = [...tableLibraryNames, ...userTypeNames];\n  const duplicateGlobalNames = getDuplicates(globalNames);\n  if (duplicateGlobalNames.length > 0) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Table library names, enum names must be globally unique: ${duplicateGlobalNames.join(\", \")}`,\n    });\n  }\n  // Table names used for tableId must be unique\n  const tableNames = Object.values(config.tables).map(({ name }) => name);\n  const duplicateTableNames = getDuplicates(tableNames);\n  if (duplicateTableNames.length > 0) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Table names must be unique: ${duplicateTableNames.join(\", \")}`,\n    });\n  }\n  // User types must exist\n  for (const table of Object.values(config.tables)) {\n    for (const keySchemaType of Object.values(table.keySchema)) {\n      validateStaticAbiOrUserType(staticUserTypeNames, keySchemaType, ctx);\n    }\n    for (const fieldType of Object.values(table.schema)) {\n      validateAbiOrUserType(userTypeNames, staticUserTypeNames, fieldType, ctx);\n    }\n  }\n}\n\nfunction validateAbiOrUserType(\n  userTypeNames: string[],\n  staticUserTypeNames: string[],\n  type: string,\n  ctx: RefinementCtx\n) {\n  if (!(AbiTypes as string[]).includes(type) && !userTypeNames.includes(type)) {\n    const staticArray = parseStaticArray(type);\n    if (staticArray) {\n      validateStaticArray(staticUserTypeNames, staticArray.elementType, staticArray.staticLength, ctx);\n    } else {\n      ctx.addIssue({\n        code: ZodIssueCode.custom,\n        message: `${type} is not a valid abi type, and is not defined in userTypes`,\n      });\n    }\n  }\n}\n\nfunction validateStaticAbiOrUserType(staticUserTypeNames: string[], type: string, ctx: RefinementCtx) {\n  if (!(StaticAbiTypes as string[]).includes(type) && !staticUserTypeNames.includes(type)) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `${type} is not a static type`,\n    });\n  }\n}\n\nfunction validateStaticArray(\n  staticUserTypeNames: string[],\n  elementType: string,\n  staticLength: number,\n  ctx: RefinementCtx\n) {\n  validateStaticAbiOrUserType(staticUserTypeNames, elementType, ctx);\n\n  if (staticLength === 0) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Static array length must not be 0`,\n    });\n  } else if (staticLength >= 2 ** 16) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Static array length must be less than 2**16`,\n    });\n  }\n}\n"],"mappings":"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","names":["PATH_DEFAULTS","DEFAULTS","TABLE_DEFAULTS","AbiTypes","StaticAbiTypes","z","ZodIssueCode","getDuplicates","parseStaticArray","STORE_SELECTOR_MAX_LENGTH","zObjectName","zSelector","zUserEnum","zValueName","zTableName","zObjectName","zKeyName","zValueName","zColumnName","zUserEnumName","zFieldData","z","zKeyElementSchema","zKeySchema","TABLE_DEFAULTS","zFullSchemaConfig","arg","zShorthandSchemaConfig","fieldData","zSchemaConfig","zFullTableConfig","zSelector","zShorthandTableConfig","zTableConfig","zTablesConfig","tables","tableName","table","STORE_SELECTOR_MAX_LENGTH","zEnumsConfig","zUserEnum","DEFAULTS","StoreConfigUnrefined","PATH_DEFAULTS","zStoreConfig","validateStoreConfig","zPluginStoreConfig","config","ctx","keySchemaNames","fieldNames","duplicateVariableNames","getDuplicates","ZodIssueCode","tableLibraryNames","staticUserTypeNames","userTypeNames","globalNames","duplicateGlobalNames","tableNames","name","duplicateTableNames","keySchemaType","validateStaticAbiOrUserType","fieldType","validateAbiOrUserType","type","AbiTypes","staticArray","parseStaticArray","validateStaticArray","StaticAbiTypes","elementType","staticLength"]}