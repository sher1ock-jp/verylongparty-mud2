{"version":3,"sources":["../../../ts/codegen/field.ts","../../../ts/codegen/record.ts","../../../ts/codegen/renderTable.ts","../../../ts/codegen/ephemeral.ts","../../../ts/codegen/renderTypesFromConfig.ts","../../../ts/codegen/tablegen.ts","../../../ts/codegen/tableOptions.ts","../../../ts/codegen/userType.ts","../../../ts/codegen/renderTableIndex.ts","../../../ts/codegen/tightcoder/renderDecodeSlice.ts","../../../ts/codegen/tightcoder/renderFunctions.ts","../../../ts/codegen/tightcoder/renderEncodeArray.ts","../../../ts/codegen/tightcoder/renderTightCoderAutoTest.ts"],"sourcesContent":["import {\n  renderArguments,\n  renderCommonData,\n  RenderField,\n  RenderType,\n  renderWithStore,\n} from \"@latticexyz/common/codegen\";\nimport { RenderTableOptions } from \"./types\";\n\nexport function renderFieldMethods(options: RenderTableOptions) {\n  const storeArgument = options.storeArgument;\n  const { _typedTableId, _typedKeyArgs, _keyTupleDefinition } = renderCommonData(options);\n\n  let result = \"\";\n  for (const [schemaIndex, field] of options.fields.entries()) {\n    const _typedFieldName = `${field.typeWithLocation} ${field.name}`;\n\n    result += renderWithStore(\n      storeArgument,\n      (_typedStore, _store, _commentSuffix) => `\n      /** Get ${field.name}${_commentSuffix} */\n      function get${field.methodNameSuffix}(${renderArguments([\n        _typedStore,\n        _typedTableId,\n        _typedKeyArgs,\n      ])}) internal view returns (${_typedFieldName}) {\n        ${_keyTupleDefinition}\n        bytes memory _blob = ${_store}.getField(_tableId, _keyTuple, ${schemaIndex});\n        return ${renderDecodeFieldSingle(field)};\n      }\n    `\n    );\n\n    result += renderWithStore(\n      storeArgument,\n      (_typedStore, _store, _commentSuffix) => `\n      /** Set ${field.name}${_commentSuffix} */\n      function set${field.methodNameSuffix}(${renderArguments([\n        _typedStore,\n        _typedTableId,\n        _typedKeyArgs,\n        _typedFieldName,\n      ])}) internal {\n        ${_keyTupleDefinition}\n        ${_store}.setField(_tableId, _keyTuple, ${schemaIndex}, ${renderEncodeFieldSingle(field)});\n      }\n    `\n    );\n\n    if (field.isDynamic) {\n      const portionData = fieldPortionData(field);\n\n      result += renderWithStore(\n        storeArgument,\n        (_typedStore, _store, _commentSuffix) => `\n        /** Get the length of ${field.name}${_commentSuffix} */\n        function length${field.methodNameSuffix}(${renderArguments([\n          _typedStore,\n          _typedTableId,\n          _typedKeyArgs,\n        ])}) internal view returns (uint256) {\n          ${_keyTupleDefinition}\n          uint256 _byteLength = ${_store}.getFieldLength(_tableId, _keyTuple, ${schemaIndex}, getSchema());\n          return _byteLength / ${portionData.elementLength};\n        }\n      `\n      );\n\n      result += renderWithStore(\n        storeArgument,\n        (_typedStore, _store, _commentSuffix) => `\n        /** Get an item of ${field.name}${_commentSuffix} (unchecked, returns invalid data if index overflows) */\n        function getItem${field.methodNameSuffix}(${renderArguments([\n          _typedStore,\n          _typedTableId,\n          _typedKeyArgs,\n          \"uint256 _index\",\n        ])}) internal view returns (${portionData.typeWithLocation}) {\n          ${_keyTupleDefinition}\n          bytes memory _blob = ${_store}.getFieldSlice(\n            _tableId,\n            _keyTuple,\n            ${schemaIndex},\n            getSchema(),\n            _index * ${portionData.elementLength},\n            (_index + 1) * ${portionData.elementLength}\n          );\n          return ${portionData.decoded};\n        }\n      `\n      );\n\n      result += renderWithStore(\n        storeArgument,\n        (_typedStore, _store, _commentSuffix) => `\n        /** Push ${portionData.title} to ${field.name}${_commentSuffix} */\n        function push${field.methodNameSuffix}(${renderArguments([\n          _typedStore,\n          _typedTableId,\n          _typedKeyArgs,\n          `${portionData.typeWithLocation} ${portionData.name}`,\n        ])}) internal {\n          ${_keyTupleDefinition}\n          ${_store}.pushToField(_tableId, _keyTuple, ${schemaIndex}, ${portionData.encoded});\n        }\n      `\n      );\n\n      result += renderWithStore(\n        storeArgument,\n        (_typedStore, _store, _commentSuffix) => `\n        /** Pop ${portionData.title} from ${field.name}${_commentSuffix} */\n        function pop${field.methodNameSuffix}(${renderArguments([\n          _typedStore,\n          _typedTableId,\n          _typedKeyArgs,\n        ])}) internal {\n          ${_keyTupleDefinition}\n          ${_store}.popFromField(_tableId, _keyTuple, ${schemaIndex}, ${portionData.elementLength});\n        }\n      `\n      );\n\n      result += renderWithStore(\n        storeArgument,\n        (_typedStore, _store, _commentSuffix) => `\n        /** Update ${portionData.title} of ${field.name}${_commentSuffix} at \\`_index\\` */\n        function update${field.methodNameSuffix}(${renderArguments([\n          _typedStore,\n          _typedTableId,\n          _typedKeyArgs,\n          \"uint256 _index\",\n          `${portionData.typeWithLocation} ${portionData.name}`,\n        ])}) internal {\n          ${_keyTupleDefinition}\n          ${_store}.updateInField(\n            _tableId,\n            _keyTuple,\n            ${schemaIndex},\n            _index * ${portionData.elementLength},\n            ${portionData.encoded}\n          );\n        }\n      `\n      );\n    }\n  }\n  return result;\n}\n\nexport function renderEncodeFieldSingle(field: RenderField) {\n  let func;\n  if (field.arrayElement) {\n    func = \"EncodeArray.encode\";\n  } else if (field.isDynamic) {\n    func = \"bytes\";\n  } else {\n    func = \"abi.encodePacked\";\n  }\n  return `${func}(${field.typeUnwrap}(${field.name}))`;\n}\n\nexport function renderDecodeValueType(field: RenderType, offset: number) {\n  const { staticByteLength, internalTypeId } = field;\n\n  const innerSlice = `Bytes.slice${staticByteLength}(_blob, ${offset})`;\n  const bits = staticByteLength * 8;\n\n  let result;\n  if (internalTypeId.match(/^uint\\d{1,3}$/) || internalTypeId === \"address\") {\n    result = `${internalTypeId}(${innerSlice})`;\n  } else if (internalTypeId.match(/^int\\d{1,3}$/)) {\n    result = `${internalTypeId}(uint${bits}(${innerSlice}))`;\n  } else if (internalTypeId.match(/^bytes\\d{1,2}$/)) {\n    result = innerSlice;\n  } else if (internalTypeId === \"bool\") {\n    result = `_toBool(uint8(${innerSlice}))`;\n  } else {\n    throw new Error(`Unknown value type id ${internalTypeId}`);\n  }\n  return `${field.typeWrap}(${result})`;\n}\n\n/** bytes/string are dynamic, but aren't really arrays */\nfunction fieldPortionData(field: RenderField) {\n  const methodNameSuffix = \"\";\n  if (field.arrayElement) {\n    const name = \"_element\";\n    const elementFieldData = { ...field.arrayElement, arrayElement: undefined, name, methodNameSuffix };\n    return {\n      typeWithLocation: field.arrayElement.typeWithLocation,\n      name: \"_element\",\n      encoded: renderEncodeFieldSingle(elementFieldData),\n      decoded: renderDecodeFieldSingle(elementFieldData),\n      title: \"an element\",\n      elementLength: field.arrayElement.staticByteLength,\n    };\n  } else {\n    const name = \"_slice\";\n    const elementFieldData = { ...field, name, methodNameSuffix };\n    return {\n      typeWithLocation: `${field.typeId} memory`,\n      name,\n      encoded: renderEncodeFieldSingle(elementFieldData),\n      decoded: renderDecodeFieldSingle(elementFieldData),\n      title: \"a slice\",\n      elementLength: 1,\n    };\n  }\n}\n\nfunction renderDecodeFieldSingle(field: RenderField) {\n  const { isDynamic, arrayElement } = field;\n  if (arrayElement) {\n    // arrays\n    return `${field.typeWrap}(\n      SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_${arrayElement.internalTypeId}()\n    )`;\n  } else if (isDynamic) {\n    // bytes/string\n    return `${field.typeWrap}(${field.internalTypeId}(_blob))`;\n  } else {\n    return renderDecodeValueType(field, 0);\n  }\n}\n","import {\n  renderList,\n  renderArguments,\n  renderCommonData,\n  renderWithStore,\n  RenderDynamicField,\n} from \"@latticexyz/common/codegen\";\nimport { renderDecodeValueType } from \"./field\";\nimport { RenderTableOptions } from \"./types\";\n\nexport function renderRecordMethods(options: RenderTableOptions) {\n  const { structName, storeArgument } = options;\n  const { _tableId, _typedTableId, _keyArgs, _typedKeyArgs, _keyTupleDefinition } = renderCommonData(options);\n\n  let result = renderWithStore(\n    storeArgument,\n    (_typedStore, _store, _commentSuffix) => `\n    /** Get the full data${_commentSuffix} */\n    function get(${renderArguments([\n      _typedStore,\n      _typedTableId,\n      _typedKeyArgs,\n    ])}) internal view returns (${renderDecodedRecord(options)}) {\n      ${_keyTupleDefinition}\n      bytes memory _blob = ${_store}.getRecord(_tableId, _keyTuple, getSchema());\n      return decode(_blob);\n    }\n  `\n  );\n\n  result += renderWithStore(\n    storeArgument,\n    (_typedStore, _store, _commentSuffix) => `\n    /** Set the full data using individual values${_commentSuffix} */\n    function set(${renderArguments([\n      _typedStore,\n      _typedTableId,\n      _typedKeyArgs,\n      renderArguments(options.fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)),\n    ])}) internal {\n      bytes memory _data = encode(${renderArguments(options.fields.map(({ name }) => name))});\n\n      ${_keyTupleDefinition}\n\n      ${_store}.setRecord(_tableId, _keyTuple, _data);\n    }\n  `\n  );\n\n  if (structName !== undefined) {\n    result += renderWithStore(\n      storeArgument,\n      (_typedStore, _store, _commentSuffix, _untypedStore) => `\n      /** Set the full data using the data struct${_commentSuffix} */\n      function set(${renderArguments([\n        _typedStore,\n        _typedTableId,\n        _typedKeyArgs,\n        `${structName} memory _table`,\n      ])}) internal {\n        set(${renderArguments([\n          _untypedStore,\n          _tableId,\n          _keyArgs,\n          renderArguments(options.fields.map(({ name }) => `_table.${name}`)),\n        ])});\n      }\n    `\n    );\n  }\n\n  result += renderDecodeFunction(options);\n\n  return result;\n}\n\n// Renders the `decode` function that parses a bytes blob into the table data\nfunction renderDecodeFunction({ structName, fields, staticFields, dynamicFields }: RenderTableOptions) {\n  // either set struct properties, or just variables\n  const renderedDecodedRecord = structName\n    ? `${structName} memory _table`\n    : renderArguments(fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));\n  const fieldNamePrefix = structName ? \"_table.\" : \"\";\n\n  // Static field offsets\n  const staticOffsets = staticFields.map(() => 0);\n  let _acc = 0;\n  for (const [index, field] of staticFields.entries()) {\n    staticOffsets[index] = _acc;\n    _acc += field.staticByteLength;\n  }\n\n  if (dynamicFields.length > 0) {\n    const totalStaticLength = staticFields.reduce((acc, { staticByteLength }) => acc + staticByteLength, 0);\n    // decode static (optionally) and dynamic data\n    return `\n    /** Decode the tightly packed blob using this table's schema */\n    function decode(bytes memory _blob) internal pure returns (${renderedDecodedRecord}) {\n      // ${totalStaticLength} is the total byte length of static data\n      PackedCounter _encodedLengths = PackedCounter.wrap(Bytes.slice32(_blob, ${totalStaticLength})); \n\n      ${renderList(\n        staticFields,\n        (field, index) => `\n        ${fieldNamePrefix}${field.name} = ${renderDecodeValueType(field, staticOffsets[index])};\n        `\n      )}\n      // Store trims the blob if dynamic fields are all empty\n      if (_blob.length > ${totalStaticLength}) {\n        uint256 _start;\n        // skip static data length + dynamic lengths word\n        uint256 _end = ${totalStaticLength + 32};\n        ${renderList(\n          dynamicFields,\n          (field, index) => `\n          _start = _end;\n          _end += _encodedLengths.atIndex(${index});\n          ${fieldNamePrefix}${field.name} = ${renderDecodeDynamicFieldPartial(field)};\n          `\n        )}\n      }\n    }\n  `;\n  } else {\n    // decode only static data\n    return `\n    /** Decode the tightly packed blob using this table's schema */\n    function decode(bytes memory _blob) internal pure returns (${renderedDecodedRecord}) {\n      ${renderList(\n        staticFields,\n        (field, index) => `\n        ${fieldNamePrefix}${field.name} = ${renderDecodeValueType(field, staticOffsets[index])};\n        `\n      )}\n    }\n    `;\n  }\n}\n\n// contents of `returns (...)` for record getter/decoder\nfunction renderDecodedRecord({ structName, fields }: RenderTableOptions) {\n  if (structName) {\n    return `${structName} memory _table`;\n  } else {\n    return renderArguments(fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));\n  }\n}\n\nfunction renderDecodeDynamicFieldPartial(field: RenderDynamicField) {\n  const { typeId, arrayElement, typeWrap } = field;\n  if (arrayElement) {\n    // arrays\n    return `${typeWrap}(\n      SliceLib.getSubslice(_blob, _start, _end).decodeArray_${arrayElement.typeId}()\n    )`;\n  } else {\n    // bytes/string\n    return `${typeWrap}(\n      ${typeId}(\n        SliceLib.getSubslice(_blob, _start, _end).toBytes()\n      )\n    )`;\n  }\n}\n","import {\n  renderArguments,\n  renderCommonData,\n  renderList,\n  renderedSolidityHeader,\n  renderRelativeImports,\n  renderTableId,\n  renderValueTypeToBytes32,\n  renderWithStore,\n  renderTypeHelpers,\n  RenderDynamicField,\n} from \"@latticexyz/common/codegen\";\nimport { renderEphemeralMethods } from \"./ephemeral\";\nimport { renderEncodeFieldSingle, renderFieldMethods } from \"./field\";\nimport { renderRecordMethods } from \"./record\";\nimport { RenderTableOptions } from \"./types\";\n\nexport function renderTable(options: RenderTableOptions) {\n  const {\n    imports,\n    libraryName,\n    structName,\n    staticResourceData,\n    storeImportPath,\n    fields,\n    staticFields,\n    dynamicFields,\n    withFieldMethods,\n    withRecordMethods,\n    withEphemeralMethods,\n    storeArgument,\n    keyTuple,\n  } = options;\n\n  const { _typedTableId, _typedKeyArgs, _keyTupleDefinition } = renderCommonData(options);\n  const shouldRenderDelete = !withEphemeralMethods;\n\n  return `${renderedSolidityHeader}\n\n// Import schema type\nimport { SchemaType } from \"@latticexyz/schema-type/src/solidity/SchemaType.sol\";\n\n// Import store internals\nimport { IStore } from \"${storeImportPath}IStore.sol\";\nimport { StoreSwitch } from \"${storeImportPath}StoreSwitch.sol\";\nimport { StoreCore } from \"${storeImportPath}StoreCore.sol\";\nimport { Bytes } from \"${storeImportPath}Bytes.sol\";\nimport { Memory } from \"${storeImportPath}Memory.sol\";\nimport { SliceLib } from \"${storeImportPath}Slice.sol\";\nimport { EncodeArray } from \"${storeImportPath}tightcoder/EncodeArray.sol\";\nimport { Schema, SchemaLib } from \"${storeImportPath}Schema.sol\";\nimport { PackedCounter, PackedCounterLib } from \"${storeImportPath}PackedCounter.sol\";\n\n${\n  imports.length > 0\n    ? `\n      // Import user types\n      ${renderRelativeImports(imports)}\n    `\n    : \"\"\n}\n\n${staticResourceData ? renderTableId(staticResourceData).tableIdDefinition : \"\"}\n\n${\n  !structName\n    ? \"\"\n    : `\n      struct ${structName} {\n        ${renderList(fields, ({ name, typeId }) => `${typeId} ${name};`)}\n      }\n`\n}\n\nlibrary ${libraryName} {\n  /** Get the table's schema */\n  function getSchema() internal pure returns (Schema) {\n    SchemaType[] memory _schema = new SchemaType[](${fields.length});\n    ${renderList(fields, ({ enumName }, index) => `_schema[${index}] = SchemaType.${enumName};`)}\n\n    return SchemaLib.encode(_schema);\n  }\n\n  function getKeySchema() internal pure returns (Schema) {\n    SchemaType[] memory _schema = new SchemaType[](${keyTuple.length});\n    ${renderList(keyTuple, ({ enumName }, index) => `_schema[${index}] = SchemaType.${enumName};`)}\n\n    return SchemaLib.encode(_schema);\n  }\n\n  /** Get the table's metadata */\n  function getMetadata() internal pure returns (string memory, string[] memory) {\n    string[] memory _fieldNames = new string[](${fields.length});\n    ${renderList(fields, (field, index) => `_fieldNames[${index}] = \"${field.name}\";`)}\n    return (\"${libraryName}\", _fieldNames);\n  }\n\n  ${renderWithStore(\n    storeArgument,\n    (_typedStore, _store, _commentSuffix) => `\n    /** Register the table's schema${_commentSuffix} */\n    function registerSchema(${renderArguments([_typedStore, _typedTableId])}) internal {\n      ${_store}.registerSchema(_tableId, getSchema(), getKeySchema());\n    }\n  `\n  )}\n  ${renderWithStore(\n    storeArgument,\n    (_typedStore, _store, _commentSuffix) => `\n    /** Set the table's metadata${_commentSuffix} */\n    function setMetadata(${renderArguments([_typedStore, _typedTableId])}) internal {\n      (string memory _tableName, string[] memory _fieldNames) = getMetadata();\n      ${_store}.setMetadata(_tableId, _tableName, _fieldNames);\n    }\n  `\n  )}\n\n  ${withFieldMethods ? renderFieldMethods(options) : \"\"}\n\n  ${withRecordMethods ? renderRecordMethods(options) : \"\"}\n\n  ${withEphemeralMethods ? renderEphemeralMethods(options) : \"\"}\n\n  /** Tightly pack full data using this table's schema */\n  function encode(${renderArguments(\n    options.fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)\n  )}) internal pure returns (bytes memory) {\n    ${renderEncodedLengths(dynamicFields)}\n    return abi.encodePacked(${renderArguments([\n      renderArguments(staticFields.map(({ name }) => name)),\n      ...(dynamicFields.length === 0\n        ? []\n        : [\"_encodedLengths.unwrap()\", renderArguments(dynamicFields.map((field) => renderEncodeFieldSingle(field)))]),\n    ])});\n  }\n  \n  /** Encode keys as a bytes32 array using this table's schema */\n  function encodeKeyTuple(${renderArguments([_typedKeyArgs])}) internal pure returns (bytes32[] memory _keyTuple) {\n    _keyTuple = new bytes32[](${keyTuple.length});\n    ${renderList(keyTuple, (key, index) => `_keyTuple[${index}] = ${renderValueTypeToBytes32(key.name, key)};`)}\n  }\n\n  ${\n    shouldRenderDelete\n      ? renderWithStore(\n          storeArgument,\n          (_typedStore, _store, _commentSuffix) => `\n    /* Delete all data for given keys${_commentSuffix} */\n    function deleteRecord(${renderArguments([_typedStore, _typedTableId, _typedKeyArgs])}) internal {\n      ${_keyTupleDefinition}\n      ${_store}.deleteRecord(_tableId, _keyTuple);\n    }\n  `\n        )\n      : \"\"\n  }\n}\n\n${renderTypeHelpers(options)}\n\n`;\n}\n\nfunction renderEncodedLengths(dynamicFields: RenderDynamicField[]) {\n  if (dynamicFields.length > 0) {\n    return `\n    uint40[] memory _counters = new uint40[](${dynamicFields.length});\n    ${renderList(dynamicFields, ({ name, arrayElement }, index) => {\n      if (arrayElement) {\n        return `_counters[${index}] = uint40(${name}.length * ${arrayElement.staticByteLength});`;\n      } else {\n        return `_counters[${index}] = uint40(bytes(${name}).length);`;\n      }\n    })}\n    PackedCounter _encodedLengths = PackedCounterLib.pack(_counters);\n    `;\n  } else {\n    return \"\";\n  }\n}\n","import { renderArguments, renderCommonData, renderWithStore } from \"@latticexyz/common/codegen\";\nimport { RenderTableOptions } from \"./types\";\n\nexport function renderEphemeralMethods(options: RenderTableOptions) {\n  const { structName, storeArgument } = options;\n  const { _tableId, _typedTableId, _keyArgs, _typedKeyArgs, _keyTupleDefinition } = renderCommonData(options);\n\n  let result = renderWithStore(\n    storeArgument,\n    (_typedStore, _store, _commentSuffix) => `\n    /** Emit the ephemeral event using individual values${_commentSuffix} */\n    function emitEphemeral(${renderArguments([\n      _typedStore,\n      _typedTableId,\n      _typedKeyArgs,\n      renderArguments(options.fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)),\n    ])}) internal {\n      bytes memory _data = encode(${renderArguments(options.fields.map(({ name }) => name))});\n\n      ${_keyTupleDefinition}\n\n      ${_store}.emitEphemeralRecord(_tableId, _keyTuple, _data);\n    }\n  `\n  );\n\n  if (structName !== undefined) {\n    result += renderWithStore(\n      storeArgument,\n      (_typedStore, _store, _commentSuffix, _untypedStore) => `\n      /** Emit the ephemeral event using the data struct${_commentSuffix} */\n      function emitEphemeral(${renderArguments([\n        _typedStore,\n        _typedTableId,\n        _typedKeyArgs,\n        `${structName} memory _table`,\n      ])}) internal {\n        emitEphemeral(${renderArguments([\n          _untypedStore,\n          _tableId,\n          _keyArgs,\n          renderArguments(options.fields.map(({ name }) => `_table.${name}`)),\n        ])});\n      }\n    `\n    );\n  }\n\n  return result;\n}\n","import { renderEnums } from \"@latticexyz/common/codegen\";\nimport { StoreConfig } from \"../config\";\n\nexport function renderTypesFromConfig(config: StoreConfig) {\n  const enums = Object.keys(config.enums).map((name) => ({\n    name,\n    memberNames: config.enums[name],\n  }));\n\n  return renderEnums(enums);\n}\n","import path from \"path\";\nimport { formatAndWriteSolidity } from \"@latticexyz/common/codegen\";\nimport { getTableOptions } from \"./tableOptions\";\nimport { renderTable } from \"./renderTable\";\nimport { renderTypesFromConfig } from \"./renderTypesFromConfig\";\nimport { renderTableIndex } from \"./renderTableIndex\";\nimport { rmSync } from \"fs\";\nimport { StoreConfig } from \"../config\";\n\nexport async function tablegen(config: StoreConfig, outputBaseDirectory: string) {\n  const allTableOptions = getTableOptions(config);\n\n  const uniqueTableDirectories = new Set(allTableOptions.map(({ outputPath }) => path.dirname(outputPath)));\n  for (const tableDir of uniqueTableDirectories) {\n    rmSync(path.join(outputBaseDirectory, tableDir), { recursive: true, force: true });\n  }\n\n  // write tables to files\n  for (const { outputPath, renderOptions } of allTableOptions) {\n    const fullOutputPath = path.join(outputBaseDirectory, outputPath);\n    const output = renderTable(renderOptions);\n    await formatAndWriteSolidity(output, fullOutputPath, \"Generated table\");\n  }\n\n  // write types to file\n  if (Object.keys(config.enums).length > 0) {\n    const fullOutputPath = path.join(outputBaseDirectory, `${config.userTypesPath}.sol`);\n    const output = renderTypesFromConfig(config);\n    await formatAndWriteSolidity(output, fullOutputPath, \"Generated types file\");\n  }\n\n  const fullOutputPath = path.join(outputBaseDirectory, `Tables.sol`);\n  const output = renderTableIndex(allTableOptions);\n  await formatAndWriteSolidity(output, fullOutputPath, \"Generated table index\");\n}\n","import path from \"path\";\nimport { SchemaTypeArrayToElement } from \"@latticexyz/schema-type/deprecated\";\nimport {\n  RelativeImportDatum,\n  RenderDynamicField,\n  RenderField,\n  RenderKeyTuple,\n  RenderStaticField,\n} from \"@latticexyz/common/codegen\";\nimport { RenderTableOptions } from \"./types\";\nimport { StoreConfig } from \"../config\";\nimport { getSchemaTypeInfo, importForAbiOrUserType, resolveAbiOrUserType } from \"./userType\";\n\nexport interface TableOptions {\n  outputPath: string;\n  tableName: string;\n  renderOptions: RenderTableOptions;\n}\n\nexport function getTableOptions(config: StoreConfig): TableOptions[] {\n  const storeImportPath = config.storeImportPath;\n\n  const options = [];\n  for (const tableName of Object.keys(config.tables)) {\n    const tableData = config.tables[tableName];\n\n    // struct adds methods to get/set all values at once\n    const withStruct = tableData.dataStruct;\n    // operate on all fields at once; for only 1 field keep them only if struct is also kept\n    const withRecordMethods = withStruct || Object.keys(tableData.schema).length > 1;\n    // field methods can be simply get/set if there's only 1 field and no record methods\n    const noFieldMethodSuffix = !withRecordMethods && Object.keys(tableData.schema).length === 1;\n    // list of any symbols that need to be imported\n    const imports: RelativeImportDatum[] = [];\n\n    const keyTuple = Object.keys(tableData.keySchema).map((name) => {\n      const abiOrUserType = tableData.keySchema[name];\n      const { renderType } = resolveAbiOrUserType(abiOrUserType, config);\n\n      const importDatum = importForAbiOrUserType(abiOrUserType, tableData.directory, config);\n      if (importDatum) imports.push(importDatum);\n\n      if (renderType.isDynamic) throw new Error(`Parsing error: found dynamic key ${name} in table ${tableName}`);\n\n      const keyTuple: RenderKeyTuple = {\n        ...renderType,\n        name,\n        isDynamic: false,\n      };\n      return keyTuple;\n    });\n\n    const fields = Object.keys(tableData.schema).map((name) => {\n      const abiOrUserType = tableData.schema[name];\n      const { renderType, schemaType } = resolveAbiOrUserType(abiOrUserType, config);\n\n      const importDatum = importForAbiOrUserType(abiOrUserType, tableData.directory, config);\n      if (importDatum) imports.push(importDatum);\n\n      const elementType = SchemaTypeArrayToElement[schemaType];\n      const field: RenderField = {\n        ...renderType,\n        arrayElement: elementType !== undefined ? getSchemaTypeInfo(elementType) : undefined,\n        name,\n        methodNameSuffix: noFieldMethodSuffix ? \"\" : `${name[0].toUpperCase()}${name.slice(1)}`,\n      };\n      return field;\n    });\n\n    const staticFields = fields.filter(({ isDynamic }) => !isDynamic) as RenderStaticField[];\n    const dynamicFields = fields.filter(({ isDynamic }) => isDynamic) as RenderDynamicField[];\n\n    // With tableIdArgument: tableId is a dynamic argument for each method\n    // Without tableIdArgument: tableId is a file-level constant generated from `staticResourceData`\n    const staticResourceData = (() => {\n      if (tableData.tableIdArgument) {\n        return;\n      } else {\n        return {\n          tableIdName: tableName + \"TableId\",\n          namespace: config.namespace,\n          name: tableData.name,\n        };\n      }\n    })();\n\n    options.push({\n      outputPath: path.join(tableData.directory, `${tableName}.sol`),\n      tableName,\n      renderOptions: {\n        imports,\n        libraryName: tableName,\n        structName: withStruct ? tableName + \"Data\" : undefined,\n        staticResourceData,\n        storeImportPath,\n        keyTuple,\n        fields,\n        staticFields,\n        dynamicFields,\n        withFieldMethods: !tableData.ephemeral,\n        withRecordMethods: withRecordMethods && !tableData.ephemeral,\n        withEphemeralMethods: tableData.ephemeral,\n        storeArgument: tableData.storeArgument,\n      },\n    });\n  }\n  return options;\n}\n","import {\n  AbiTypeToSchemaType,\n  getStaticByteLength,\n  SchemaType,\n  SchemaTypeToAbiType,\n} from \"@latticexyz/schema-type/deprecated\";\nimport { parseStaticArray } from \"@latticexyz/config\";\nimport { RelativeImportDatum, RenderType } from \"@latticexyz/common/codegen\";\nimport { StoreConfig } from \"../config\";\n\nexport type UserTypeInfo = ReturnType<typeof getUserTypeInfo>;\n\n/**\n * Resolve an abi or user type into a SchemaType and RenderType\n */\nexport function resolveAbiOrUserType(\n  abiOrUserType: string,\n  config: StoreConfig\n): {\n  schemaType: SchemaType;\n  renderType: RenderType;\n} {\n  // abi types which directly mirror a SchemaType\n  if (abiOrUserType in AbiTypeToSchemaType) {\n    const schemaType = AbiTypeToSchemaType[abiOrUserType];\n    return {\n      schemaType,\n      renderType: getSchemaTypeInfo(schemaType),\n    };\n  }\n  // static arrays\n  const staticArray = parseStaticArray(abiOrUserType);\n  if (staticArray) {\n    if (staticArray.elementType in AbiTypeToSchemaType) {\n      return getStaticArrayTypeInfo(abiOrUserType, staticArray.elementType, staticArray.staticLength);\n    } else {\n      throw new Error(\"Static arrays of user types are not supported\");\n    }\n  }\n  // user types\n  return getUserTypeInfo(abiOrUserType, config);\n}\n\n/**\n * Get the required import for SchemaType|userType (`undefined` means that no import is required)\n */\nexport function importForAbiOrUserType(\n  abiOrUserType: string,\n  usedInDirectory: string,\n  config: StoreConfig\n): RelativeImportDatum | undefined {\n  // abi types which directly mirror a SchemaType\n  if (abiOrUserType in AbiTypeToSchemaType) {\n    return undefined;\n  }\n  // static arrays\n  const staticArray = parseStaticArray(abiOrUserType);\n  if (staticArray) {\n    return undefined;\n  }\n  // user types\n  return {\n    symbol: abiOrUserType,\n    fromPath: config.userTypesPath + \".sol\",\n    usedInPath: usedInDirectory,\n  };\n}\n\nexport function getSchemaTypeInfo(schemaType: SchemaType): RenderType {\n  const staticByteLength = getStaticByteLength(schemaType);\n  const isDynamic = staticByteLength === 0;\n  const typeId = SchemaTypeToAbiType[schemaType];\n  return {\n    typeId,\n    typeWithLocation: isDynamic ? typeId + \" memory\" : typeId,\n    enumName: SchemaType[schemaType],\n    staticByteLength,\n    isDynamic,\n    typeWrap: \"\",\n    typeUnwrap: \"\",\n    internalTypeId: typeId,\n  };\n}\n\nexport function getUserTypeInfo(\n  userType: string,\n  config: StoreConfig\n): {\n  schemaType: SchemaType;\n  renderType: RenderType;\n} {\n  // enums\n  if (userType in config.enums) {\n    const schemaType = SchemaType.UINT8;\n    const staticByteLength = getStaticByteLength(schemaType);\n    const isDynamic = staticByteLength === 0;\n    const typeId = userType;\n    return {\n      schemaType,\n      renderType: {\n        typeId,\n        typeWithLocation: typeId,\n        enumName: SchemaType[schemaType],\n        staticByteLength,\n        isDynamic,\n        typeWrap: `${userType}`,\n        typeUnwrap: `uint8`,\n        internalTypeId: `${SchemaTypeToAbiType[schemaType]}`,\n      },\n    };\n  }\n  // invalid\n  throw new Error(`User type \"${userType}\" does not exist`);\n}\n\nfunction getStaticArrayTypeInfo(abiType: string, elementType: string, staticLength: number) {\n  const internalTypeId = elementType + \"[]\";\n  const schemaType = AbiTypeToSchemaType[internalTypeId];\n  return {\n    schemaType,\n    renderType: {\n      typeId: abiType,\n      typeWithLocation: `${abiType} memory`,\n      enumName: SchemaType[schemaType],\n      staticByteLength: 0,\n      isDynamic: true,\n      typeWrap: `toStaticArray_${elementType}_${staticLength}`,\n      typeUnwrap: `fromStaticArray_${elementType}_${staticLength}`,\n      typeWrappingData: {\n        kind: \"staticArray\",\n        elementType,\n        staticLength,\n      },\n      internalTypeId,\n    },\n  } as const;\n}\n","import { posixPath, renderList, renderedSolidityHeader } from \"@latticexyz/common/codegen\";\nimport { TableOptions } from \"./tableOptions\";\n\nexport function renderTableIndex(options: TableOptions[]) {\n  return `${renderedSolidityHeader}\n\n${renderList(options, ({ outputPath, tableName, renderOptions: { structName, staticResourceData } }) => {\n  const imports = [tableName];\n  if (structName) imports.push(structName);\n  if (staticResourceData) imports.push(`${tableName}TableId`);\n\n  return `import { ${imports.join(\", \")} } from \"./${posixPath(outputPath)}\";`;\n})}\n`;\n}\n","import { renderedSolidityHeader } from \"@latticexyz/common/codegen\";\nimport { staticAbiTypeToByteLength, staticAbiTypes } from \"@latticexyz/schema-type\";\nimport { renderTightCoderDecode } from \"./renderFunctions\";\n\nexport function renderDecodeSlice() {\n  let result = `${renderedSolidityHeader}\n    import { TightCoder } from \"./TightCoder.sol\";\n    import { Slice } from \"../Slice.sol\";\n    library DecodeSlice {\n  `;\n\n  for (const staticAbiType of staticAbiTypes) {\n    const staticByteLength = staticAbiTypeToByteLength[staticAbiType];\n    result += renderTightCoderDecode({ internalTypeId: staticAbiType, staticByteLength });\n  }\n\n  result += `\n    }\n  `;\n\n  return result;\n}\n","import { getLeftPaddingBits } from \"@latticexyz/common/codegen\";\n\nexport function renderTightCoderDecode(element: { internalTypeId: string; staticByteLength: number }) {\n  return `\n    function decodeArray_${element.internalTypeId}(\n      Slice _input\n    ) internal pure returns (\n      ${element.internalTypeId}[] memory _output\n    ) {\n      bytes32[] memory _genericArray = TightCoder.decode(\n        _input,\n        ${element.staticByteLength},\n        ${getLeftPaddingBits(element)}\n      );\n      assembly {\n        _output := _genericArray\n      }\n    }\n  `.trim();\n}\n\nexport function renderTightCoderEncode(element: { internalTypeId: string; staticByteLength: number }) {\n  return `\n    function encode(${element.internalTypeId}[] memory _input) internal pure returns (bytes memory) {\n      bytes32[] memory _genericArray;\n      assembly {\n        _genericArray := _input\n      }\n      return TightCoder.encode(\n        _genericArray,\n        ${element.staticByteLength},\n        ${getLeftPaddingBits(element)}\n      );\n    }\n  `.trim();\n}\n","import { renderedSolidityHeader } from \"@latticexyz/common/codegen\";\nimport { staticAbiTypeToByteLength, staticAbiTypes } from \"@latticexyz/schema-type\";\nimport { renderTightCoderEncode } from \"./renderFunctions\";\n\nexport function renderEncodeArray() {\n  let result = `${renderedSolidityHeader}\n    import { TightCoder } from \"./TightCoder.sol\";\n    library EncodeArray {\n  `;\n\n  for (const staticAbiType of staticAbiTypes) {\n    const staticByteLength = staticAbiTypeToByteLength[staticAbiType];\n    result += renderTightCoderEncode({ internalTypeId: staticAbiType, staticByteLength });\n  }\n\n  result += `\n    }\n  `;\n\n  return result;\n}\n","import { renderedSolidityHeader } from \"@latticexyz/common/codegen\";\nimport { staticAbiTypes } from \"@latticexyz/schema-type\";\n\nexport function renderTightCoderAutoTestFunction({ typeId }: { typeId: string }) {\n  return `\n    function testEncodeDecodeArray_${typeId}(\n      ${typeId} val0,\n      ${typeId} val1,\n      ${typeId} val2\n    ) public {\n      ${typeId}[] memory input = new ${typeId}[](3);\n      input[0] = val0;\n      input[1] = val1;\n      input[2] = val2;\n\n      bytes memory encoded = EncodeArray.encode(input);\n      assertEq(encoded, abi.encodePacked(val0, val1, val2));\n\n      ${typeId}[] memory decoded = SliceLib.fromBytes(encoded).decodeArray_${typeId}();\n      assertEq(decoded.length, 3);\n      assertEq(decoded[0], val0);\n      assertEq(decoded[1], val1);\n      assertEq(decoded[2], val2);\n    }\n  `.trim();\n}\n\nexport function renderTightCoderAutoTest() {\n  let result = `${renderedSolidityHeader}\n\n    import { Test } from \"forge-std/Test.sol\";\n    import { EncodeArray } from \"../../src/tightcoder/EncodeArray.sol\";\n    import { SliceLib } from \"../../src/Slice.sol\";\n\n    contract TightCoderAutoTest is Test {\n  `;\n\n  for (const staticAbiType of staticAbiTypes) {\n    result += renderTightCoderAutoTestFunction({ typeId: staticAbiType });\n  }\n\n  result += `\n    }\n  `;\n\n  return result;\n}\n"],"mappings":"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","names":["renderArguments","renderCommonData","renderWithStore","renderFieldMethods","options","storeArgument","_typedTableId","_typedKeyArgs","_keyTupleDefinition","result","schemaIndex","field","_typedFieldName","_typedStore","_store","_commentSuffix","renderDecodeFieldSingle","renderEncodeFieldSingle","portionData","fieldPortionData","func","renderDecodeValueType","offset","staticByteLength","internalTypeId","innerSlice","bits","methodNameSuffix","name","elementFieldData","isDynamic","arrayElement","renderList","renderArguments","renderCommonData","renderWithStore","renderRecordMethods","options","structName","storeArgument","_tableId","_typedTableId","_keyArgs","_typedKeyArgs","_keyTupleDefinition","renderCommonData","result","renderWithStore","_typedStore","_store","_commentSuffix","renderArguments","renderDecodedRecord","name","typeWithLocation","_untypedStore","renderDecodeFunction","fields","staticFields","dynamicFields","renderedDecodedRecord","fieldNamePrefix","staticOffsets","_acc","index","field","totalStaticLength","acc","staticByteLength","renderList","renderDecodeValueType","renderDecodeDynamicFieldPartial","typeId","arrayElement","typeWrap","renderArguments","renderCommonData","renderList","renderedSolidityHeader","renderRelativeImports","renderTableId","renderValueTypeToBytes32","renderWithStore","renderTypeHelpers","renderArguments","renderCommonData","renderWithStore","renderEphemeralMethods","options","structName","storeArgument","_tableId","_typedTableId","_keyArgs","_typedKeyArgs","_keyTupleDefinition","result","_typedStore","_store","_commentSuffix","name","typeWithLocation","_untypedStore","renderTable","options","imports","libraryName","structName","staticResourceData","storeImportPath","fields","staticFields","dynamicFields","withFieldMethods","withRecordMethods","withEphemeralMethods","storeArgument","keyTuple","_typedTableId","_typedKeyArgs","_keyTupleDefinition","renderCommonData","shouldRenderDelete","renderedSolidityHeader","renderRelativeImports","renderTableId","renderList","name","typeId","enumName","index","field","renderWithStore","_typedStore","_store","_commentSuffix","renderArguments","renderFieldMethods","renderRecordMethods","renderEphemeralMethods","typeWithLocation","renderEncodedLengths","renderEncodeFieldSingle","key","renderValueTypeToBytes32","renderTypeHelpers","arrayElement","renderEnums","renderTypesFromConfig","config","enums","name","path","formatAndWriteSolidity","path","SchemaTypeArrayToElement","AbiTypeToSchemaType","getStaticByteLength","SchemaType","SchemaTypeToAbiType","parseStaticArray","resolveAbiOrUserType","abiOrUserType","config","schemaType","getSchemaTypeInfo","staticArray","getStaticArrayTypeInfo","getUserTypeInfo","importForAbiOrUserType","usedInDirectory","staticByteLength","isDynamic","typeId","userType","abiType","elementType","staticLength","internalTypeId","getTableOptions","config","storeImportPath","options","tableName","tableData","withStruct","withRecordMethods","noFieldMethodSuffix","imports","keyTuple","name","abiOrUserType","renderType","resolveAbiOrUserType","importDatum","importForAbiOrUserType","fields","schemaType","elementType","SchemaTypeArrayToElement","getSchemaTypeInfo","staticFields","isDynamic","dynamicFields","staticResourceData","path","posixPath","renderList","renderedSolidityHeader","renderTableIndex","options","outputPath","tableName","structName","staticResourceData","imports","rmSync","tablegen","config","outputBaseDirectory","allTableOptions","getTableOptions","uniqueTableDirectories","outputPath","path","tableDir","renderOptions","fullOutputPath","output","renderTable","formatAndWriteSolidity","renderTypesFromConfig","renderTableIndex","renderedSolidityHeader","staticAbiTypeToByteLength","staticAbiTypes","getLeftPaddingBits","renderTightCoderDecode","element","renderTightCoderEncode","renderDecodeSlice","result","renderedSolidityHeader","staticAbiType","staticAbiTypes","staticByteLength","staticAbiTypeToByteLength","renderTightCoderDecode","renderedSolidityHeader","staticAbiTypeToByteLength","staticAbiTypes","renderEncodeArray","result","renderedSolidityHeader","staticAbiType","staticAbiTypes","staticByteLength","staticAbiTypeToByteLength","renderTightCoderEncode","renderedSolidityHeader","staticAbiTypes","renderTightCoderAutoTestFunction","typeId","renderTightCoderAutoTest","result","staticAbiType"]}