var O=(o=>(o.SystemCall="SystemCall",o.NetworkComponentUpdate="NetworkComponentUpdate",o))(O||{});function Jo(e){return e.type==="SystemCall"}function Q(e){return e.type==="NetworkComponentUpdate"}var dt=(u=>(u[u.BOOL=0]="BOOL",u[u.INT8=1]="INT8",u[u.INT16=2]="INT16",u[u.INT32=3]="INT32",u[u.INT64=4]="INT64",u[u.INT128=5]="INT128",u[u.INT256=6]="INT256",u[u.INT=7]="INT",u[u.UINT8=8]="UINT8",u[u.UINT16=9]="UINT16",u[u.UINT32=10]="UINT32",u[u.UINT64=11]="UINT64",u[u.UINT128=12]="UINT128",u[u.UINT256=13]="UINT256",u[u.BYTES=14]="BYTES",u[u.STRING=15]="STRING",u[u.ADDRESS=16]="ADDRESS",u[u.BYTES4=17]="BYTES4",u[u.BOOL_ARRAY=18]="BOOL_ARRAY",u[u.INT8_ARRAY=19]="INT8_ARRAY",u[u.INT16_ARRAY=20]="INT16_ARRAY",u[u.INT32_ARRAY=21]="INT32_ARRAY",u[u.INT64_ARRAY=22]="INT64_ARRAY",u[u.INT128_ARRAY=23]="INT128_ARRAY",u[u.INT256_ARRAY=24]="INT256_ARRAY",u[u.INT_ARRAY=25]="INT_ARRAY",u[u.UINT8_ARRAY=26]="UINT8_ARRAY",u[u.UINT16_ARRAY=27]="UINT16_ARRAY",u[u.UINT32_ARRAY=28]="UINT32_ARRAY",u[u.UINT64_ARRAY=29]="UINT64_ARRAY",u[u.UINT128_ARRAY=30]="UINT128_ARRAY",u[u.UINT256_ARRAY=31]="UINT256_ARRAY",u[u.BYTES_ARRAY=32]="BYTES_ARRAY",u[u.STRING_ARRAY=33]="STRING_ARRAY",u))(dt||{}),Go={[0]:"bool",[1]:"int8",[2]:"int16",[3]:"int32",[4]:"int64",[5]:"int128",[6]:"int256",[7]:"int",[8]:"uint8",[9]:"uint16",[10]:"uint32",[11]:"uint64",[12]:"uint128",[13]:"uint256",[14]:"bytes",[15]:"string",[16]:"address",[17]:"bytes4",[18]:"bool[]",[19]:"int8[]",[20]:"int16[]",[21]:"int32[]",[22]:"int64[]",[23]:"int128[]",[24]:"int256[]",[25]:"int[]",[26]:"uint8[]",[27]:"uint16[]",[28]:"uint32[]",[29]:"uint64[]",[30]:"uint128[]",[31]:"uint256[]",[32]:"bytes[]",[33]:"string[]"},zo={[18]:0,[19]:1,[20]:2,[21]:3,[22]:4,[23]:5,[24]:6,[25]:7,[26]:8,[27]:9,[28]:10,[29]:11,[30]:12,[31]:6,[32]:14,[33]:15};import{Formatter as pt}from"@ethersproject/providers";import{callWithRetry as q,extractEncodedArguments as ut,range as be,sleep as ge}from"@latticexyz/utils";import{BigNumber as ft,Contract as Tt}from"ethers";import{resolveProperties as bt,defaultAbiCoder as gt}from"ethers/lib/utils.js";async function Se(e,t){await q(()=>Promise.all([e.getBlockNumber(),t?t.getBlockNumber():Promise.resolve()]),[],10,1e3)}async function cr(e,t){for(let o of be(10)){let a=await q(async()=>{let i=await e.perform("getBlock",{includeTransactions:!1,blockTag:e.formatter.blockTag(await e._getBlockTag("latest"))});return e.formatter.block(i)},[],10,1e3);if(t&&a.number<t){await ge(300);continue}else return a}throw new Error("Could not fetch a block with blockNumber "+t)}async function St(e,t,o,r,a,i){let n=async(m,l)=>{let f=await bt({filter:e._getFilter({fromBlock:o,toBlock:r,address:m,topics:l})}),T=await e.perform("getLogs",f);return T.forEach(b=>{b.removed==null&&(b.removed=!1)}),pt.arrayOf(e.formatter.filterLog.bind(e.formatter))(T)},p=async()=>{let m=await e.perform("getBlockNumber",{});return ft.from(m).toNumber()},d=()=>{let m=[];for(let[l,f]of Object.entries(a)){let T=t.find(b=>b.key===l)?.topics;T&&m.push(n(f.address,T))}return m};if(i){for(let m in be(10)){let l=()=>Promise.all([p(),...d()]),[f,T]=await q(l,[],10,1e3);if(f<i)await ge(500);else return T.flat()}throw new Error("Could not fetch logs with a required minimum block number")}else return(await q(()=>Promise.all([...d()]),[],10,1e3)).flat()}async function ir(e,t,o,r,a,i){let n=await St(e,t,o,r,a,i?r:void 0);n.sort((m,l)=>m.blockNumber<l.blockNumber?-1:m.blockNumber>l.blockNumber?1:m.transactionIndex<l.transactionIndex?-1:m.transactionIndex>l.transactionIndex?1:m.logIndex<l.logIndex?-1:1);let p={};for(let m of Object.keys(a))p[a[m].address.toLowerCase()]=m;let d=[];for(let m=0;m<n.length;m++){let l=n[m],f=p[l.address.toLowerCase()];if(!f)throw new Error("This should not happen. An event's address is not part of the contracts dictionnary: "+l.address);let{address:T,abi:b}=a[f],S=new Tt(T,b);try{let g=S.interface.parseLog(l),h=n[m+1]?.transactionHash!==l.transactionHash;d.push({contractKey:f,eventKey:g.name,args:g.args,txHash:l.transactionHash,lastEventInTx:h,blockNumber:l.blockNumber,logIndex:l.logIndex})}catch(g){console.warn("Error",g),console.warn("A log couldn't be parsed with the corresponding contract interface!")}}return d}async function mr(e,t){let o=await t.getTransaction(e);if(!o)throw new Error("This transaction doesn't exist. Can't get the revert reason");o.gasPrice=void 0;let r=await t.call(o);return gt.decode(["string"],ut(r))[0]}import{Web3Provider as ht,WebSocketProvider as It}from"@ethersproject/providers";import{callWithRetry as Ct,observableToComputed as ye,timeoutAfter as kt}from"@latticexyz/utils";import{observable as Ne,reaction as he,runInAction as Ie}from"mobx";import{JsonRpcBatchProvider as yt,JsonRpcProvider as Nt}from"@ethersproject/providers";var X=class extends Nt{constructor(t,o){super(t,o)}async detectNetwork(){let t=this.network;if(t==null)throw new Error("No network");return t}},Z=class extends yt{constructor(t,o){super(t,o)}async detectNetwork(){let t=this.network;if(t==null)throw new Error("No network");return t}};function xt({chainId:e,jsonRpcUrl:t,wsRpcUrl:o,externalProvider:r,options:a}){let i={chainId:e,name:"mudChain"},n=r?{json:new ht(r,i),ws:void 0}:{json:a?.batch?new Z(t,i):new X(t,i),ws:o?new It(o,i):void 0};return a?.pollingInterval&&(n.json.pollingInterval=a.pollingInterval),n}var wt=(r=>(r[r.DISCONNECTED=0]="DISCONNECTED",r[r.CONNECTING=1]="CONNECTING",r[r.CONNECTED=2]="CONNECTED",r))(wt||{});async function Ce(e){let t=Ne.box(0),o=Ne.box(),r=[];async function a(){if(t.get()===1)return;Ie(()=>t.set(1));let n=o.get();n?.json.removeAllListeners(),n?.ws?.removeAllListeners();try{n?.ws?._websocket?.close()}catch{}let p=e.get();await Ct(async()=>{let d=xt(p);!p?.options?.skipNetworkCheck&&await Se(d.json,d.ws),Ie(()=>{o.set(d),t.set(2)})})}r.push(he(()=>e.get(),()=>a())),r.push(he(()=>o.get(),n=>{n?.ws?._websocket&&(n.ws._websocket.onerror=a,n.ws._websocket.onclose=()=>{t.get()===2&&a()})}));let i=setInterval(async()=>{if(t.get()!==2)return;let n=o.get();if(n?.ws)try{await kt(n.ws.getBlockNumber(),1e4,"Network Request Timed out")}catch{a()}},1e4);return r.push(()=>clearInterval(i)),await a(),{connected:ye(t),providers:ye(o),dispose:()=>{for(let n of r)n();try{o.get()?.ws?._websocket?.close()}catch{}}}}import{stretch as vt}from"@latticexyz/utils";import{reaction as Et}from"mobx";import{concat as Rt,concatMap as At,EMPTY as Ut,endWith as Bt,filter as Yt,map as Pt,range as Lt,ReplaySubject as Dt,take as Vt}from"rxjs";function ke(e,t){let o=new Dt(1),r=t?.initialSync?o.pipe(Vt(1),Yt(n=>n>(t.initialSync.initialBlockNumber||0)),At(n=>{let p=n-t.initialSync.initialBlockNumber;return Lt(0,Math.ceil(p/t.initialSync.interval)).pipe(Pt(d=>t.initialSync.initialBlockNumber+d*t.initialSync.interval),Bt(n))}),vt(50)):Ut,a=Et(()=>e.get(),n=>{let p=n?.ws||n?.json,d=!0;p?.getBlockNumber().then(m=>{d&&o.next(m)}),p?.on("block",m=>{d=!1,o.next(m)})},{fireImmediately:!0});return{blockNumber$:Rt(r,o),dispose:a}}import{BehaviorSubject as ee,Subject as xe}from"rxjs";var J=new xe,Ar=new xe,Ur=new ee(null),Br=new ee(null),se=new ee(null),we=new ee(null);import{packTuple as jt,transformIterator as Wt,unpackTuple as Jt}from"@latticexyz/utils";import{arrayToIterator as Ee,deferred as _,mergeIterators as Ot,transformIterator as _t}from"@latticexyz/utils";var $t=self.indexedDB,Ft=2;function Mt(e,t){e.objectStoreNames.contains(t)||e.createObjectStore(t)}function Kt(e,t,o=Ft,r=$t){let[a,i,n]=_(),p=r.open(e,o);return p.onupgradeneeded=()=>{let d=p.result;for(let m of t)Mt(d,m)},p.onsuccess=()=>{let d=p.result;a(d)},p.onerror=d=>{i(new Error(JSON.stringify(d)))},n}async function Re(e,t,o,r){let a=await Kt(e,t,o,r);function i(T){return a.transaction(T,"readwrite").objectStore(T)}function n(T,b,S,g=!1){let y=i(T).put(S,b);if(g)return;let[N,C,R]=_();return y.onerror=j=>{C(new Error(JSON.stringify(j)))},y.onsuccess=()=>{N()},R}function p(T,b){let[S,g,h]=_(),N=i(T).get(b);return N.onerror=C=>{g(new Error(JSON.stringify(C)))},N.onsuccess=()=>{let C=N.result;S(C)},h}function d(T,b){let[S,g,h]=_(),N=i(T).delete(b);return N.onerror=C=>{g(new Error(JSON.stringify(C)))},N.onsuccess=()=>{S()},h}function m(T){let[b,S,g]=_(),y=i(T).getAllKeys();return y.onerror=N=>{S(new Error(JSON.stringify(N)))},y.onsuccess=()=>{let N=Ee(y.result),C=_t(N,R=>R.toString());b(C)},g}function l(T){let[b,S,g]=_(),y=i(T).getAll();return y.onerror=N=>{S(new Error(JSON.stringify(N)))},y.onsuccess=()=>{b(Ee(y.result))},g}async function f(T){let[b,S]=await Promise.all([m(T),l(T)]);return Ot(b,S)}return{set:n,get:p,remove:d,keys:m,values:l,entries:f,db:a}}import Ht from"debug";var Ae=Ht("mud:network");var te=Ae.extend("workers");import{Subject as Ue}from"rxjs";var Gt=te.extend("CacheStore");function zt(e,t,o){return`${e}-${t}-${o}`}function $(){let e=[],t=new Map,o=[],r=new Map,a=0,i=new Map,n=new Ue;return{components:e,componentToIndex:t,entities:o,entityToIndex:r,blockNumber:a,state:i,componentUpdate$:n,keys:{},tables:{}}}function F(e,{component:t,entity:o,value:r,partialValue:a,initialValue:i,blockNumber:n,key:p,namespace:d,table:m}){let{components:l,entities:f,componentToIndex:T,entityToIndex:b,state:S,keys:g,tables:h}=e,y=T.get(t);y==null&&(y=l.push(t)-1,T.set(t,y));let N=b.get(o);N==null&&(N=f.push(o)-1,b.set(o,N)),p&&(g[N]=p),d!=null&&m!=null&&(h[y]={namespace:d,table:m});let C=jt([y,N]);if(a!==void 0){let R=S.get(C);S.set(C,{...i,...R,...a})}else r===void 0?(console.log("deleting key",C),S.delete(C)):S.set(C,r);e.blockNumber=n-1,e.componentUpdate$.next({component:t,entity:o,blockNumber:n})}function ce(e,t){for(let o of t)F(e,o)}function ie({blockNumber:e,state:t,components:o,entities:r,keys:a,tables:i}){return Wt(t.entries(),([n,p])=>{let[d,m]=Jt(n),l=o[d],f=r[m],T=a[m],{namespace:b,table:S}=i[d];if(l==null||f==null)throw new Error(`Unknown component / entity: ${l}, ${f}`);return{type:"NetworkComponentUpdate",component:l,entity:f,value:p,namespace:b,table:S,key:T,lastEventInTx:!1,txHash:"cache",blockNumber:e}})}function jr(e){let t=$(),o=[...e].sort((r,a)=>r.blockNumber-a.blockNumber);for(let r of o)for(let a of ie(r))F(t,a);return t.blockNumber=o[o.length-1].blockNumber,t}async function me(e,t){Gt("store cache with size",t.state.size,"at block",t.blockNumber),await e.set("ComponentValues","current",t.state),await e.set("Mappings","components",t.components),await e.set("Mappings","entities",t.entities),await e.set("BlockNumber","current",t.blockNumber),await e.set("Keys","current",t.keys),await e.set("Tables","current",t.tables)}async function Be(e){let t=await e.get("ComponentValues","current")??new Map,o=await e.get("BlockNumber","current")??0,r=await e.get("Mappings","components")??[],a=await e.get("Mappings","entities")??[],i=await e.get("Keys","current")??{},n=await e.get("Tables","current")??{},p=new Map,d=new Map,m=new Ue;for(let l=0;l<r.length;l++)p.set(r[l],l);for(let l=0;l<a.length;l++)d.set(a[l],l);return{state:t,blockNumber:o,components:r,entities:a,componentToIndex:p,entityToIndex:d,componentUpdate$:m,keys:i,tables:n}}async function Ye(e){return await e.get("BlockNumber","current")??0}function Pe(e,t,o,r){return Re(zt("ECSCache",e,t),["ComponentValues","BlockNumber","Mappings","Snapshot","Keys","Tables"],o,r)}import{pad as Qt}from"viem";var Le=(r=>(r[r.CONNECTING=0]="CONNECTING",r[r.INITIAL=1]="INITIAL",r[r.LIVE=2]="LIVE",r))(Le||{}),G=Qt("0x060d",{size:32}),zr=G;import{awaitStreamValue as Ao,filterNullish as Uo,keccak256 as Bo,streamToDefinedComputed as Yo}from"@latticexyz/utils";import{bufferTime as Po,concat as Lo,concatMap as Do,filter as st,ignoreElements as Vo,map as Oo,of as _o,Subject as Te,take as $o}from"rxjs";import{computed as Fo}from"mobx";import je from"lodash/orderBy";import{isDefined as We}from"@latticexyz/common/utils";import{TableId as De}from"@latticexyz/common/deprecated";var oe=new De("mudstore","schema"),Y=new De("mudstore","StoreMetadata"),Ve=["StoreSetRecord","StoreSetField","StoreDeleteRecord"],Oe=["StoreEphemeralRecord"];import{TableId as yo}from"@latticexyz/common/deprecated";import{TableId as Fe}from"@latticexyz/common/deprecated";import{utils as fo}from"ethers";import{getStaticByteLength as qt,SchemaTypeToAbiType as Xt}from"@latticexyz/schema-type/deprecated";import{hexToArray as Zt}from"@latticexyz/utils";function le(e){let t=!e||e==="0x",o=t?new Uint8Array(64).buffer:Zt(e).buffer,r=new DataView(o),a=new DataView(o.slice(32)),i={..._e(r),rawSchema:e,isEmpty:t},n={..._e(a),rawSchema:e,isEmpty:t};return{valueSchema:i,keySchema:n}}function _e(e){let t=e.getUint16(0),o=e.getUint8(2),r=e.getUint8(3),a=[],i=[];for(let m=4;m<4+o;m++)a.push(e.getUint8(m));for(let m=4+o;m<4+o+r;m++)i.push(e.getUint8(m));let n=a.reduce((m,l)=>m+qt(l),0);if(n!==t)throw console.error("Schema static data length mismatch! Is `getStaticByteLength` outdated?",{schemaStaticDataLength:t,actualStaticDataLength:n,schemaBytes:e}),new Error("Schema static data length mismatch! Is `getStaticByteLength` outdated?");let d=`(${[...a,...i].map(m=>Xt[m]).join(",")})`;return{staticDataLength:t,staticFields:a,dynamicFields:i,abi:d}}var de={};function E(e,t,o){let r=`${e.address}:${t.toHex()}`,a=de[r];if(a)return o&&a.then(l=>{l.valueSchema.rawSchema!==o&&console.warn("a different schema was already registered for this table",{table:t,currentSchema:l,newSchema:o,world:e.address})}),a;if(o){console.log("registering schema for table",{table:t.toString(),world:e.address,rawSchema:o});let l=Promise.resolve(le(o));return de[r]=l,l}console.log("fetching schema for table",{table:t.toString(),world:e.address});let i=e,n=i.getKeySchema(t.toHex()),p=i.getSchema(t.toHex()),m=Promise.all([n,p]).then(([l,f])=>f+l.substring(2)).then(l=>{let f=le(l);return f.valueSchema.isEmpty&&console.warn("Schema not found for table",{table:t.toString(),world:e.address}),f});return de[r]=m,m}import{utils as lo}from"ethers";import{getStaticByteLength as ue,SchemaType as $e}from"@latticexyz/schema-type/deprecated";import{hexToArray as mo}from"@latticexyz/utils";import{getStaticByteLength as eo,SchemaType as s}from"@latticexyz/schema-type/deprecated";import{toHex as to,pad as oo}from"viem";var ro=e=>{throw new Error(`Unsupported static field type: ${s[e]??e}`)},w=(e,t,o)=>{let r=eo(e),a=t.slice(o,o+r),i=to(a),n=i.replace(/^0x$/,"0x0");switch(e){case s.BOOL:return Number(n)!==0;case s.UINT8:case s.UINT16:case s.UINT24:case s.UINT32:case s.UINT40:case s.UINT48:return Number(n);case s.UINT56:case s.UINT64:case s.UINT72:case s.UINT80:case s.UINT88:case s.UINT96:case s.UINT104:case s.UINT112:case s.UINT120:case s.UINT128:case s.UINT136:case s.UINT144:case s.UINT152:case s.UINT160:case s.UINT168:case s.UINT176:case s.UINT184:case s.UINT192:case s.UINT200:case s.UINT208:case s.UINT216:case s.UINT224:case s.UINT232:case s.UINT240:case s.UINT248:case s.UINT256:return BigInt(n);case s.INT8:case s.INT16:case s.INT24:case s.INT32:case s.INT40:case s.INT48:{let p=2**(r*8),d=Number(n);return d<p/2?d:d-p}case s.INT56:case s.INT64:case s.INT72:case s.INT80:case s.INT88:case s.INT96:case s.INT104:case s.INT112:case s.INT120:case s.INT128:case s.INT136:case s.INT144:case s.INT152:case s.INT160:case s.INT168:case s.INT176:case s.INT184:case s.INT192:case s.INT200:case s.INT208:case s.INT216:case s.INT224:case s.INT232:case s.INT240:case s.INT248:case s.INT256:{let p=2n**(BigInt(r)*8n),d=BigInt(n);return d<p/2n?d:d-p}case s.BYTES1:case s.BYTES2:case s.BYTES3:case s.BYTES4:case s.BYTES5:case s.BYTES6:case s.BYTES7:case s.BYTES8:case s.BYTES9:case s.BYTES10:case s.BYTES11:case s.BYTES12:case s.BYTES13:case s.BYTES14:case s.BYTES15:case s.BYTES16:case s.BYTES17:case s.BYTES18:case s.BYTES19:case s.BYTES20:case s.BYTES21:case s.BYTES22:case s.BYTES23:case s.BYTES24:case s.BYTES25:case s.BYTES26:case s.BYTES27:case s.BYTES28:case s.BYTES29:case s.BYTES30:case s.BYTES31:case s.BYTES32:case s.ADDRESS:return oo(i,{dir:"right",size:r});default:return ro(e)}};import{SchemaType as pe,SchemaTypeArrayToElement as no,getStaticByteLength as ao}from"@latticexyz/schema-type/deprecated";import{toHex as so,bytesToString as co}from"viem";var io=e=>{throw new Error(`Unsupported dynamic field type: ${pe[e]??e}`)},U=(e,t)=>{if(e===pe.BYTES)return so(t);if(e===pe.STRING)return co(t);let o=no[e];if(o!==void 0){let r=ao(o),a=t.byteLength/r;return new Array(a).fill(void 0).map((i,n)=>w(o,t,n*r))}return io(e)};var re=(e,t)=>{let o={},r=mo(t),a=0;e.staticFields.forEach((n,p)=>{let d=w(n,r,a);a+=ue(n),o[p]=d});let i=a;if(i!==e.staticDataLength&&console.warn("Decoded static data length does not match schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?",{expectedLength:e.staticDataLength,actualLength:i,bytesOffset:a,schema:e,hexData:t}),e.dynamicFields.length>0){let n=r.slice(e.staticDataLength,e.staticDataLength+32);a+=32;let p=$e.UINT56,d=$e.UINT40,m=w(p,n,0);e.dynamicFields.forEach((f,T)=>{let b=w(d,n,ue(p)+T*ue(d)),S=U(f,r.slice(a,a+b));a+=b,o[e.staticFields.length+T]=S});let l=a-32-i;BigInt(l)!==m&&console.warn("Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?",{expectedLength:m,actualLength:l,bytesOffset:a,schema:e,hexData:t})}return o};var fe={};function P(e,t,o){let r=`${e.address}:${t.toHex()}`,a=fe[r];if(a)return o&&a.then(n=>{JSON.stringify(n)!==JSON.stringify(o)&&console.warn("different metadata already registered for this table",{table:t,currentMetadata:n,newMetadata:o,world:e.address})}),a;if(o){console.log("registering metadata for table",{table:t.toString(),metadata:o,world:e.address});let n=Promise.resolve(o);return fe[r]=n,n}if(t.toHex()===oe.toHex()||t.toHex()===Y.toHex())return Promise.resolve(void 0);console.log("fetching metadata for table",{table:t.toString(),world:e.address});let i=Promise.all([E(e,Y),e["getRecord(bytes32,bytes32[])"](Y.toHex(),[t.toHex()])]).then(([{valueSchema:n},p])=>{n.isEmpty&&console.warn("Metadata schema not found",{table:Y.toString(),world:e.address}),(!p||p==="0x")&&console.warn("Metadata not found for table",{table:t.toString(),world:e.address});let d=re(n,p),m=d[0];m!==t.name&&console.warn("Metadata table name does not match table ID",{tableName:m,tableId:t.toString(),world:e.address});let[l]=lo.defaultAbiCoder.decode(["string[]"],d[1]);return{tableName:m,fieldNames:l}});return fe[r]=i,i}import{SchemaTypeToAbiType as po}from"@latticexyz/schema-type/deprecated";import{decodeAbiParameters as uo}from"viem";function M(e,t){let o=e.staticFields.map(a=>po[a]);return t.map((a,i)=>uo([{type:o[i]}],a)[0]).reduce((a,i,n)=>({...a,[n]:i}),{})}async function z(e,t,o,r){if(t.toHex()===oe.toHex()){let[m,...l]=o;l.length&&console.warn("registerSchema event has more than one value in key tuple, but this method only supports a single key",{table:t,keyTuple:o}),E(e,Fe.fromHex(m),r)}let{keySchema:a,valueSchema:i}=await E(e,t),n=re(i,r),p=M(a,o);if(t.toHex()===Y.toHex()){let[m,...l]=o;l.length&&console.warn("setMetadata event has more than one value in key tuple, but this method only supports a single key",{table:t,keyTuple:o});let f=n[0],[T]=fo.defaultAbiCoder.decode(["string[]"],n[1]);P(e,Fe.fromHex(m),{tableName:f,fieldNames:T})}let d=await P(e,t);if(d){let{tableName:m,fieldNames:l}=d,f={};for(let[T,b]of l.entries())f[b]=n[T];return{indexedValues:n,namedValues:f,indexedKey:p}}return console.warn(`Received data for ${t.toString()}, but could not find table metadata for field names. Did your contracts get autogenerated and deployed properly?`),{indexedValues:n,indexedKey:p}}import{hexToArray as To}from"@latticexyz/utils";var Me=(e,t,o)=>{let r={},a=To(o);return e.staticFields.forEach((i,n)=>{n===t&&(r[t]=w(i,a,0))}),e.dynamicFields.length>0&&e.dynamicFields.forEach((i,n)=>{e.staticFields.length+n===t&&(r[t]=U(i,a))}),r};async function Ke(e,t,o,r,a){let i=await E(e,t),{valueSchema:n,keySchema:p}=i,d=Me(n,r,a),m=M(p,o),l=[...n.staticFields.map(b=>w(b,new Uint8Array(0),0)),...n.dynamicFields.map(b=>U(b,new Uint8Array(0)))],f=Object.fromEntries(l.map((b,S)=>[S,b])),T=await P(e,t);if(T){let{tableName:b,fieldNames:S}=T,g=Object.fromEntries(l.map((h,y)=>[S[y],h]));return{schema:i,indexedValues:d,indexedInitialValues:f,namedValues:{[S[r]]:d[r]},namedInitialValues:g,indexedKey:m}}return console.warn(`Received data for ${t.toString()}, but could not find table metadata for field names. Did your contracts get autogenerated and deployed properly?`),{schema:i,indexedValues:d,indexedInitialValues:f,indexedKey:m}}import{toHex as bo,pad as go,isHex as So}from"viem";function K(e){return e.length===0?G:e.map(t=>So(t)?go(t,{size:32}):bo(t,{size:32})).join(":")}var He=async(e,t,o,r,a)=>{let{blockNumber:i,transactionHash:n,logIndex:p}=o,{args:d,name:m}=r,l=yo.fromHex(d.table),f=l.toString(),T=K(d.key),b={type:"NetworkComponentUpdate",component:f,entity:T,value:void 0,blockNumber:i,txHash:n,logIndex:p,lastEventInTx:a,namespace:l.namespace,table:l.name,key:{}};if(m==="StoreSetRecord"){let{indexedValues:S,namedValues:g,indexedKey:h,namedKey:y}=await z(t,l,d.key,d.data);return{...b,value:{...S,...g},key:{...h,...y},devEmit:()=>{J.next({event:m,chainId:e,worldAddress:t.address,blockNumber:i,logIndex:p,transactionHash:n,table:l,keyTuple:d.key,indexedValues:S,namedValues:g})}}}if(m==="StoreEphemeralRecord"){let{indexedValues:S,namedValues:g,indexedKey:h,namedKey:y}=await z(t,l,d.key,d.data);return{...b,ephemeral:!0,value:{...S,...g},key:{...h,...y},devEmit:()=>{J.next({event:m,chainId:e,worldAddress:t.address,blockNumber:i,logIndex:p,transactionHash:n,table:l,keyTuple:d.key,indexedValues:S,namedValues:g})}}}if(m==="StoreSetField"){console.log("set field");let{indexedValues:S,indexedInitialValues:g,namedValues:h,namedInitialValues:y,indexedKey:N,namedKey:C}=await Ke(t,l,d.key,d.schemaIndex,d.data);return{...b,partialValue:{...S,...h},initialValue:{...g,...y},key:{...N,...C},devEmit:()=>{J.next({event:m,chainId:e,worldAddress:t.address,blockNumber:i,logIndex:p,transactionHash:n,table:l,keyTuple:d.key,indexedValues:S,namedValues:h})}}}if(m==="StoreDeleteRecord"){let{keySchema:S}=await E(t,l),g=M(S,d.key);return{...b,key:g,devEmit:()=>{J.next({event:m,chainId:e,worldAddress:t.address,blockNumber:i,logIndex:p,transactionHash:n,table:l,keyTuple:d.key})}}}};async function Je(e,t,o){let{chainId:r}=await e.provider.getNetwork(),i=[...Ve,...Oe].map(f=>e.filters[f]().topics).filter(We),n=await Promise.all(i.map(f=>e.provider.getLogs({address:e.address,topics:f,fromBlock:t,toBlock:o}))),p=je(n.flatMap(f=>f.map(T=>({log:T,parsedLog:e.interface.parseLog(T)}))),["log.blockNumber","log.logIndex"]),d={};p.map(({log:f})=>{d[f.transactionHash]=f.logIndex});let m=await Promise.all(p.map(({log:f,parsedLog:T})=>{let{transactionHash:b,logIndex:S}=f;return He(r,e,f,T,d[b]===S)})),l=je(m.filter(We),["blockNumber","logIndex"]);return l.forEach(f=>f?.devEmit&&f.devEmit()),l}import Mo from"@latticexyz/store/abi/IStore.sol/IStore.abi.json";import{Contract as Ko}from"ethers";import{QueryLayerDefinition as No}from"@latticexyz/services/mode";import{createChannel as ho,createClient as Io}from"nice-grpc-web";function Ge(e){return Io(No,ho(e))}import{AbiTypeToSchemaType as Qe,encodeSchema as qe}from"@latticexyz/schema-type/deprecated";import{arrayToHex as ae}from"@latticexyz/utils";import{TableId as ko}from"@latticexyz/common/deprecated";import{SchemaType as Co}from"@latticexyz/schema-type/deprecated";import{SchemaType as c}from"@latticexyz/schema-type/deprecated";function ze(e,t){switch(e){case c.BOOL:case c.UINT8:case c.UINT16:case c.UINT24:case c.UINT32:case c.UINT40:case c.UINT48:case c.UINT56:case c.UINT64:case c.UINT72:case c.UINT80:case c.UINT88:case c.UINT96:case c.UINT104:case c.UINT112:case c.UINT120:case c.UINT128:case c.UINT136:case c.UINT144:case c.UINT152:case c.UINT160:case c.UINT168:case c.UINT176:case c.UINT184:case c.UINT192:case c.UINT200:case c.UINT208:case c.UINT216:case c.UINT224:case c.UINT232:case c.UINT240:case c.UINT248:case c.UINT256:case c.INT8:case c.INT16:case c.INT24:case c.INT32:case c.INT40:case c.INT48:case c.INT56:case c.INT64:case c.INT72:case c.INT80:case c.INT88:case c.INT96:case c.INT104:case c.INT112:case c.INT120:case c.INT128:case c.INT136:case c.INT144:case c.INT152:case c.INT160:case c.INT168:case c.INT176:case c.INT184:case c.INT192:case c.INT200:case c.INT208:case c.INT216:case c.INT224:case c.INT232:case c.INT240:case c.INT248:case c.INT256:case c.BYTES1:case c.BYTES2:case c.BYTES3:case c.BYTES4:case c.BYTES5:case c.BYTES6:case c.BYTES7:case c.BYTES8:case c.BYTES9:case c.BYTES10:case c.BYTES11:case c.BYTES12:case c.BYTES13:case c.BYTES14:case c.BYTES15:case c.BYTES16:case c.BYTES17:case c.BYTES18:case c.BYTES19:case c.BYTES20:case c.BYTES21:case c.BYTES22:case c.BYTES23:case c.BYTES24:case c.BYTES25:case c.BYTES26:case c.BYTES27:case c.BYTES28:case c.BYTES29:case c.BYTES30:case c.BYTES31:case c.BYTES32:case c.ADDRESS:return w(e,t,0);default:return U(e,t)}}function ne(e){if(e.cols[1]!=="block_number")throw new Error("Table does not contain block_number column");return Number(ze(Co.UINT256,e.rows[0].values[1]))}import{decodeAbiParameters as Xe}from"viem";async function Ze(e,t,o,r){let a=$(),i=await e.getState({chainTables:[],worldTables:[],namespace:{chainId:t.toString(),worldAddress:o.address}});console.log("syncTablesFromMode",i);let n=Object.values(i.worldTables).reduce((l,f)=>l+f.rows.length,0),p=0,d=ne(i.chainTables.block_number),m=[];for(let[l,{rows:f,cols:T,types:b}]of Object.entries(i.worldTables)){let[S,g]=l.split("__"),h=new ko(S,g),y=h.toString(),N=T.findIndex(k=>!k.startsWith("key_")),C=b.slice(0,N),R=C.map(k=>Qe[k]),j=ae(qe(R)),L=T.slice(N),D=b.slice(N).map(k=>k.match(/tuple\((.*)\[]\)/)?.[1]??k),A=D.map(k=>Qe[k]),W=ae(qe(A))+j.substring(2);m.push(E(o,h,W)),m.push(P(o,h,{tableName:g,fieldNames:L}));for(let k of f){console.log(g,C,D,k.values);let V=k.values.slice(0,N).map((B,u)=>Xe([{type:C[u]}],ae(B))[0]),I=k.values.slice(N).map((B,u)=>Xe([{type:D[u]}],ae(B))[0]),v=V.reduce((B,u,lt)=>({...B,[lt]:u}),{}),it=K(V),mt=Object.fromEntries(I.map((B,u)=>[L[u],B]));F(a,{type:"NetworkComponentUpdate",component:y,entity:it,key:v,value:mt,blockNumber:d,namespace:h.namespace,table:h.name}),p++,p%100===0&&r&&r(Math.floor(p/n))}console.log("done syncing from mode table",g)}return console.log("done syncing from mode",p,"rows processed"),await Promise.all(m),a}async function et(e,t){try{let o=await e.getPartialState({table:"block_number",namespace:{chainId:t.toString()}});return ne(o.chainTables.block_number)}catch(o){return console.error("MODE Error: ",o),-1}}async function tt(e,t,o){let r=[];for(let a of t){let{tableId:i,keyTuple:n,value:p}=a,{indexedValues:d,namedValues:m,indexedKey:l,namedKey:f}=await z(e,i,n,p),T={...l,...f},b=i.toString(),S=K(n),g={type:"NetworkComponentUpdate",component:b,entity:S,key:T,value:{...d,...m},lastEventInTx:!1,txHash:"cache",blockNumber:o,namespace:i.namespace,table:i.name};r.push(g)}return r}import{getEventSelector as Ho}from"viem";import{concatMap as xo,map as wo,of as vo}from"rxjs";import{orderBy as ot}from"lodash";import rt from"debug";import{awaitPromise as Eo,range as Ro}from"@latticexyz/utils";function nt(e,t){let o;return e.pipe(wo(async r=>{let a=o==null||o>=r?r:o+1,i=r;o=i;let n=await t(a,i),p=ot(n,["blockNumber","logIndex"]);return rt(`fetched ${p.length} events from block range ${a} -> ${i}`),p}),Eo(),xo(r=>vo(...r)))}async function at(e,t,o,r=50,a){let i=[],n=o-t,p=Math.ceil(n/r),d=[...Ro(p,r,t)];for(let m=0;m<d.length;m++){let l=d[m],f=m===d.length-1?o:d[m+1]-1,T=await e(l,f);a&&a(m*r/n*100),rt(`initial sync fetched ${i.length} events from block range ${l} -> ${f}`),i=i.concat(ot(T,["blockNumber","logIndex"]))}return i}var H=te.extend("SyncWorker"),jo=3,Wo=(o=>(o[o.Ack=0]="Ack",o[o.Config=1]="Config",o))(Wo||{}),ks={type:0},ct=class{input$=new Te;output$=new Te;syncState={state:0,msg:"",percentage:0};constructor(){H("creating SyncWorker"),this.init()}setLoadingState(t,o=0){let r={...this.syncState,...t};this.syncState=r;let a={type:"NetworkComponentUpdate",component:Bo("component.LoadingState"),value:r,entity:G,key:{},namespace:"mudsync",table:"LoadingState",txHash:"worker",lastEventInTx:!1,blockNumber:o};this.output$.next(a)}async init(){this.setLoadingState({state:0,msg:"Connecting...",percentage:0});let t=await Yo(this.input$.pipe(Oo(I=>I.type===1?I.data:void 0),Uo())),o=t.get(),{modeUrl:r,chainId:a,worldContract:i,disableCache:n,initialRecords:p}=o;we.next(i.address);let d=o.cacheAgeThreshold||100,m=o.cacheInterval||1,{providers:l}=await Ce(Fo(()=>t.get().provider)),f=l.get().json,T=r?Ge(r):void 0,b=await Pe(a,i.address,jo);H("start initial sync"),this.setLoadingState({state:1,msg:"Starting initial sync",percentage:0});let S=!1,g={current:$()};se.next(g.current);let{blockNumber$:h}=ke(l),y=new Ko(i.address,Mo,f),N=(I,v)=>Je(y,I,v),C=nt(h,N),R=[];C.subscribe(I=>{if(!S){Q(I)&&R.push(I);return}Q(I)&&(F(g.current,I),I.blockNumber>g.current.blockNumber+1&&I.blockNumber%m===0&&me(b,g.current));let v=I;Q(v)&&delete v.devEmit,this.output$.next(v)});let j=Ao(h);this.setLoadingState({state:1,msg:"Fetching cache block number",percentage:0});let L=n?-1:await Ye(b);this.setLoadingState({percentage:50});let D=T?await et(T,a):-1,A=o.initialBlockNumber;if(A<0){let I=await f.getLogs({address:i.address,topics:[Ho("event HelloWorld()")],fromBlock:"earliest"});A=I.length>0?I[0].blockNumber:0}this.setLoadingState({percentage:100}),H(`cache block: ${L}, start sync at ${A}`);let x=$();if(p){console.log("Initial state from pre-loaded records"),this.setLoadingState({state:1,msg:"Loading initial state",percentage:0});let I=await tt(y,p,A);ce(x,I),x.blockNumber=A}else if(A>Math.max(L,D))x.blockNumber=A;else{let I=T&&D>L+d;console.log("syncFromMode",I),I?(console.log("Initial sync from MODE"),this.setLoadingState({state:1,msg:"Fetching initial state from MODE",percentage:0}),x=await Ze(T,a,y,v=>this.setLoadingState({percentage:v})),this.setLoadingState({percentage:100})):n||(this.setLoadingState({state:1,msg:"Fetching initial state from cache",percentage:0}),x=await Be(b),this.setLoadingState({percentage:100})),H(`got ${x.state.size} items from ${I?"mode":"cache"}`)}let W=await j;this.setLoadingState({state:1,msg:`Fetching state from block ${x.blockNumber} to ${W}`,percentage:0});let k=await at(N,x.blockNumber,W,50,I=>this.setLoadingState({percentage:I}));H(`got ${k.length} items from block range ${x.blockNumber} -> ${W}`),ce(x,[...k,...R]),g.current=x,se.next(g.current),H(`initial sync state size: ${g.current.state.size}`),this.setLoadingState({state:1,msg:`Initializing with ${g.current.state.size} state entries`,percentage:0});let V=0;for(let I of ie(g.current))if(V++,this.output$.next(I),V%5e3===0){let v=Math.floor(V/g.current.state.size*100);this.setLoadingState({percentage:v})}me(b,g.current),this.setLoadingState({state:2,msg:"Streaming live events",percentage:100},g.current.blockNumber),S=!0}work(t){t.subscribe(this.input$);let o=new Te;return this.output$.pipe(Po(16,null,50),st(r=>r.length>0),Do(r=>Lo(_o(r),t.pipe(st(a=>a.type===0),$o(1),Vo())))).subscribe(o),o}};export{O as a,Jo as b,Q as c,dt as d,Go as e,zo as f,Se as g,cr as h,St as i,ir as j,mr as k,xt as l,wt as m,Ce as n,ke as o,J as p,Ar as q,Ur as r,Br as s,se as t,we as u,zt as v,$ as w,F as x,ce as y,ie as z,jr as A,me as B,Be as C,Ye as D,Pe as E,Le as F,G,zr as H,K as I,Wo as J,ks as K,ct as L};
//# sourceMappingURL=chunk-UU7EGKXM.js.map