{"version":3,"sources":["../src/types.ts","../src/networkUtils.ts","../src/createProvider.ts","../src/provider.ts","../src/createBlockNumberStream.ts","../src/dev/observables.ts","../src/workers/CacheStore.ts","../src/initCache.ts","../src/debug.ts","../src/workers/debug.ts","../src/workers/constants.ts","../src/workers/SyncWorker.ts","../src/v2/fetchStoreEvents.ts","../src/v2/common.ts","../src/v2/ecsEventFromLog.ts","../src/v2/decodeStoreSetRecord.ts","../src/v2/schemas/decodeSchema.ts","../src/v2/schemas/tableSchemas.ts","../src/v2/schemas/tableMetadata.ts","../src/v2/schemas/decodeData.ts","../src/v2/schemas/decodeStaticField.ts","../src/v2/schemas/decodeDynamicField.ts","../src/v2/schemas/decodeKeyTuple.ts","../src/v2/schemas/decodeField.ts","../src/v2/decodeStoreSetField.ts","../src/v2/keyTupleToEntityID.ts","../src/v2/mode/createModeClient.ts","../src/v2/mode/syncTablesFromMode.ts","../src/v2/mode/getBlockNumberFromModeTable.ts","../src/v2/schemas/decodeValue.ts","../src/v2/mode/getModeBlockNumber.ts","../src/v2/transformTableRecordsIntoEvents.ts","../src/v2/syncUtils.ts"],"sourcesContent":["import { Result } from \"@ethersproject/abi\";\nimport { ExternalProvider } from \"@ethersproject/providers\";\nimport { Components, ComponentValue, Entity, SchemaOf } from \"@latticexyz/recs\";\nimport { TxMetadata } from \"@latticexyz/services/ecs-stream\";\nimport { Cached } from \"@latticexyz/utils\";\nimport { TableId } from \"@latticexyz/common/deprecated\";\nimport { BaseContract, BigNumber, ContractInterface } from \"ethers\";\nimport { Observable } from \"rxjs\";\nimport { SyncState } from \"./workers\";\nimport { MUDChain } from \"@latticexyz/common/chains\";\n\nexport interface NetworkConfig {\n  chainId: number;\n  privateKey?: string;\n  clock: ClockConfig;\n  provider: ProviderConfig;\n  snapshotServiceUrl?: string;\n  streamServiceUrl?: string;\n  initialBlockNumber?: number;\n  blockExplorer?: string;\n  cacheAgeThreshold?: number;\n  cacheInterval?: number;\n  encoders?: boolean;\n  pruneOptions?: { playerAddress: string; hashedComponentId: string };\n  chainConfig?: MUDChain;\n}\n\nexport interface ClockConfig {\n  period: number;\n  initialTime: number;\n  syncInterval: number;\n}\n\nexport type Clock = {\n  time$: Observable<number>;\n  currentTime: number;\n  lastUpdateTime: number;\n  update: (time: number, maintainStale?: boolean) => void;\n  dispose: () => void;\n};\n\nexport interface ProviderConfig {\n  chainId: number;\n  jsonRpcUrl: string;\n  wsRpcUrl?: string;\n  externalProvider?: ExternalProvider;\n  options?: { batch?: boolean; pollingInterval?: number; skipNetworkCheck?: boolean };\n}\n\nexport type Contracts = {\n  [key: string]: BaseContract;\n};\n\nexport type ContractConfig = {\n  address: string;\n  abi: ContractInterface;\n};\n\nexport type ContractsConfig<C extends Contracts> = {\n  [key in keyof C]: ContractConfig;\n};\n\nexport type TxQueue<C extends Contracts> = Cached<C>;\n\nexport type ContractTopics = {\n  key: string;\n  topics: string[][];\n};\n\nexport type ContractEvent<C extends Contracts> = {\n  contractKey: keyof C;\n  eventKey: string;\n  args: Result;\n  txHash: string;\n  lastEventInTx: boolean;\n  blockNumber: number;\n  // TODO: make this required, so we can later sort by logIndex when concatenating event types\n  //       would require updating the ECS snapshot, though\n  logIndex?: number;\n};\n\n// Mapping from hashed contract component id to client component key\nexport type Mappings<C extends Components> = {\n  [hashedContractId: string]: keyof C;\n};\n\nexport type NetworkComponentUpdate<C extends Components = Components> = {\n  [key in keyof C]: {\n    type: NetworkEvents.NetworkComponentUpdate;\n    component: key & string;\n    value: ComponentValue<SchemaOf<C[key]>> | undefined;\n    partialValue?: Partial<ComponentValue<SchemaOf<C[key]>>>;\n    initialValue?: ComponentValue<SchemaOf<C[key]>>;\n    ephemeral?: boolean;\n    devEmit?: () => void;\n  };\n}[keyof C] & {\n  entity: Entity;\n  namespace: string;\n  table: string;\n  key: Record<string, unknown>;\n  lastEventInTx: boolean;\n  txHash: string;\n  txMetadata?: TxMetadata;\n  blockNumber: number;\n  // TODO: make this required, so we can later sort by logIndex when concatenating event types\n  //       would require updating the ECS snapshot, though\n  logIndex?: number;\n};\n\nexport type SystemCallTransaction = {\n  hash: string;\n  to: string;\n  data: string;\n  value: BigNumber;\n};\n\nexport type SystemCall<C extends Components = Components> = {\n  type: NetworkEvents.SystemCall;\n  tx: SystemCallTransaction;\n  updates: NetworkComponentUpdate<C>[];\n};\n\nexport enum NetworkEvents {\n  SystemCall = \"SystemCall\",\n  NetworkComponentUpdate = \"NetworkComponentUpdate\",\n}\n\nexport type NetworkEvent<C extends Components = Components> = SystemCall<C> | NetworkComponentUpdate<C>;\nexport function isSystemCallEvent<C extends Components>(e: NetworkEvent<C>): e is SystemCall<C> {\n  return e.type === NetworkEvents.SystemCall;\n}\n\nexport function isNetworkComponentUpdateEvent<C extends Components>(\n  e: NetworkEvent<C>\n): e is NetworkComponentUpdate<C> {\n  return e.type === NetworkEvents.NetworkComponentUpdate;\n}\n\nexport type RawTableRecord = {\n  tableId: TableId;\n  keyTuple: string[];\n  value: string;\n};\n\nexport type SyncWorkerConfig = {\n  provider: ProviderConfig;\n  initialBlockNumber: number;\n  worldContract: ContractConfig;\n  disableCache?: boolean;\n  chainId: number;\n  modeUrl?: string;\n  snapshotServiceUrl?: string;\n  streamServiceUrl?: string;\n  fetchSystemCalls?: boolean;\n  cacheInterval?: number;\n  cacheAgeThreshold?: number;\n  snapshotNumChunks?: number;\n  pruneOptions?: { playerAddress: string; hashedComponentId: string };\n  initialRecords?: RawTableRecord[];\n};\n\nexport enum ContractSchemaValue {\n  BOOL,\n  INT8,\n  INT16,\n  INT32,\n  INT64,\n  INT128,\n  INT256,\n  INT,\n  UINT8,\n  UINT16,\n  UINT32,\n  UINT64,\n  UINT128,\n  UINT256,\n  BYTES,\n  STRING,\n  ADDRESS,\n  BYTES4,\n  BOOL_ARRAY,\n  INT8_ARRAY,\n  INT16_ARRAY,\n  INT32_ARRAY,\n  INT64_ARRAY,\n  INT128_ARRAY,\n  INT256_ARRAY,\n  INT_ARRAY,\n  UINT8_ARRAY,\n  UINT16_ARRAY,\n  UINT32_ARRAY,\n  UINT64_ARRAY,\n  UINT128_ARRAY,\n  UINT256_ARRAY,\n  BYTES_ARRAY,\n  STRING_ARRAY,\n}\n\nexport const ContractSchemaValueId: { [key in ContractSchemaValue]: string } = {\n  [ContractSchemaValue.BOOL]: \"bool\",\n  [ContractSchemaValue.INT8]: \"int8\",\n  [ContractSchemaValue.INT16]: \"int16\",\n  [ContractSchemaValue.INT32]: \"int32\",\n  [ContractSchemaValue.INT64]: \"int64\",\n  [ContractSchemaValue.INT128]: \"int128\",\n  [ContractSchemaValue.INT256]: \"int256\",\n  [ContractSchemaValue.INT]: \"int\",\n  [ContractSchemaValue.UINT8]: \"uint8\",\n  [ContractSchemaValue.UINT16]: \"uint16\",\n  [ContractSchemaValue.UINT32]: \"uint32\",\n  [ContractSchemaValue.UINT64]: \"uint64\",\n  [ContractSchemaValue.UINT128]: \"uint128\",\n  [ContractSchemaValue.UINT256]: \"uint256\",\n  [ContractSchemaValue.BYTES]: \"bytes\",\n  [ContractSchemaValue.STRING]: \"string\",\n  [ContractSchemaValue.ADDRESS]: \"address\",\n  [ContractSchemaValue.BYTES4]: \"bytes4\",\n  [ContractSchemaValue.BOOL_ARRAY]: \"bool[]\",\n  [ContractSchemaValue.INT8_ARRAY]: \"int8[]\",\n  [ContractSchemaValue.INT16_ARRAY]: \"int16[]\",\n  [ContractSchemaValue.INT32_ARRAY]: \"int32[]\",\n  [ContractSchemaValue.INT64_ARRAY]: \"int64[]\",\n  [ContractSchemaValue.INT128_ARRAY]: \"int128[]\",\n  [ContractSchemaValue.INT256_ARRAY]: \"int256[]\",\n  [ContractSchemaValue.INT_ARRAY]: \"int[]\",\n  [ContractSchemaValue.UINT8_ARRAY]: \"uint8[]\",\n  [ContractSchemaValue.UINT16_ARRAY]: \"uint16[]\",\n  [ContractSchemaValue.UINT32_ARRAY]: \"uint32[]\",\n  [ContractSchemaValue.UINT64_ARRAY]: \"uint64[]\",\n  [ContractSchemaValue.UINT128_ARRAY]: \"uint128[]\",\n  [ContractSchemaValue.UINT256_ARRAY]: \"uint256[]\",\n  [ContractSchemaValue.BYTES_ARRAY]: \"bytes[]\",\n  [ContractSchemaValue.STRING_ARRAY]: \"string[]\",\n};\n\nexport const ContractSchemaValueArrayToElement = {\n  [ContractSchemaValue.BOOL_ARRAY]: ContractSchemaValue.BOOL,\n  [ContractSchemaValue.INT8_ARRAY]: ContractSchemaValue.INT8,\n  [ContractSchemaValue.INT16_ARRAY]: ContractSchemaValue.INT16,\n  [ContractSchemaValue.INT32_ARRAY]: ContractSchemaValue.INT32,\n  [ContractSchemaValue.INT64_ARRAY]: ContractSchemaValue.INT64,\n  [ContractSchemaValue.INT128_ARRAY]: ContractSchemaValue.INT128,\n  [ContractSchemaValue.INT256_ARRAY]: ContractSchemaValue.INT256,\n  [ContractSchemaValue.INT_ARRAY]: ContractSchemaValue.INT,\n  [ContractSchemaValue.UINT8_ARRAY]: ContractSchemaValue.UINT8,\n  [ContractSchemaValue.UINT16_ARRAY]: ContractSchemaValue.UINT16,\n  [ContractSchemaValue.UINT32_ARRAY]: ContractSchemaValue.UINT32,\n  [ContractSchemaValue.UINT64_ARRAY]: ContractSchemaValue.UINT64,\n  [ContractSchemaValue.UINT128_ARRAY]: ContractSchemaValue.UINT128,\n  [ContractSchemaValue.UINT256_ARRAY]: ContractSchemaValue.INT256,\n  [ContractSchemaValue.BYTES_ARRAY]: ContractSchemaValue.BYTES,\n  [ContractSchemaValue.STRING_ARRAY]: ContractSchemaValue.STRING,\n} as { [key in ContractSchemaValue]: ContractSchemaValue };\n\nexport type ContractSchemaValueTypes = {\n  [ContractSchemaValue.BOOL]: boolean;\n  [ContractSchemaValue.INT8]: number;\n  [ContractSchemaValue.INT16]: number;\n  [ContractSchemaValue.INT32]: number;\n  [ContractSchemaValue.INT64]: string;\n  [ContractSchemaValue.INT128]: string;\n  [ContractSchemaValue.INT256]: string;\n  [ContractSchemaValue.INT]: string;\n  [ContractSchemaValue.UINT8]: number;\n  [ContractSchemaValue.UINT16]: number;\n  [ContractSchemaValue.UINT32]: number;\n  [ContractSchemaValue.UINT64]: string;\n  [ContractSchemaValue.UINT128]: string;\n  [ContractSchemaValue.UINT256]: string;\n  [ContractSchemaValue.BYTES]: string;\n  [ContractSchemaValue.STRING]: string;\n  [ContractSchemaValue.ADDRESS]: string;\n  [ContractSchemaValue.BYTES4]: string;\n  [ContractSchemaValue.BOOL_ARRAY]: boolean[];\n  [ContractSchemaValue.INT8_ARRAY]: number[];\n  [ContractSchemaValue.INT16_ARRAY]: number[];\n  [ContractSchemaValue.INT32_ARRAY]: number[];\n  [ContractSchemaValue.INT64_ARRAY]: string[];\n  [ContractSchemaValue.INT128_ARRAY]: string[];\n  [ContractSchemaValue.INT256_ARRAY]: string[];\n  [ContractSchemaValue.INT_ARRAY]: string[];\n  [ContractSchemaValue.UINT8_ARRAY]: number[];\n  [ContractSchemaValue.UINT16_ARRAY]: number[];\n  [ContractSchemaValue.UINT32_ARRAY]: number[];\n  [ContractSchemaValue.UINT64_ARRAY]: string[];\n  [ContractSchemaValue.UINT128_ARRAY]: string[];\n  [ContractSchemaValue.UINT256_ARRAY]: string[];\n  [ContractSchemaValue.BYTES_ARRAY]: string[];\n  [ContractSchemaValue.STRING_ARRAY]: string[];\n};\n\nexport type SyncStateStruct = {\n  state: SyncState;\n  msg: string;\n  percentage: number;\n};\n","import {\n  JsonRpcProvider,\n  WebSocketProvider,\n  Block,\n  Log,\n  Formatter,\n  BaseProvider,\n  TransactionRequest,\n} from \"@ethersproject/providers\";\nimport { callWithRetry, extractEncodedArguments, range, sleep } from \"@latticexyz/utils\";\nimport { BigNumber, Contract } from \"ethers\";\nimport { resolveProperties, defaultAbiCoder as abi } from \"ethers/lib/utils.js\";\nimport { Contracts, ContractTopics, ContractEvent, ContractsConfig } from \"./types\";\n\n/**\n * Await network to be reachable.\n *\n * @param provider ethers JsonRpcProvider\n * @param wssProvider ethers WebSocketProvider\n * @returns Promise resolving once the network is reachable\n */\nexport async function ensureNetworkIsUp(provider: JsonRpcProvider, wssProvider?: WebSocketProvider): Promise<void> {\n  const networkInfoPromise = () => {\n    return Promise.all([provider.getBlockNumber(), wssProvider ? wssProvider.getBlockNumber() : Promise.resolve()]);\n  };\n  await callWithRetry(networkInfoPromise, [], 10, 1000);\n  return;\n}\n\n/**\n * Fetch the latest Ethereum block\n *\n * @param provider ethers JsonRpcProvider\n * @param requireMinimumBlockNumber Minimal required block number.\n * If the latest block number is below this number, the method waits for 1300ms and tries again, for at most 10 times.\n * @returns Promise resolving with the latest Ethereum block\n */\nexport async function fetchBlock(provider: JsonRpcProvider, requireMinimumBlockNumber?: number): Promise<Block> {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const _ of range(10)) {\n    const blockPromise = async () => {\n      const rawBlock = await provider.perform(\"getBlock\", {\n        includeTransactions: false,\n        blockTag: provider.formatter.blockTag(await provider._getBlockTag(\"latest\")),\n      });\n      return provider.formatter.block(rawBlock);\n    };\n    const block = await callWithRetry<Block>(blockPromise, [], 10, 1000);\n    if (requireMinimumBlockNumber && block.number < requireMinimumBlockNumber) {\n      await sleep(300);\n      continue;\n    } else {\n      return block;\n    }\n  }\n  throw new Error(\"Could not fetch a block with blockNumber \" + requireMinimumBlockNumber);\n}\n\n/**\n * Fetch logs with the given topics from a given block range.\n *\n * @param provider ethers JsonRpcProvider\n * @param topics Topics to fetch logs for\n * @param startBlockNumber Start of block range to fetch logs from (inclusive)\n * @param endBlockNumber End of block range to fetch logs from (inclusive)\n * @param contracts Contracts to fetch logs from\n * @param requireMinimumBlockNumber Minimal block number required to fetch blocks\n * @returns Promise resolving with an array of logs from the specified block range and topics\n */\nexport async function fetchLogs<C extends Contracts>(\n  provider: JsonRpcProvider,\n  topics: ContractTopics[],\n  startBlockNumber: number,\n  endBlockNumber: number,\n  contracts: ContractsConfig<C>,\n  requireMinimumBlockNumber?: number\n): Promise<Array<Log>> {\n  const getLogPromise = async (contractAddress: string, topics: string[][]): Promise<Array<Log>> => {\n    const params = await resolveProperties({\n      filter: provider._getFilter({\n        fromBlock: startBlockNumber, // inclusive\n        toBlock: endBlockNumber, // inclusive\n        address: contractAddress,\n        topics: topics,\n      }),\n    });\n    const logs: Array<Log> = await provider.perform(\"getLogs\", params);\n    logs.forEach((log) => {\n      if (log.removed == null) {\n        log.removed = false;\n      }\n    });\n    return Formatter.arrayOf(provider.formatter.filterLog.bind(provider.formatter))(logs);\n  };\n\n  const blockPromise = async () => {\n    const _blockNumber = await provider.perform(\"getBlockNumber\", {});\n    const blockNumber = BigNumber.from(_blockNumber).toNumber();\n    return blockNumber;\n  };\n\n  const getLogPromises = () => {\n    const logPromises: Array<Promise<Array<Log>>> = [];\n    for (const [k, c] of Object.entries(contracts)) {\n      const topicsForContract = topics.find((t) => t.key === k)?.topics;\n      if (topicsForContract) {\n        logPromises.push(getLogPromise(c.address, topicsForContract));\n      }\n    }\n    return logPromises;\n  };\n\n  if (requireMinimumBlockNumber) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const _ in range(10)) {\n      const call = () => Promise.all([blockPromise(), ...getLogPromises()]);\n      const [blockNumber, logs] = await callWithRetry<[number, ...Array<Array<Log>>]>(call, [], 10, 1000);\n      if (blockNumber < requireMinimumBlockNumber) {\n        await sleep(500);\n      } else {\n        return logs.flat();\n      }\n    }\n    throw new Error(\"Could not fetch logs with a required minimum block number\");\n  } else {\n    const call = () => Promise.all([...getLogPromises()]);\n    const logs = await callWithRetry<Array<Array<Log>>>(call, [], 10, 1000);\n    return logs.flat();\n  }\n}\n\n/**\n * Fetch events from block range, ordered by block, transaction index and log index\n *\n * @param provider ethers JsonRpcProvider\n * @param topics Topics to fetch events for\n * @param startBlockNumber Start of block range to fetch events from (inclusive)\n * @param endBlockNumber End of block range to fetch events from (inclusive)\n * @param contracts Contracts to fetch events from\n * @param supportsBatchQueries Set to true if the provider supports batch queries (recommended)\n * @returns Promise resolving with an array of ContractEvents\n */\nexport async function fetchEventsInBlockRange<C extends Contracts>(\n  provider: JsonRpcProvider,\n  topics: ContractTopics[],\n  startBlockNumber: number,\n  endBlockNumber: number,\n  contracts: ContractsConfig<C>,\n  supportsBatchQueries?: boolean\n): Promise<Array<ContractEvent<C>>> {\n  const logs: Array<Log> = await fetchLogs(\n    provider,\n    topics,\n    startBlockNumber,\n    endBlockNumber,\n    contracts,\n    supportsBatchQueries ? endBlockNumber : undefined\n  );\n\n  // console.log(`[Network] fetched ${logs.length} events from ${startBlockNumber} -> ${endBlockNumber}`);\n  // console.log(`got ${logs.length} logs from range ${startBlockNumber} -> ${endBlockNumber}`);\n  // we need to sort per block, transaction index, and log index\n  logs.sort((a: Log, b: Log) => {\n    if (a.blockNumber < b.blockNumber) {\n      return -1;\n    } else if (a.blockNumber > b.blockNumber) {\n      return 1;\n    } else {\n      if (a.transactionIndex < b.transactionIndex) {\n        return -1;\n      } else if (a.transactionIndex > b.transactionIndex) {\n        return 1;\n      } else {\n        return a.logIndex < b.logIndex ? -1 : 1;\n      }\n    }\n  });\n\n  // construct an object: address => keyof C\n  const addressToContractKey: { [key in string]: keyof C } = {};\n  for (const contractKey of Object.keys(contracts)) {\n    addressToContractKey[contracts[contractKey].address.toLowerCase()] = contractKey;\n  }\n\n  // parse the logs to get the logs description, then turn them into contract events\n  const contractEvents: Array<ContractEvent<C>> = [];\n\n  for (let i = 0; i < logs.length; i++) {\n    const log = logs[i];\n    const contractKey = addressToContractKey[log.address.toLowerCase()];\n    if (!contractKey) {\n      throw new Error(\n        \"This should not happen. An event's address is not part of the contracts dictionnary: \" + log.address\n      );\n    }\n\n    const { address, abi } = contracts[contractKey];\n    const contract = new Contract(address, abi);\n    try {\n      const logDescription = contract.interface.parseLog(log);\n\n      // Set a flag if this is the last event in this transaction\n      const lastEventInTx = logs[i + 1]?.transactionHash !== log.transactionHash;\n\n      contractEvents.push({\n        contractKey,\n        eventKey: logDescription.name,\n        args: logDescription.args,\n        txHash: log.transactionHash,\n        lastEventInTx,\n        blockNumber: log.blockNumber,\n        logIndex: log.logIndex,\n      });\n    } catch (e) {\n      console.warn(\"Error\", e);\n      console.warn(\"A log couldn't be parsed with the corresponding contract interface!\");\n    }\n  }\n\n  return contractEvents;\n}\n\n/**\n * Get the revert reason from a given transaction hash\n *\n * @param txHash Transaction hash to get the revert reason from\n * @param provider ethers Provider\n * @returns Promise resolving with revert reason string\n */\nexport async function getRevertReason(txHash: string, provider: BaseProvider): Promise<string> {\n  // Decoding the revert reason: https://docs.soliditylang.org/en/latest/control-structures.html#revert\n  const tx = await provider.getTransaction(txHash);\n  if (!tx) throw new Error(\"This transaction doesn't exist. Can't get the revert reason\");\n  tx.gasPrice = undefined; // tx object contains both gasPrice and maxFeePerGas\n  const encodedRevertReason = await provider.call(tx as TransactionRequest);\n  const decodedRevertReason = abi.decode([\"string\"], extractEncodedArguments(encodedRevertReason));\n  return decodedRevertReason[0];\n}\n","import { Networkish, Web3Provider, WebSocketProvider } from \"@ethersproject/providers\";\nimport { callWithRetry, observableToComputed, timeoutAfter } from \"@latticexyz/utils\";\nimport { IComputedValue, IObservableValue, observable, reaction, runInAction } from \"mobx\";\nimport { ensureNetworkIsUp } from \"./networkUtils\";\nimport { MUDJsonRpcBatchProvider, MUDJsonRpcProvider } from \"./provider\";\nimport { ProviderConfig } from \"./types\";\n\nexport type Providers = ReturnType<typeof createProvider>;\n\n/**\n * Create a JsonRpcProvider and WebsocketProvider pair\n *\n * @param config Config for the provider pair (see {@link ProviderConfig}).\n * @returns Provider pair: {\n *   json: JsonRpcProvider,\n *   ws: WebSocketProvider\n * }\n */\nexport function createProvider({ chainId, jsonRpcUrl, wsRpcUrl, externalProvider, options }: ProviderConfig) {\n  const network: Networkish = {\n    chainId,\n    name: \"mudChain\",\n  };\n  const providers = externalProvider\n    ? { json: new Web3Provider(externalProvider, network), ws: undefined }\n    : {\n        json: options?.batch\n          ? new MUDJsonRpcBatchProvider(jsonRpcUrl, network)\n          : new MUDJsonRpcProvider(jsonRpcUrl, network),\n        ws: wsRpcUrl ? new WebSocketProvider(wsRpcUrl, network) : undefined,\n      };\n\n  if (options?.pollingInterval) {\n    providers.json.pollingInterval = options.pollingInterval;\n  }\n\n  return providers;\n}\n\nexport enum ConnectionState {\n  DISCONNECTED,\n  CONNECTING,\n  CONNECTED,\n}\n\n/**\n * Creates a {@link createProvider provider pair} that automatically updates if the config changes\n * and automatically reconnects if the connection is lost.\n *\n * @param config Mobx computed provider config object (see {@link ProviderConfig}).\n * Automatically updates the returned provider pair if the config changes.\n * @returns Automatically reconnecting {@link createProvider provider pair} that updates if the config changes.\n */\nexport async function createReconnectingProvider(config: IComputedValue<ProviderConfig>) {\n  const connected = observable.box<ConnectionState>(ConnectionState.DISCONNECTED);\n  const providers = observable.box<Providers>() as IObservableValue<Providers>;\n  const disposers: (() => void)[] = [];\n\n  async function initProviders() {\n    // Abort if connection is currently being established\n    if (connected.get() === ConnectionState.CONNECTING) return;\n\n    // Invalidate current providers\n    runInAction(() => connected.set(ConnectionState.CONNECTING));\n\n    // Remove listeners from stale providers and close open connections\n    const prevProviders = providers.get();\n    prevProviders?.json.removeAllListeners();\n    prevProviders?.ws?.removeAllListeners();\n    try {\n      prevProviders?.ws?._websocket?.close();\n    } catch {\n      // Ignore errors when closing websocket that was not in an open state\n    }\n\n    const conf = config.get();\n\n    // Create new providers\n    await callWithRetry(async () => {\n      const newProviders = createProvider(conf);\n      // If the connection is not successful, this will throw an error, triggering a retry\n      !conf?.options?.skipNetworkCheck && (await ensureNetworkIsUp(newProviders.json, newProviders.ws));\n      runInAction(() => {\n        providers.set(newProviders);\n        connected.set(ConnectionState.CONNECTED);\n      });\n    });\n  }\n\n  // Create new providers if config changes\n  disposers.push(\n    reaction(\n      () => config.get(),\n      () => initProviders()\n    )\n  );\n\n  // Reconnect providers in case of error\n  disposers.push(\n    reaction(\n      () => providers.get(),\n      (currentProviders) => {\n        if (currentProviders?.ws?._websocket) {\n          currentProviders.ws._websocket.onerror = initProviders;\n          currentProviders.ws._websocket.onclose = () => {\n            // Only reconnect if closed unexpectedly\n            if (connected.get() === ConnectionState.CONNECTED) {\n              initProviders();\n            }\n          };\n        }\n      }\n    )\n  );\n\n  // Keep websocket connection alive\n  const keepAliveInterval = setInterval(async () => {\n    if (connected.get() !== ConnectionState.CONNECTED) return;\n    const currentProviders = providers.get();\n    if (!currentProviders?.ws) return;\n    try {\n      await timeoutAfter(currentProviders.ws.getBlockNumber(), 10000, \"Network Request Timed out\");\n    } catch {\n      initProviders();\n    }\n  }, 10000);\n  disposers.push(() => clearInterval(keepAliveInterval));\n\n  await initProviders();\n\n  return {\n    connected: observableToComputed(connected),\n    providers: observableToComputed(providers),\n    dispose: () => {\n      for (const disposer of disposers) disposer();\n      try {\n        providers.get()?.ws?._websocket?.close();\n      } catch {\n        // Ignore error if websocket is not on OPEN state\n      }\n    },\n  };\n}\n","import { JsonRpcBatchProvider, JsonRpcProvider, Network, Networkish } from \"@ethersproject/providers\";\nimport { ConnectionInfo } from \"ethers/lib/utils.js\";\n\nexport class MUDJsonRpcProvider extends JsonRpcProvider {\n  constructor(url: string | ConnectionInfo | undefined, network: Networkish) {\n    super(url, network);\n  }\n  async detectNetwork(): Promise<Network> {\n    const network = this.network;\n    if (network == null) {\n      throw new Error(\"No network\");\n    }\n    return network;\n  }\n}\n\nexport class MUDJsonRpcBatchProvider extends JsonRpcBatchProvider {\n  constructor(url?: string | ConnectionInfo | undefined, network?: Networkish | undefined) {\n    super(url, network);\n  }\n  async detectNetwork(): Promise<Network> {\n    const network = this.network;\n    if (network == null) {\n      throw new Error(\"No network\");\n    }\n    return network;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { stretch } from \"@latticexyz/utils\";\nimport { IComputedValue, reaction } from \"mobx\";\nimport { concat, concatMap, EMPTY, endWith, filter, map, range, ReplaySubject, take } from \"rxjs\";\nimport { Providers } from \"./createProvider\";\n\n/**\n * Creates a stream of block numbers based on the `block` event of the currently connected provider.\n * In case `initialSync` is provided, this stream will also output a stream of past block numbers to drive replaying events.\n *\n * @param providers Mobx computed providers object (created by {@link createReconnectingProvider}).\n * @param options\n * @returns Stream of block numbers based on connected provider's `block` event.\n */\nexport function createBlockNumberStream(\n  providers: IComputedValue<Providers | undefined>,\n  options?: {\n    initialSync?: {\n      initialBlockNumber: number;\n      interval: number;\n    };\n  }\n) {\n  const blockNumberEvent$ = new ReplaySubject<number>(1);\n\n  const initialSync$ = options?.initialSync\n    ? blockNumberEvent$.pipe(\n        take(1), // Take the first block number\n        filter((blockNr) => blockNr > (options.initialSync!.initialBlockNumber || 0)), // Only do inital sync if the first block number we receive is larger than the block number to start from\n        concatMap((blockNr) => {\n          // Create a stepped range that ends with the current number\n          const blocksToSync = blockNr - options.initialSync!.initialBlockNumber;\n          return range(0, Math.ceil(blocksToSync / options.initialSync!.interval)).pipe(\n            map((i) => options.initialSync!.initialBlockNumber + i * options.initialSync!.interval),\n            endWith(blockNr)\n          );\n        }),\n        stretch(50) // Stretch processing of block number to one every 32 milliseconds (during initial sync)\n      )\n    : EMPTY;\n\n  const dispose = reaction(\n    () => providers.get(),\n    (currProviders) => {\n      const provider = currProviders?.ws || currProviders?.json;\n\n      let streamEmpty = true;\n      // Get the current block number (skipped if a new block arrives faster)\n      provider?.getBlockNumber().then((blockNumber) => {\n        if (streamEmpty) {\n          blockNumberEvent$.next(blockNumber);\n        }\n      });\n      // Stream new block numbers\n      provider?.on(\"block\", (blockNumber: number) => {\n        streamEmpty = false;\n        blockNumberEvent$.next(blockNumber);\n      });\n    },\n    { fireImmediately: true }\n  );\n\n  const blockNumber$ = concat(initialSync$, blockNumberEvent$);\n\n  return { blockNumber$, dispose };\n}\n","import { BehaviorSubject, Subject } from \"rxjs\";\nimport type { PublicClient, WalletClient, Chain, Transport } from \"viem\";\nimport type { CacheStore } from \"../workers\";\nimport { TableId } from \"@latticexyz/common/deprecated\";\nimport { StoreEvent, EphemeralEvent } from \"../v2/common\";\n\n// TODO: connection status?\n// TODO: sync status (rpc vs mode vs cache)\n\nexport const storeEvent$ = new Subject<{\n  chainId: number;\n  worldAddress: string;\n  transactionHash: string;\n  blockNumber: number;\n  logIndex: number;\n  event: StoreEvent | EphemeralEvent;\n  table: TableId;\n  keyTuple: any; // TODO: refine\n  indexedValues?: Record<number, any>; // TODO: refine\n  namedValues?: Record<string, any>; // TODO: refine\n}>();\n\nexport const transactionHash$ = new Subject<string>();\n\n// require chain for now so we can use it downstream\nexport const publicClient$: BehaviorSubject<PublicClient<Transport, Chain> | null> = new BehaviorSubject<PublicClient<\n  Transport,\n  Chain\n> | null>(null);\n// require chain for now so we can use it downstream\nexport const walletClient$: BehaviorSubject<WalletClient<Transport, Chain> | null> = new BehaviorSubject<WalletClient<\n  Transport,\n  Chain\n> | null>(null);\n\nexport const cacheStore$ = new BehaviorSubject<CacheStore | null>(null);\n\nexport const worldAddress$ = new BehaviorSubject<string | null>(null);\n","import { Components, ComponentValue, Entity, SchemaOf } from \"@latticexyz/recs\";\nimport { packTuple, transformIterator, unpackTuple } from \"@latticexyz/utils\";\nimport { initCache } from \"../initCache\";\nimport { ECSStateReply } from \"@latticexyz/services/ecs-snapshot\";\nimport { NetworkComponentUpdate, NetworkEvents } from \"../types\";\nimport { debug as parentDebug } from \"./debug\";\nimport { Subject } from \"rxjs\";\n\nconst debug = parentDebug.extend(\"CacheStore\");\n\nexport type State = Map<number, ComponentValue>;\nexport type CacheStore = ReturnType<typeof createCacheStore>;\nexport type ECSCache = Awaited<ReturnType<typeof getIndexDbECSCache>>;\n\nexport function getCacheId(namespace: string, chainId: number, worldAddress: string) {\n  return `${namespace}-${chainId}-${worldAddress}`;\n}\n\nexport function createCacheStore() {\n  const components: string[] = [];\n  const componentToIndex = new Map<string, number>();\n  const entities: string[] = [];\n  const entityToIndex = new Map<string, number>();\n  const blockNumber = 0;\n  const state: State = new Map<number, ComponentValue>();\n  const componentUpdate$ = new Subject<{ component: string; entity: Entity; blockNumber: number }>();\n  const keys: Record<number, Record<string | number, unknown>> = {}; // Mapping from entity index to key tuple\n  const tables: Record<number, { namespace: string; table: string }> = {}; // Mapping from component index to namespace/table\n\n  return { components, componentToIndex, entities, entityToIndex, blockNumber, state, componentUpdate$, keys, tables };\n}\n\nexport function storeEvent<Cm extends Components>(\n  cacheStore: CacheStore,\n  {\n    component,\n    entity,\n    value,\n    partialValue,\n    initialValue,\n    blockNumber,\n    key,\n    namespace,\n    table,\n  }: Omit<NetworkComponentUpdate<Cm>, \"lastEventInTx\" | \"txHash\">\n) {\n  const { components, entities, componentToIndex, entityToIndex, state, keys, tables } = cacheStore;\n\n  // Get component index\n  let componentIndex = componentToIndex.get(component);\n  if (componentIndex == null) {\n    componentIndex = components.push(component) - 1;\n    componentToIndex.set(component as string, componentIndex);\n  }\n\n  // Get entity index\n  let entityIndex = entityToIndex.get(entity);\n  if (entityIndex == null) {\n    entityIndex = entities.push(entity) - 1;\n    entityToIndex.set(entity, entityIndex);\n  }\n\n  // Store the key\n  if (key) {\n    keys[entityIndex] = key;\n  }\n\n  // Store the namespace/table\n  if (namespace != null && table != null) {\n    tables[componentIndex] = { namespace, table };\n  }\n\n  // Entity index gets the right 24 bits, component index the left 8 bits\n  const cacheKey = packTuple([componentIndex, entityIndex]);\n\n  // keep this logic aligned with applyNetworkUpdates\n  if (partialValue !== undefined) {\n    const currentValue = state.get(cacheKey);\n    state.set(cacheKey, { ...initialValue, ...currentValue, ...partialValue });\n  } else if (value === undefined) {\n    console.log(\"deleting key\", cacheKey);\n    state.delete(cacheKey);\n  } else {\n    state.set(cacheKey, value);\n  }\n\n  // Set block number to one less than the last received event's block number\n  // (Events are expected to be ordered, so once a new block number appears,\n  // the previous block number is done processing)\n  cacheStore.blockNumber = blockNumber - 1;\n\n  cacheStore.componentUpdate$.next({ component, entity, blockNumber });\n}\n\nexport function storeEvents<Cm extends Components>(\n  cacheStore: CacheStore,\n  events: Omit<NetworkComponentUpdate<Cm>, \"lastEventInTx\" | \"txHash\">[]\n) {\n  for (const event of events) {\n    storeEvent(cacheStore, event);\n  }\n}\n\nexport function getCacheStoreEntries<Cm extends Components>({\n  blockNumber,\n  state,\n  components,\n  entities,\n  keys,\n  tables,\n}: CacheStore): IterableIterator<NetworkComponentUpdate<Cm>> {\n  return transformIterator(state.entries(), ([cacheKey, value]) => {\n    const [componentIndex, entityIndex] = unpackTuple(cacheKey);\n    const component = components[componentIndex];\n    const entity = entities[entityIndex];\n    const key = keys[entityIndex];\n    const { namespace, table } = tables[componentIndex];\n\n    if (component == null || entity == null) {\n      throw new Error(`Unknown component / entity: ${component}, ${entity}`);\n    }\n\n    const ecsEvent: NetworkComponentUpdate<Cm> = {\n      type: NetworkEvents.NetworkComponentUpdate,\n      component,\n      entity: entity as Entity,\n      value: value as ComponentValue<SchemaOf<Cm[keyof Cm]>>,\n      namespace,\n      table,\n      key,\n      lastEventInTx: false,\n      txHash: \"cache\",\n      blockNumber: blockNumber,\n    };\n\n    return ecsEvent;\n  });\n}\n\nexport function mergeCacheStores(stores: CacheStore[]): CacheStore {\n  const result = createCacheStore();\n\n  // Sort by block number (increasing)\n  const sortedStores = [...stores].sort((a, b) => a.blockNumber - b.blockNumber);\n\n  // Insert the cached events into the result store (from stores with low block number to high number)\n  for (const store of sortedStores) {\n    for (const updateEvent of getCacheStoreEntries(store)) {\n      storeEvent(result, updateEvent);\n    }\n  }\n\n  result.blockNumber = sortedStores[sortedStores.length - 1].blockNumber;\n\n  return result;\n}\n\nexport async function saveCacheStoreToIndexDb(cache: ECSCache, store: CacheStore) {\n  debug(\"store cache with size\", store.state.size, \"at block\", store.blockNumber);\n  await cache.set(\"ComponentValues\", \"current\", store.state);\n  await cache.set(\"Mappings\", \"components\", store.components);\n  await cache.set(\"Mappings\", \"entities\", store.entities);\n  await cache.set(\"BlockNumber\", \"current\", store.blockNumber);\n  await cache.set(\"Keys\", \"current\", store.keys);\n  await cache.set(\"Tables\", \"current\", store.tables);\n}\n\nexport async function loadIndexDbCacheStore(cache: ECSCache): Promise<CacheStore> {\n  const state = (await cache.get(\"ComponentValues\", \"current\")) ?? new Map<number, ComponentValue>();\n  const blockNumber = (await cache.get(\"BlockNumber\", \"current\")) ?? 0;\n  const components = (await cache.get(\"Mappings\", \"components\")) ?? [];\n  const entities = (await cache.get(\"Mappings\", \"entities\")) ?? [];\n  const keys = (await cache.get(\"Keys\", \"current\")) ?? {};\n  const tables = (await cache.get(\"Tables\", \"current\")) ?? {};\n  const componentToIndex = new Map<string, number>();\n  const entityToIndex = new Map<string, number>();\n  const componentUpdate$ = new Subject<{ component: string; entity: Entity; blockNumber: number }>();\n\n  // Init componentToIndex map\n  for (let i = 0; i < components.length; i++) {\n    componentToIndex.set(components[i], i);\n  }\n\n  // Init entityToIndex map\n  for (let i = 0; i < entities.length; i++) {\n    entityToIndex.set(entities[i], i);\n  }\n\n  return { state, blockNumber, components, entities, componentToIndex, entityToIndex, componentUpdate$, keys, tables };\n}\n\nexport async function getIndexDBCacheStoreBlockNumber(cache: ECSCache): Promise<number> {\n  return (await cache.get(\"BlockNumber\", \"current\")) ?? 0;\n}\n\nexport function getIndexDbECSCache(chainId: number, worldAddress: string, version?: number, idb?: IDBFactory) {\n  return initCache<{\n    ComponentValues: State;\n    BlockNumber: number;\n    Mappings: string[];\n    Snapshot: ECSStateReply;\n    Keys: Record<number, Record<string | number, unknown>>;\n    Tables: Record<number, { namespace: string; table: string }>;\n  }>(\n    getCacheId(\"ECSCache\", chainId, worldAddress), // Store a separate cache for each World contract address\n    [\"ComponentValues\", \"BlockNumber\", \"Mappings\", \"Snapshot\", \"Keys\", \"Tables\"],\n    version,\n    idb\n  );\n}\n","import { arrayToIterator, deferred, mergeIterators, transformIterator } from \"@latticexyz/utils\";\n\nconst indexedDB = self.indexedDB;\nconst VERSION = 2;\n\n/**\n * Initialize an indexedDB store.\n *\n * @param db IDBDatabase\n * @param storeId Id of the store to initialize\n */\nfunction initStore(db: IDBDatabase, storeId: string) {\n  if (!db.objectStoreNames.contains(storeId)) {\n    db.createObjectStore(storeId);\n  }\n}\n\n/**\n * Initialize an indexedDB database.\n *\n * @param dbId Id of the database to initialize.\n * @param stores Keys of the stores to initialize.\n * @param version Optional: version of the database to initialize.\n * @param idb Optional: custom indexedDB factory\n * @returns Promise resolving with IDBDatabase object\n */\nfunction initDb(dbId: string, stores: string[], version = VERSION, idb: IDBFactory = indexedDB) {\n  const [resolve, reject, promise] = deferred<IDBDatabase>();\n\n  const request = idb.open(dbId, version);\n\n  // Create store and index\n  request.onupgradeneeded = () => {\n    const db = request.result;\n    for (const store of stores) {\n      initStore(db, store);\n    }\n  };\n\n  request.onsuccess = () => {\n    const db = request.result;\n    resolve(db);\n  };\n\n  request.onerror = (error) => {\n    reject(new Error(JSON.stringify(error)));\n  };\n\n  return promise;\n}\n\ntype Stores = { [key: string]: unknown };\ntype StoreKey<S extends Stores> = keyof S & string;\n\n/**\n * Initialize an abstracted Cache object to simplify interaction with the indexedDB database.\n *\n * @param id Id of the database to initialize.\n * @param stores Keys of the stores to initialize.\n * @param version Optional: version of the database to initialize.\n * @param idb Optional: custom indexedDB factory\n * @returns Promise resolving with Cache object\n */\nexport async function initCache<S extends Stores>(\n  id: string,\n  stores: StoreKey<S>[],\n  version?: number,\n  idb?: IDBFactory\n) {\n  const db = await initDb(id, stores, version, idb);\n\n  function openStore(store: StoreKey<S>): IDBObjectStore {\n    const tx = db.transaction(store, \"readwrite\");\n    const objectStore = tx.objectStore(store);\n    return objectStore;\n  }\n\n  function set<Store extends StoreKey<S>>(store: Store, key: string, value: S[Store], ignoreResult = false) {\n    const objectStore = openStore(store);\n    const request = objectStore.put(value, key);\n\n    if (ignoreResult) return;\n\n    const [resolve, reject, promise] = deferred<void>();\n\n    request.onerror = (error) => {\n      reject(new Error(JSON.stringify(error)));\n    };\n\n    request.onsuccess = () => {\n      resolve();\n    };\n\n    return promise;\n  }\n\n  function get<Store extends StoreKey<S>>(store: Store, key: string): Promise<S[Store] | undefined> {\n    const [resolve, reject, promise] = deferred<S[Store] | undefined>();\n\n    const objectStore = openStore(store);\n    const request = objectStore.get(key);\n\n    request.onerror = (error) => {\n      reject(new Error(JSON.stringify(error)));\n    };\n\n    request.onsuccess = () => {\n      const item = request.result;\n      resolve(item);\n    };\n\n    return promise;\n  }\n\n  function remove(store: StoreKey<S>, key: string): Promise<void> {\n    const [resolve, reject, promise] = deferred<void>();\n\n    const objectStore = openStore(store);\n    const request = objectStore.delete(key);\n\n    request.onerror = (error) => {\n      reject(new Error(JSON.stringify(error)));\n    };\n\n    request.onsuccess = () => {\n      resolve();\n    };\n\n    return promise;\n  }\n\n  function keys(store: StoreKey<S>): Promise<IterableIterator<string>> {\n    const [resolve, reject, promise] = deferred<IterableIterator<string>>();\n\n    const objectStore = openStore(store);\n    const request = objectStore.getAllKeys();\n\n    request.onerror = (error) => {\n      reject(new Error(JSON.stringify(error)));\n    };\n\n    request.onsuccess = () => {\n      const rawKeys = arrayToIterator(request.result);\n      const stringKeys = transformIterator(rawKeys, (k) => k.toString());\n      resolve(stringKeys);\n    };\n\n    return promise;\n  }\n\n  function values<Store extends StoreKey<S>>(store: Store): Promise<IterableIterator<S[Store]>> {\n    const [resolve, reject, promise] = deferred<IterableIterator<S[Store]>>();\n\n    const objectStore = openStore(store);\n    const request = objectStore.getAll();\n\n    request.onerror = (error) => {\n      reject(new Error(JSON.stringify(error)));\n    };\n\n    request.onsuccess = () => {\n      resolve(arrayToIterator(request.result));\n    };\n\n    return promise;\n  }\n\n  async function entries<Store extends StoreKey<S>>(store: Store): Promise<IterableIterator<[string, S[Store]]>> {\n    const [keyIterator, valueIterator] = await Promise.all([keys(store), values(store)]);\n    return mergeIterators(keyIterator, valueIterator);\n  }\n\n  return { set, get, remove, keys, values, entries, db };\n}\n","import createDebug from \"debug\";\n\nexport const debug = createDebug(\"mud:network\");\n","import { debug as parentDebug } from \"../debug\";\n\nexport const debug = parentDebug.extend(\"workers\");\n","import { Entity } from \"@latticexyz/recs\";\nimport { Hex, pad } from \"viem\";\n\nexport enum SyncState {\n  CONNECTING,\n  INITIAL,\n  LIVE,\n}\n\nexport const SingletonID = pad(\"0x060d\" as Hex, { size: 32 }) as Entity;\n\n/** @deprecated Import SingletonID instead */\nexport const GodID = SingletonID;\n","import { awaitStreamValue, DoWork, filterNullish, keccak256, streamToDefinedComputed } from \"@latticexyz/utils\";\nimport { bufferTime, concat, concatMap, filter, ignoreElements, map, Observable, of, Subject, take } from \"rxjs\";\nimport {\n  isNetworkComponentUpdateEvent,\n  NetworkComponentUpdate,\n  NetworkEvent,\n  NetworkEvents,\n  SyncStateStruct,\n  SyncWorkerConfig,\n} from \"../types\";\nimport { Components, ComponentValue, SchemaOf } from \"@latticexyz/recs\";\nimport {\n  createCacheStore,\n  getCacheStoreEntries,\n  getIndexDBCacheStoreBlockNumber,\n  getIndexDbECSCache,\n  loadIndexDbCacheStore,\n  saveCacheStoreToIndexDb,\n  storeEvent,\n  storeEvents,\n} from \"./CacheStore\";\nimport { createReconnectingProvider } from \"../createProvider\";\nimport { computed } from \"mobx\";\nimport { createBlockNumberStream } from \"../createBlockNumberStream\";\nimport { SingletonID, SyncState } from \"./constants\";\nimport { debug as parentDebug } from \"./debug\";\nimport { fetchStoreEvents } from \"../v2/fetchStoreEvents\";\nimport IStoreAbi from \"@latticexyz/store/abi/IStore.sol/IStore.abi.json\";\nimport { Contract } from \"ethers\";\nimport { createModeClient } from \"../v2/mode/createModeClient\";\nimport { syncTablesFromMode } from \"../v2/mode/syncTablesFromMode\";\nimport { getModeBlockNumber } from \"../v2/mode/getModeBlockNumber\";\nimport { transformTableRecordsIntoEvents } from \"../v2/transformTableRecordsIntoEvents\";\nimport * as devObservables from \"../dev/observables\";\nimport { getEventSelector } from \"viem\";\nimport { createLatestEventStreamRPC, fetchEventsInBlockRangeChunked } from \"../v2/syncUtils\";\n\nconst debug = parentDebug.extend(\"SyncWorker\");\n\nconst VERSION = 3;\n\nexport enum InputType {\n  Ack,\n  Config,\n}\nexport type Config = { type: InputType.Config; data: SyncWorkerConfig };\nexport type Ack = { type: InputType.Ack };\nexport const ack = { type: InputType.Ack as const };\nexport type Input = Config | Ack;\n\nexport class SyncWorker<C extends Components> implements DoWork<Input, NetworkEvent<C>[]> {\n  private input$ = new Subject<Input>();\n  private output$ = new Subject<NetworkEvent<C>>();\n  private syncState: SyncStateStruct = { state: SyncState.CONNECTING, msg: \"\", percentage: 0 };\n\n  constructor() {\n    debug(\"creating SyncWorker\");\n    this.init();\n  }\n\n  /**\n   * Pass a loading state component update to the main thread.\n   * Can be used to indicate the initial loading state on a loading screen.\n   * @param loadingState {\n   *  state: {@link SyncState},\n   *  msg: Message to describe the current loading step.\n   *  percentage: Number between 0 and 100 to describe the loading progress.\n   * }\n   * @param blockNumber Optional: block number to pass in the component update.\n   */\n  private setLoadingState(\n    loadingState: Partial<{ state: SyncState; msg: string; percentage: number }>,\n    blockNumber = 0\n  ) {\n    const newLoadingState = { ...this.syncState, ...loadingState };\n    this.syncState = newLoadingState;\n    const update: NetworkComponentUpdate<C> = {\n      type: NetworkEvents.NetworkComponentUpdate,\n      component: keccak256(\"component.LoadingState\"),\n      value: newLoadingState as unknown as ComponentValue<SchemaOf<C[keyof C]>>,\n      entity: SingletonID,\n      key: {},\n      namespace: \"mudsync\",\n      table: \"LoadingState\",\n      txHash: \"worker\",\n      lastEventInTx: false,\n      blockNumber,\n    };\n\n    this.output$.next(update);\n  }\n\n  /**\n   * Start the sync process.\n   *\n   * 1. Get config\n   * 2. Load initial state\n   *   2.1 Get cache block number\n   *   2.2 Get mode block number\n   *   2.3 Load from more recent source\n   * 3. Cach up to current block number by requesting events from RPC ( -> TODO: Replace with own service)\n   * 4. Keep in sync\n   *  4.1 If available keep in sync with mode\n   *  4.2 Else keep in sync with RPC\n   */\n  private async init() {\n    this.setLoadingState({ state: SyncState.CONNECTING, msg: \"Connecting...\", percentage: 0 });\n\n    // Turn config into variable accessible outside the stream\n    const computedConfig = await streamToDefinedComputed(\n      this.input$.pipe(\n        map((e) => (e.type === InputType.Config ? e.data : undefined)),\n        filterNullish()\n      )\n    );\n    const config = computedConfig.get();\n    const { modeUrl, chainId, worldContract, disableCache, initialRecords } = config;\n    devObservables.worldAddress$.next(worldContract.address);\n\n    // Set default values for cacheAgeThreshold and cacheInterval\n    const cacheAgeThreshold = config.cacheAgeThreshold || 100;\n    const cacheInterval = config.cacheInterval || 1;\n\n    // Set up\n    const { providers } = await createReconnectingProvider(computed(() => computedConfig.get().provider));\n    const provider = providers.get().json;\n    const modeClient = modeUrl ? createModeClient(modeUrl) : undefined;\n    const indexDbCache = await getIndexDbECSCache(chainId, worldContract.address, VERSION);\n\n    // Start syncing current events, but only start streaming to output once gap between initial state and current block is closed\n\n    debug(\"start initial sync\");\n    this.setLoadingState({ state: SyncState.INITIAL, msg: \"Starting initial sync\", percentage: 0 });\n    let passLiveEventsToOutput = false;\n    const cacheStore = { current: createCacheStore() };\n    devObservables.cacheStore$.next(cacheStore.current);\n    const { blockNumber$ } = createBlockNumberStream(providers);\n    // The RPC is only queried if this stream is subscribed to\n\n    const storeContract = new Contract(worldContract.address, IStoreAbi, provider);\n    const boundFetchStoreEvents = (fromBlock: number, toBlock: number) =>\n      fetchStoreEvents(storeContract, fromBlock, toBlock);\n\n    const latestEvent$ = createLatestEventStreamRPC(blockNumber$, boundFetchStoreEvents);\n\n    const initialLiveEvents: NetworkComponentUpdate<Components>[] = [];\n    latestEvent$.subscribe((event) => {\n      // If initial sync is in progress, temporary store the events to apply later\n      // Ignore system calls during initial sync\n      if (!passLiveEventsToOutput) {\n        if (isNetworkComponentUpdateEvent(event)) {\n          initialLiveEvents.push(event);\n        }\n        return;\n      }\n\n      if (isNetworkComponentUpdateEvent(event)) {\n        storeEvent(cacheStore.current, event);\n        // Store cache to indexdb every block\n        if (event.blockNumber > cacheStore.current.blockNumber + 1 && event.blockNumber % cacheInterval === 0) {\n          saveCacheStoreToIndexDb(indexDbCache, cacheStore.current);\n        }\n      }\n\n      const networkEvent = event as NetworkEvent<C>;\n      if (isNetworkComponentUpdateEvent(networkEvent)) {\n        // Remove devEmit from event before passing it to the main thread\n        // because it is not serializable\n        delete networkEvent.devEmit;\n      }\n\n      this.output$.next(networkEvent);\n    });\n    const streamStartBlockNumberPromise = awaitStreamValue(blockNumber$);\n\n    // Load initial state from cache or snapshot service\n    this.setLoadingState({ state: SyncState.INITIAL, msg: \"Fetching cache block number\", percentage: 0 });\n    const cacheBlockNumber = !disableCache ? await getIndexDBCacheStoreBlockNumber(indexDbCache) : -1;\n    this.setLoadingState({ percentage: 50 });\n    const modeBlockNumber = modeClient ? await getModeBlockNumber(modeClient, chainId) : -1;\n\n    let initialBlockNumber = config.initialBlockNumber;\n    if (initialBlockNumber < 0) {\n      const worldDeployLogs = await provider.getLogs({\n        address: worldContract.address,\n        topics: [getEventSelector(\"event HelloWorld()\")],\n        fromBlock: \"earliest\",\n      });\n      initialBlockNumber = worldDeployLogs.length > 0 ? worldDeployLogs[0].blockNumber : 0;\n    }\n\n    this.setLoadingState({ percentage: 100 });\n    debug(`cache block: ${cacheBlockNumber}, start sync at ${initialBlockNumber}`);\n\n    let initialState = createCacheStore();\n\n    if (initialRecords) {\n      console.log(\"Initial state from pre-loaded records\");\n      this.setLoadingState({ state: SyncState.INITIAL, msg: \"Loading initial state\", percentage: 0 });\n      const events = await transformTableRecordsIntoEvents(storeContract, initialRecords, initialBlockNumber);\n      storeEvents(initialState, events);\n      initialState.blockNumber = initialBlockNumber;\n    } else if (initialBlockNumber > Math.max(cacheBlockNumber, modeBlockNumber)) {\n      // Skip initializing from cache/mode if the initial block number is newer than all of them\n      initialState.blockNumber = initialBlockNumber;\n    } else {\n      // Load from cache if the mode is less than <cacheAgeThreshold> blocks newer than the cache\n      const syncFromMode = modeClient && modeBlockNumber > cacheBlockNumber + cacheAgeThreshold;\n      console.log(\"syncFromMode\", syncFromMode);\n\n      if (syncFromMode) {\n        console.log(\"Initial sync from MODE\");\n        this.setLoadingState({ state: SyncState.INITIAL, msg: \"Fetching initial state from MODE\", percentage: 0 });\n        initialState = await syncTablesFromMode(modeClient, chainId, storeContract, (percentage: number) =>\n          this.setLoadingState({ percentage })\n        );\n        this.setLoadingState({ percentage: 100 });\n      } else if (!disableCache) {\n        this.setLoadingState({ state: SyncState.INITIAL, msg: \"Fetching initial state from cache\", percentage: 0 });\n        initialState = await loadIndexDbCacheStore(indexDbCache);\n        this.setLoadingState({ percentage: 100 });\n      }\n\n      debug(`got ${initialState.state.size} items from ${syncFromMode ? \"mode\" : \"cache\"}`);\n    }\n\n    // Load events from gap between initial state and current block number from RPC\n    const streamStartBlockNumber = await streamStartBlockNumberPromise;\n    this.setLoadingState({\n      state: SyncState.INITIAL,\n      msg: `Fetching state from block ${initialState.blockNumber} to ${streamStartBlockNumber}`,\n      percentage: 0,\n    });\n\n    const gapStateEvents = await fetchEventsInBlockRangeChunked(\n      boundFetchStoreEvents,\n      initialState.blockNumber,\n      streamStartBlockNumber,\n      50,\n      (percentage: number) => this.setLoadingState({ percentage })\n    );\n\n    debug(\n      `got ${gapStateEvents.length} items from block range ${initialState.blockNumber} -> ${streamStartBlockNumber}`\n    );\n\n    // Merge initial state, gap state and live events since initial sync started\n    storeEvents(initialState, [...gapStateEvents, ...initialLiveEvents]);\n    cacheStore.current = initialState;\n    devObservables.cacheStore$.next(cacheStore.current);\n    debug(`initial sync state size: ${cacheStore.current.state.size}`);\n\n    this.setLoadingState({\n      state: SyncState.INITIAL,\n      msg: `Initializing with ${cacheStore.current.state.size} state entries`,\n      percentage: 0,\n    });\n\n    // Pass current cacheStore to output and start passing live events\n    let i = 0;\n    for (const update of getCacheStoreEntries(cacheStore.current)) {\n      i++;\n      this.output$.next(update as NetworkEvent<C>);\n      if (i % 5000 === 0) {\n        const percentage = Math.floor((i / cacheStore.current.state.size) * 100);\n        this.setLoadingState({ percentage });\n      }\n    }\n\n    // Save initial state to cache\n    saveCacheStoreToIndexDb(indexDbCache, cacheStore.current);\n\n    // Let the client know loading is complete\n    this.setLoadingState(\n      { state: SyncState.LIVE, msg: `Streaming live events`, percentage: 100 },\n      cacheStore.current.blockNumber\n    );\n    passLiveEventsToOutput = true;\n  }\n\n  public work(input$: Observable<Input>): Observable<NetworkEvent<C>[]> {\n    input$.subscribe(this.input$);\n    const throttledOutput$ = new Subject<NetworkEvent<C>[]>();\n\n    this.output$\n      .pipe(\n        bufferTime(16, null, 50),\n        filter((updates) => updates.length > 0),\n        concatMap((updates) =>\n          concat(\n            of(updates),\n            input$.pipe(\n              filter((e) => e.type === InputType.Ack),\n              take(1),\n              ignoreElements()\n            )\n          )\n        )\n      )\n      .subscribe(throttledOutput$);\n\n    return throttledOutput$;\n  }\n}\n","import { Contract } from \"ethers\";\nimport { NetworkComponentUpdate } from \"../types\";\nimport orderBy from \"lodash/orderBy\";\nimport { isDefined } from \"@latticexyz/common/utils\";\nimport { ephemeralEvents, storeEvents } from \"./common\";\nimport { ecsEventFromLog } from \"./ecsEventFromLog\";\n\nexport async function fetchStoreEvents(\n  store: Contract,\n  fromBlock: number,\n  toBlock: number\n): Promise<NetworkComponentUpdate[]> {\n  // TODO: pass the chain ID as an argument\n  const { chainId } = await store.provider.getNetwork();\n\n  const eventNames = [...storeEvents, ...ephemeralEvents];\n  const topicSets = eventNames.map((eventName) => store.filters[eventName]().topics).filter(isDefined);\n\n  const logSets = await Promise.all(\n    topicSets.map((topics) => store.provider.getLogs({ address: store.address, topics, fromBlock, toBlock }))\n  );\n\n  const logs = orderBy(\n    logSets.flatMap((logs) => logs.map((log) => ({ log, parsedLog: store.interface.parseLog(log) }))),\n    [\"log.blockNumber\", \"log.logIndex\"]\n  );\n\n  const lastLogForTx: Record<string, number> = {};\n  logs.map(({ log }) => {\n    lastLogForTx[log.transactionHash] = log.logIndex;\n  });\n\n  const unsortedEvents = await Promise.all(\n    logs.map(({ log, parsedLog }) => {\n      const { transactionHash, logIndex } = log;\n      return ecsEventFromLog(chainId, store, log, parsedLog, lastLogForTx[transactionHash] === logIndex);\n    })\n  );\n\n  const events = orderBy(unsortedEvents.filter(isDefined), [\"blockNumber\", \"logIndex\"]);\n\n  // We defer the emissions of dev events because `ecsEventFromLog` is async and emitting them\n  // from within that function causes them to arrive out of order. It's better if our emitter\n  // can guarantee ordering for now.\n  events.forEach((event) => event?.devEmit && event.devEmit());\n\n  return events;\n}\n","import { TableId } from \"@latticexyz/common/deprecated\";\nimport { SchemaType } from \"@latticexyz/schema-type/deprecated\";\n\nexport const schemaTableId = new TableId(\"mudstore\", \"schema\");\nexport const metadataTableId = new TableId(\"mudstore\", \"StoreMetadata\");\n\nexport const storeEvents = [\"StoreSetRecord\", \"StoreSetField\", \"StoreDeleteRecord\"] as const;\nexport const ephemeralEvents = [\"StoreEphemeralRecord\"] as const;\n\nexport type StoreEvent = (typeof storeEvents)[number];\nexport type EphemeralEvent = (typeof ephemeralEvents)[number];\n\nexport type TableSchema = { valueSchema: Schema; keySchema: Schema };\n\nexport type Schema = Readonly<{\n  staticDataLength: number;\n  staticFields: SchemaType[];\n  dynamicFields: SchemaType[];\n  rawSchema: string;\n  abi: string;\n  isEmpty: boolean;\n}>;\n\nexport type TableMetadata = Readonly<{\n  tableName: string;\n  fieldNames: string[];\n}>;\n","import { Contract, utils } from \"ethers\";\nimport { Log } from \"@ethersproject/providers\";\nimport { LogDescription } from \"@ethersproject/abi\";\nimport { TableId } from \"@latticexyz/common/deprecated\";\nimport { NetworkComponentUpdate, NetworkEvents } from \"../types\";\nimport { decodeStoreSetRecord } from \"./decodeStoreSetRecord\";\nimport { decodeStoreSetField } from \"./decodeStoreSetField\";\nimport { keyTupleToEntityID } from \"./keyTupleToEntityID\";\nimport * as devObservables from \"../dev/observables\";\nimport { registerSchema } from \"./schemas/tableSchemas\";\nimport { decodeKeyTuple } from \"./schemas/decodeKeyTuple\";\n\nexport const ecsEventFromLog = async (\n  chainId: number,\n  contract: Contract,\n  log: Log,\n  parsedLog: LogDescription,\n  lastEventInTx: boolean\n): Promise<NetworkComponentUpdate | undefined> => {\n  const { blockNumber, transactionHash, logIndex } = log;\n  const { args, name } = parsedLog;\n\n  const tableId = TableId.fromHex(args.table);\n  const component = tableId.toString();\n  const entity = keyTupleToEntityID(args.key);\n\n  const ecsEvent = {\n    type: NetworkEvents.NetworkComponentUpdate,\n    component,\n    entity,\n    value: undefined,\n    blockNumber,\n    txHash: transactionHash,\n    logIndex,\n    lastEventInTx,\n    namespace: tableId.namespace,\n    table: tableId.name,\n    key: {},\n  } satisfies NetworkComponentUpdate;\n\n  if (name === \"StoreSetRecord\") {\n    const { indexedValues, namedValues, indexedKey, namedKey } = await decodeStoreSetRecord(\n      contract,\n      tableId,\n      args.key,\n      args.data\n    );\n    return {\n      ...ecsEvent,\n      value: {\n        ...indexedValues,\n        ...namedValues,\n      },\n      key: {\n        ...indexedKey,\n        ...namedKey,\n      },\n      devEmit: () => {\n        devObservables.storeEvent$.next({\n          event: name,\n          chainId,\n          worldAddress: contract.address,\n          blockNumber,\n          logIndex,\n          transactionHash,\n          table: tableId,\n          keyTuple: args.key,\n          indexedValues,\n          namedValues,\n        });\n      },\n    };\n  }\n\n  if (name === \"StoreEphemeralRecord\") {\n    const { indexedValues, namedValues, indexedKey, namedKey } = await decodeStoreSetRecord(\n      contract,\n      tableId,\n      args.key,\n      args.data\n    );\n    return {\n      ...ecsEvent,\n      ephemeral: true,\n      value: {\n        ...indexedValues,\n        ...namedValues,\n      },\n      key: {\n        ...indexedKey,\n        ...namedKey,\n      },\n      devEmit: () => {\n        devObservables.storeEvent$.next({\n          event: name,\n          chainId,\n          worldAddress: contract.address,\n          blockNumber,\n          logIndex,\n          transactionHash,\n          table: tableId,\n          keyTuple: args.key,\n          indexedValues,\n          namedValues,\n        });\n      },\n    };\n  }\n\n  if (name === \"StoreSetField\") {\n    console.log(\"set field\");\n    const { indexedValues, indexedInitialValues, namedValues, namedInitialValues, indexedKey, namedKey } =\n      await decodeStoreSetField(contract, tableId, args.key, args.schemaIndex, args.data);\n    return {\n      ...ecsEvent,\n      partialValue: {\n        ...indexedValues,\n        ...namedValues,\n      },\n      initialValue: {\n        ...indexedInitialValues,\n        ...namedInitialValues,\n      },\n      key: {\n        ...indexedKey,\n        ...namedKey,\n      },\n      devEmit: () => {\n        devObservables.storeEvent$.next({\n          event: name,\n          chainId,\n          worldAddress: contract.address,\n          blockNumber,\n          logIndex,\n          transactionHash,\n          table: tableId,\n          keyTuple: args.key,\n          indexedValues,\n          namedValues,\n        });\n      },\n    };\n  }\n\n  if (name === \"StoreDeleteRecord\") {\n    const { keySchema } = await registerSchema(contract, tableId);\n    const indexedKey = decodeKeyTuple(keySchema, args.key);\n\n    return {\n      ...ecsEvent,\n      key: indexedKey,\n      devEmit: () => {\n        devObservables.storeEvent$.next({\n          event: name,\n          chainId,\n          worldAddress: contract.address,\n          blockNumber,\n          logIndex,\n          transactionHash,\n          table: tableId,\n          keyTuple: args.key,\n        });\n      },\n    };\n  }\n};\n","import { TableId } from \"@latticexyz/common/deprecated\";\nimport { Contract, utils } from \"ethers\";\nimport { registerSchema } from \"./schemas/tableSchemas\";\nimport { registerMetadata } from \"./schemas/tableMetadata\";\nimport { decodeData } from \"./schemas/decodeData\";\nimport { schemaTableId, metadataTableId } from \"./common\";\nimport { decodeKeyTuple } from \"./schemas/decodeKeyTuple\";\nimport { Hex } from \"viem\";\n\nexport async function decodeStoreSetRecord(\n  contract: Contract,\n  table: TableId,\n  keyTuple: string[],\n  data: string\n): Promise<{\n  indexedValues: Record<number, any>;\n  namedValues?: Record<string, any>;\n  indexedKey: Record<number, unknown>;\n  namedKey?: Record<string, unknown>;\n}> {\n  // registerSchema event\n  if (table.toHex() === schemaTableId.toHex()) {\n    const [tableForSchema, ...otherKeys] = keyTuple;\n    if (otherKeys.length) {\n      console.warn(\n        \"registerSchema event has more than one value in key tuple, but this method only supports a single key\",\n        { table, keyTuple }\n      );\n    }\n    registerSchema(contract, TableId.fromHex(tableForSchema as Hex), data);\n  }\n\n  const { keySchema, valueSchema } = await registerSchema(contract, table);\n  const indexedValues = decodeData(valueSchema, data);\n  const indexedKey = decodeKeyTuple(keySchema, keyTuple);\n\n  if (table.toHex() === metadataTableId.toHex()) {\n    const [tableForMetadata, ...otherKeys] = keyTuple;\n    if (otherKeys.length) {\n      console.warn(\n        \"setMetadata event has more than one value in key tuple, but this method only supports a single key\",\n        { table, keyTuple }\n      );\n    }\n    const tableName = indexedValues[0];\n    const [fieldNames] = utils.defaultAbiCoder.decode([\"string[]\"], indexedValues[1]);\n    registerMetadata(contract, TableId.fromHex(tableForMetadata as Hex), { tableName, fieldNames });\n  }\n\n  const metadata = await registerMetadata(contract, table);\n  if (metadata) {\n    const { tableName, fieldNames } = metadata;\n    const namedValues: Record<string, any> = {};\n    for (const [index, fieldName] of fieldNames.entries()) {\n      namedValues[fieldName] = indexedValues[index];\n    }\n\n    // TODO: once TableMetadata supports key names we can decode them here.\n    // For now we extract the key names of known tables from the `mud.config.ts`\n    // and ignore others in `applyNetworkUpdate`.\n    // (see https://github.com/latticexyz/mud/issues/824)\n\n    return {\n      indexedValues,\n      namedValues,\n      indexedKey,\n    };\n  }\n\n  console.warn(\n    `Received data for ${table.toString()}, but could not find table metadata for field names. Did your contracts get autogenerated and deployed properly?`\n  );\n  return {\n    indexedValues,\n    indexedKey,\n  };\n}\n","import { getStaticByteLength, SchemaType, SchemaTypeToAbiType } from \"@latticexyz/schema-type/deprecated\";\nimport { hexToArray } from \"@latticexyz/utils\";\nimport { TableSchema } from \"../common\";\n\nexport function decodeSchema(rawSchema: string): TableSchema {\n  const isEmpty = !rawSchema || rawSchema === \"0x\";\n  const buffer = isEmpty ? new Uint8Array(64).buffer : hexToArray(rawSchema).buffer;\n  const valueSchemaBytes = new DataView(buffer); // First 32 bytes of the raw schema are the value schema\n  const keySchemaBytes = new DataView(buffer.slice(32)); // Last 32 bytes of the raw schema are the key schema\n\n  const valueSchema = { ...decodeSchemaBytes(valueSchemaBytes), rawSchema, isEmpty };\n  const keySchema = { ...decodeSchemaBytes(keySchemaBytes), rawSchema, isEmpty };\n\n  return { valueSchema, keySchema };\n}\n\nfunction decodeSchemaBytes(schemaBytes: DataView) {\n  const staticDataLength = schemaBytes.getUint16(0);\n  const numStaticFields = schemaBytes.getUint8(2);\n  const numDynamicFields = schemaBytes.getUint8(3);\n  const staticFields: SchemaType[] = [];\n  const dynamicFields: SchemaType[] = [];\n  for (let i = 4; i < 4 + numStaticFields; i++) {\n    staticFields.push(schemaBytes.getUint8(i));\n  }\n  for (let i = 4 + numStaticFields; i < 4 + numStaticFields + numDynamicFields; i++) {\n    dynamicFields.push(schemaBytes.getUint8(i));\n  }\n\n  // validate static data length\n  const actualStaticDataLength = staticFields.reduce((acc, fieldType) => acc + getStaticByteLength(fieldType), 0);\n  if (actualStaticDataLength !== staticDataLength) {\n    console.error(\"Schema static data length mismatch! Is `getStaticByteLength` outdated?\", {\n      schemaStaticDataLength: staticDataLength,\n      actualStaticDataLength,\n      schemaBytes,\n    });\n    throw new Error(\"Schema static data length mismatch! Is `getStaticByteLength` outdated?\");\n  }\n\n  const abiTypes = [...staticFields, ...dynamicFields].map((type) => SchemaTypeToAbiType[type]);\n  const abi = `(${abiTypes.join(\",\")})`;\n\n  return { staticDataLength, staticFields, dynamicFields, abi };\n}\n","import { Contract } from \"ethers\";\nimport { TableId } from \"@latticexyz/common/deprecated\";\nimport { TableSchema } from \"../common\";\nimport { decodeSchema } from \"./decodeSchema\";\nimport { IStore } from \"@latticexyz/store/types/ethers-contracts/IStore.sol/IStore\";\n\n// worldAddress:tableId => schema\n// TODO: add chain ID to namespace?\nconst schemaCache: Partial<Record<`${string}:${string}`, Promise<TableSchema>>> = {};\n\n// the Contract arguments below assume that they're bound to a provider\n\nexport function getSchema(world: IStore, table: TableId): Promise<TableSchema> | undefined {\n  const cacheKey = `${world.address}:${table.toHex()}` as const;\n  return schemaCache[cacheKey];\n}\n\nexport function registerSchema(world: Contract, table: TableId, rawSchema?: string): Promise<TableSchema> {\n  const cacheKey = `${world.address}:${table.toHex()}` as const;\n\n  const existingSchema = schemaCache[cacheKey];\n  if (existingSchema) {\n    // Warn if a different schema was already registered\n    if (rawSchema) {\n      existingSchema.then((schema) => {\n        if (schema.valueSchema.rawSchema !== rawSchema) {\n          console.warn(\"a different schema was already registered for this table\", {\n            table,\n            currentSchema: schema,\n            newSchema: rawSchema,\n            world: world.address,\n          });\n        }\n      });\n    }\n    return existingSchema;\n  }\n\n  if (rawSchema) {\n    console.log(\"registering schema for table\", { table: table.toString(), world: world.address, rawSchema });\n    const schema = Promise.resolve(decodeSchema(rawSchema));\n    schemaCache[cacheKey] = schema;\n    return schema;\n  }\n\n  // TODO: populate from ECS cache before fetching from RPC\n\n  console.log(\"fetching schema for table\", { table: table.toString(), world: world.address });\n  const store = world as IStore;\n  const rawKeySchemaPromise = store.getKeySchema(table.toHex());\n  const rawValueSchemaPromise = store.getSchema(table.toHex());\n  const rawSchemaPromise = Promise.all([rawKeySchemaPromise, rawValueSchemaPromise]).then(\n    ([rawKeySchema, rawValueSchema]) => rawValueSchema + rawKeySchema.substring(2)\n  );\n  const schema = rawSchemaPromise.then((rawSchema: string) => {\n    const decodedSchema = decodeSchema(rawSchema);\n    if (decodedSchema.valueSchema.isEmpty) {\n      console.warn(\"Schema not found for table\", { table: table.toString(), world: world.address });\n    }\n    return decodedSchema;\n  });\n  schemaCache[cacheKey] = schema;\n  return schema;\n}\n","import { TableId } from \"@latticexyz/common/deprecated\";\nimport { Contract, utils } from \"ethers\";\nimport { metadataTableId, schemaTableId, TableMetadata } from \"../common\";\nimport { decodeData } from \"./decodeData\";\nimport { registerSchema } from \"./tableSchemas\";\nimport { IStore } from \"@latticexyz/store/types/ethers-contracts/IStore.sol/IStore\";\n\n// worldAddress:tableId => metadata\n// TODO: add chain ID to namespace?\nexport const metadataCache: Partial<Record<`${string}:${string}`, Promise<TableMetadata>>> = {};\n\n// the Contract arguments below assume that they're bound to a provider\n\nexport function getMetadata(world: Contract, table: TableId): Promise<TableMetadata> | undefined {\n  const cacheKey = `${world.address}:${table.toHex()}` as const;\n  return metadataCache[cacheKey];\n}\n\nexport function registerMetadata(\n  world: Contract,\n  table: TableId,\n  metadata?: TableMetadata\n): Promise<TableMetadata | undefined> {\n  const cacheKey = `${world.address}:${table.toHex()}` as const;\n\n  const cachedMetadataPromise = metadataCache[cacheKey];\n  if (cachedMetadataPromise) {\n    if (metadata) {\n      cachedMetadataPromise.then((cachedMetadata) => {\n        if (JSON.stringify(cachedMetadata) !== JSON.stringify(metadata)) {\n          console.warn(\"different metadata already registered for this table\", {\n            table,\n            currentMetadata: cachedMetadata,\n            newMetadata: metadata,\n            world: world.address,\n          });\n        }\n      });\n    }\n    return cachedMetadataPromise;\n  }\n\n  if (metadata) {\n    console.log(\"registering metadata for table\", { table: table.toString(), metadata, world: world.address });\n    const metadataPromise = Promise.resolve(metadata);\n    metadataCache[cacheKey] = metadataPromise;\n    return metadataPromise;\n  }\n\n  // TODO: populate from ECS cache before fetching from RPC\n\n  // Skip lazily fetching internal tables\n  if (table.toHex() === schemaTableId.toHex() || table.toHex() === metadataTableId.toHex()) {\n    return Promise.resolve(undefined);\n  }\n\n  console.log(\"fetching metadata for table\", { table: table.toString(), world: world.address });\n  const metadataPromise = Promise.all([\n    registerSchema(world, metadataTableId),\n    // TODO: figure out how to pass in rawSchema, it was giving me \"incorrect length\" errors before\n    //       we still have to do both calls though, and this is a getter, so this should be fine\n    (world as IStore)[\"getRecord(bytes32,bytes32[])\"](metadataTableId.toHex(), [table.toHex()]),\n  ]).then(([{ valueSchema }, metadataRecord]) => {\n    if (valueSchema.isEmpty) {\n      console.warn(\"Metadata schema not found\", { table: metadataTableId.toString(), world: world.address });\n    }\n    if (!metadataRecord || metadataRecord === \"0x\") {\n      console.warn(\"Metadata not found for table\", { table: table.toString(), world: world.address });\n    }\n    const decoded = decodeData(valueSchema, metadataRecord);\n    const tableName = decoded[0];\n    if (tableName !== table.name) {\n      console.warn(\"Metadata table name does not match table ID\", {\n        tableName,\n        tableId: table.toString(),\n        world: world.address,\n      });\n    }\n    const [fieldNames] = utils.defaultAbiCoder.decode([\"string[]\"], decoded[1]);\n    return { tableName, fieldNames };\n  });\n  metadataCache[cacheKey] = metadataPromise;\n  return metadataPromise;\n}\n","import {\n  DynamicSchemaType,\n  getStaticByteLength,\n  SchemaType,\n  StaticSchemaType,\n} from \"@latticexyz/schema-type/deprecated\";\nimport { hexToArray } from \"@latticexyz/utils\";\nimport { Schema } from \"../common\";\nimport { decodeStaticField } from \"./decodeStaticField\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\n\nexport const decodeData = (schema: Schema, hexData: string): Record<number, any> => {\n  const data: Record<number, any> = {};\n  const bytes = hexToArray(hexData);\n\n  let bytesOffset = 0;\n  schema.staticFields.forEach((fieldType, i) => {\n    const value = decodeStaticField(fieldType as StaticSchemaType, bytes, bytesOffset);\n    bytesOffset += getStaticByteLength(fieldType);\n    data[i] = value;\n  });\n\n  // Warn user if static data length doesn't match the schema, because data corruption might be possible.\n  const actualStaticDataLength = bytesOffset;\n  if (actualStaticDataLength !== schema.staticDataLength) {\n    console.warn(\n      \"Decoded static data length does not match schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?\",\n      {\n        expectedLength: schema.staticDataLength,\n        actualLength: actualStaticDataLength,\n        bytesOffset,\n        schema,\n        hexData,\n      }\n    );\n  }\n\n  if (schema.dynamicFields.length > 0) {\n    const dynamicDataLayout = bytes.slice(schema.staticDataLength, schema.staticDataLength + 32);\n    bytesOffset += 32;\n\n    // keep in sync with PackedCounter.sol\n    const packedCounterAccumulatorType = SchemaType.UINT56;\n    const packedCounterCounterType = SchemaType.UINT40;\n    const dynamicDataLength = decodeStaticField(packedCounterAccumulatorType, dynamicDataLayout, 0) as bigint;\n\n    schema.dynamicFields.forEach((fieldType, i) => {\n      const dataLength = decodeStaticField(\n        packedCounterCounterType,\n        dynamicDataLayout,\n        getStaticByteLength(packedCounterAccumulatorType) + i * getStaticByteLength(packedCounterCounterType)\n      ) as number;\n      const value = decodeDynamicField(\n        fieldType as DynamicSchemaType,\n        bytes.slice(bytesOffset, bytesOffset + dataLength)\n      );\n      bytesOffset += dataLength;\n      data[schema.staticFields.length + i] = value;\n    });\n\n    // Warn user if dynamic data length doesn't match the schema, because data corruption might be possible.\n    const actualDynamicDataLength = bytesOffset - 32 - actualStaticDataLength;\n    // TODO: refactor this so we don't break for bytes offsets >UINT40\n    if (BigInt(actualDynamicDataLength) !== dynamicDataLength) {\n      console.warn(\n        \"Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?\",\n        {\n          expectedLength: dynamicDataLength,\n          actualLength: actualDynamicDataLength,\n          bytesOffset,\n          schema,\n          hexData,\n        }\n      );\n    }\n  }\n\n  return data;\n};\n","import {\n  getStaticByteLength,\n  SchemaType,\n  SchemaTypeToPrimitiveType,\n  StaticSchemaType,\n} from \"@latticexyz/schema-type/deprecated\";\nimport { toHex, pad } from \"viem\";\n\nconst unsupportedStaticField = (fieldType: never): never => {\n  throw new Error(`Unsupported static field type: ${SchemaType[fieldType] ?? fieldType}`);\n};\n\nexport const decodeStaticField = <T extends StaticSchemaType, P extends SchemaTypeToPrimitiveType<T>>(\n  fieldType: T,\n  bytes: Uint8Array,\n  offset: number\n): P => {\n  const staticLength = getStaticByteLength(fieldType);\n  const slice = bytes.slice(offset, offset + staticLength);\n  const hex = toHex(slice);\n  const numberHex = hex.replace(/^0x$/, \"0x0\");\n\n  switch (fieldType) {\n    case SchemaType.BOOL:\n      return (Number(numberHex) !== 0) as P;\n    case SchemaType.UINT8:\n    case SchemaType.UINT16:\n    case SchemaType.UINT24:\n    case SchemaType.UINT32:\n    case SchemaType.UINT40:\n    case SchemaType.UINT48:\n      return Number(numberHex) as P;\n    case SchemaType.UINT56:\n    case SchemaType.UINT64:\n    case SchemaType.UINT72:\n    case SchemaType.UINT80:\n    case SchemaType.UINT88:\n    case SchemaType.UINT96:\n    case SchemaType.UINT104:\n    case SchemaType.UINT112:\n    case SchemaType.UINT120:\n    case SchemaType.UINT128:\n    case SchemaType.UINT136:\n    case SchemaType.UINT144:\n    case SchemaType.UINT152:\n    case SchemaType.UINT160:\n    case SchemaType.UINT168:\n    case SchemaType.UINT176:\n    case SchemaType.UINT184:\n    case SchemaType.UINT192:\n    case SchemaType.UINT200:\n    case SchemaType.UINT208:\n    case SchemaType.UINT216:\n    case SchemaType.UINT224:\n    case SchemaType.UINT232:\n    case SchemaType.UINT240:\n    case SchemaType.UINT248:\n    case SchemaType.UINT256:\n      return BigInt(numberHex) as P;\n    case SchemaType.INT8:\n    case SchemaType.INT16:\n    case SchemaType.INT24:\n    case SchemaType.INT32:\n    case SchemaType.INT40:\n    case SchemaType.INT48: {\n      const max = 2 ** (staticLength * 8);\n      const num = Number(numberHex);\n      return (num < max / 2 ? num : num - max) as P;\n    }\n    case SchemaType.INT56:\n    case SchemaType.INT64:\n    case SchemaType.INT72:\n    case SchemaType.INT80:\n    case SchemaType.INT88:\n    case SchemaType.INT96:\n    case SchemaType.INT104:\n    case SchemaType.INT112:\n    case SchemaType.INT120:\n    case SchemaType.INT128:\n    case SchemaType.INT136:\n    case SchemaType.INT144:\n    case SchemaType.INT152:\n    case SchemaType.INT160:\n    case SchemaType.INT168:\n    case SchemaType.INT176:\n    case SchemaType.INT184:\n    case SchemaType.INT192:\n    case SchemaType.INT200:\n    case SchemaType.INT208:\n    case SchemaType.INT216:\n    case SchemaType.INT224:\n    case SchemaType.INT232:\n    case SchemaType.INT240:\n    case SchemaType.INT248:\n    case SchemaType.INT256: {\n      const max = 2n ** (BigInt(staticLength) * 8n);\n      const num = BigInt(numberHex);\n      return (num < max / 2n ? num : num - max) as P;\n    }\n    case SchemaType.BYTES1:\n    case SchemaType.BYTES2:\n    case SchemaType.BYTES3:\n    case SchemaType.BYTES4:\n    case SchemaType.BYTES5:\n    case SchemaType.BYTES6:\n    case SchemaType.BYTES7:\n    case SchemaType.BYTES8:\n    case SchemaType.BYTES9:\n    case SchemaType.BYTES10:\n    case SchemaType.BYTES11:\n    case SchemaType.BYTES12:\n    case SchemaType.BYTES13:\n    case SchemaType.BYTES14:\n    case SchemaType.BYTES15:\n    case SchemaType.BYTES16:\n    case SchemaType.BYTES17:\n    case SchemaType.BYTES18:\n    case SchemaType.BYTES19:\n    case SchemaType.BYTES20:\n    case SchemaType.BYTES21:\n    case SchemaType.BYTES22:\n    case SchemaType.BYTES23:\n    case SchemaType.BYTES24:\n    case SchemaType.BYTES25:\n    case SchemaType.BYTES26:\n    case SchemaType.BYTES27:\n    case SchemaType.BYTES28:\n    case SchemaType.BYTES29:\n    case SchemaType.BYTES30:\n    case SchemaType.BYTES31:\n    case SchemaType.BYTES32:\n    case SchemaType.ADDRESS:\n      return pad(hex, { dir: \"right\", size: staticLength }) as P;\n    default:\n      return unsupportedStaticField(fieldType);\n  }\n};\n","import {\n  SchemaType,\n  DynamicSchemaType,\n  SchemaTypeArrayToElement,\n  getStaticByteLength,\n  SchemaTypeToPrimitiveType,\n} from \"@latticexyz/schema-type/deprecated\";\nimport { toHex, bytesToString } from \"viem\";\nimport { decodeStaticField } from \"./decodeStaticField\";\n\n// TODO: figure out how to switch back to `fieldType: never` for exhaustiveness check\nconst unsupportedDynamicField = (fieldType: SchemaType): never => {\n  throw new Error(`Unsupported dynamic field type: ${SchemaType[fieldType] ?? fieldType}`);\n};\n\nexport const decodeDynamicField = <T extends DynamicSchemaType, P extends SchemaTypeToPrimitiveType<T>>(\n  fieldType: T,\n  bytes: Uint8Array\n): P => {\n  if (fieldType === SchemaType.BYTES) {\n    return toHex(bytes) as P;\n  }\n  if (fieldType === SchemaType.STRING) {\n    return bytesToString(bytes) as P;\n  }\n\n  const staticType = SchemaTypeArrayToElement[fieldType];\n  if (staticType !== undefined) {\n    const fieldLength = getStaticByteLength(staticType);\n    const arrayLength = bytes.byteLength / fieldLength;\n    return new Array(arrayLength)\n      .fill(undefined)\n      .map((_, i) => decodeStaticField(staticType, bytes, i * fieldLength)) as any as P;\n  }\n\n  return unsupportedDynamicField(fieldType);\n};\n","import { SchemaTypeToAbiType } from \"@latticexyz/schema-type/deprecated\";\nimport { Schema } from \"../common\";\nimport { decodeAbiParameters } from \"viem\";\n\nexport function decodeKeyTuple(keySchema: Schema, keyTuple: unknown[]) {\n  const abiTypes = keySchema.staticFields.map((schemaType) => SchemaTypeToAbiType[schemaType]);\n  const decodedKeys = keyTuple.map(\n    (key, index) => decodeAbiParameters([{ type: abiTypes[index] }], key as `0x${string}`)[0]\n  );\n  return decodedKeys.reduce<Record<number, unknown>>((acc, curr, i) => ({ ...acc, [i]: curr }), {});\n}\n","import { DynamicSchemaType, StaticSchemaType } from \"@latticexyz/schema-type/deprecated\";\nimport { hexToArray } from \"@latticexyz/utils\";\nimport { Schema } from \"../common\";\nimport { decodeStaticField } from \"./decodeStaticField\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\n\nexport const decodeField = (schema: Schema, schemaIndex: number, hexData: string): Record<number, any> => {\n  const data: Record<number, any> = {};\n  const bytes = hexToArray(hexData);\n\n  schema.staticFields.forEach((fieldType, index) => {\n    if (index === schemaIndex) {\n      data[schemaIndex] = decodeStaticField(fieldType as StaticSchemaType, bytes, 0);\n    }\n  });\n\n  if (schema.dynamicFields.length > 0) {\n    schema.dynamicFields.forEach((fieldType, i) => {\n      const index = schema.staticFields.length + i;\n      if (index === schemaIndex) {\n        data[schemaIndex] = decodeDynamicField(fieldType as DynamicSchemaType, bytes);\n      }\n    });\n  }\n\n  return data;\n};\n","import { ComponentValue } from \"@latticexyz/recs\";\nimport { TableId } from \"@latticexyz/common/deprecated\";\nimport { Contract } from \"ethers\";\nimport { registerSchema } from \"./schemas/tableSchemas\";\nimport { registerMetadata } from \"./schemas/tableMetadata\";\nimport { decodeField } from \"./schemas/decodeField\";\nimport { TableSchema } from \"./common\";\nimport { decodeStaticField } from \"./schemas/decodeStaticField\";\nimport { DynamicSchemaType, StaticSchemaType } from \"@latticexyz/schema-type/deprecated\";\nimport { decodeDynamicField } from \"./schemas/decodeDynamicField\";\nimport { decodeKeyTuple } from \"./schemas/decodeKeyTuple\";\n\nexport async function decodeStoreSetField(\n  contract: Contract,\n  table: TableId,\n  keyTuple: string[],\n  schemaIndex: number,\n  data: string\n): Promise<{\n  schema: TableSchema;\n  indexedValues: Record<number, any>;\n  indexedInitialValues: Record<number, any>;\n  namedValues?: Record<string, any>;\n  namedInitialValues?: Record<string, any>;\n  indexedKey: Record<number, any>;\n  namedKey?: Record<string, any>;\n}> {\n  const schema = await registerSchema(contract, table);\n  const { valueSchema, keySchema } = schema;\n  const indexedValues = decodeField(valueSchema, schemaIndex, data);\n  const indexedKey = decodeKeyTuple(keySchema, keyTuple);\n\n  // Create an object that represents an \"uninitialized\" record as it would exist in Solidity\n  // to help populate RECS state when using StoreSetField before StoreSetRecord.\n  const defaultValues = [\n    ...valueSchema.staticFields.map((fieldType) =>\n      decodeStaticField(fieldType as StaticSchemaType, new Uint8Array(0), 0)\n    ),\n    ...valueSchema.dynamicFields.map((fieldType) =>\n      decodeDynamicField(fieldType as DynamicSchemaType, new Uint8Array(0))\n    ),\n  ];\n  const indexedInitialValues = Object.fromEntries(\n    defaultValues.map((value, index) => [index, value])\n  ) as ComponentValue;\n\n  const metadata = await registerMetadata(contract, table);\n  if (metadata) {\n    const { tableName, fieldNames } = metadata;\n    const namedInitialValues = Object.fromEntries(\n      defaultValues.map((fieldValue, schemaIndex) => {\n        return [fieldNames[schemaIndex], fieldValue];\n      })\n    ) as ComponentValue;\n\n    // TODO: once TableMetadata supports key names we can decode them here.\n    // For now we extract the key names of known tables from the `mud.config.ts`\n    // and ignore others in `applyNetworkUpdate`.\n    // (see https://github.com/latticexyz/mud/issues/824)\n\n    return {\n      schema,\n      indexedValues,\n      indexedInitialValues,\n      namedValues: {\n        [fieldNames[schemaIndex]]: indexedValues[schemaIndex],\n      },\n      namedInitialValues,\n      indexedKey,\n    };\n  }\n\n  console.warn(\n    `Received data for ${table.toString()}, but could not find table metadata for field names. Did your contracts get autogenerated and deployed properly?`\n  );\n  return {\n    schema,\n    indexedValues,\n    indexedInitialValues,\n    indexedKey,\n  };\n}\n","import { Entity } from \"@latticexyz/recs\";\nimport { toHex, pad, isHex } from \"viem\";\nimport { SingletonID } from \"../workers\";\n\n// TODO: revisit key tuple format?\nexport function keyTupleToEntityID(keyTuple: any[]): Entity {\n  // v2 uses an empty key tuple as the singleton ID, so we'll return the corresponding v1 singleton entity ID to normalize this for now\n  if (keyTuple.length === 0) {\n    return SingletonID;\n  }\n  // TODO: this should probably be padded based on key schema (uint vs bytes32 will have different leading/trailing zeroes)\n  return keyTuple.map((key) => (isHex(key) ? pad(key, { size: 32 }) : toHex(key, { size: 32 }))).join(\":\") as Entity;\n}\n","import { QueryLayerClient, QueryLayerDefinition } from \"@latticexyz/services/mode\";\nimport { createChannel, createClient } from \"nice-grpc-web\";\n\n/**\n * Create a MODE QueryLayerClient\n * @param url MUDE URL\n * @returns MODE QueryLayerClient\n */\nexport function createModeClient(url: string): QueryLayerClient {\n  return createClient(QueryLayerDefinition, createChannel(url));\n}\n","import { ComponentValue } from \"@latticexyz/recs\";\nimport { AbiTypeToSchemaType, encodeSchema } from \"@latticexyz/schema-type/deprecated\";\nimport { QueryLayerClient } from \"@latticexyz/services/mode\";\nimport { arrayToHex } from \"@latticexyz/utils\";\nimport { TableId } from \"@latticexyz/common/deprecated\";\nimport { Contract } from \"ethers\";\nimport { NetworkEvents } from \"../../types\";\n\nimport { CacheStore, createCacheStore, storeEvent } from \"../../workers\";\nimport { keyTupleToEntityID } from \"../keyTupleToEntityID\";\nimport { registerMetadata } from \"../schemas/tableMetadata\";\nimport { registerSchema } from \"../schemas/tableSchemas\";\nimport { getBlockNumberFromModeTable } from \"./getBlockNumberFromModeTable\";\nimport { decodeAbiParameters } from \"viem\";\n\nexport async function syncTablesFromMode(\n  client: QueryLayerClient,\n  chainId: number,\n  world: Contract,\n  setPercentage?: (progress: number) => void\n): Promise<CacheStore> {\n  const cacheStore = createCacheStore();\n\n  const response = await client.getState({\n    chainTables: [],\n    worldTables: [],\n    namespace: {\n      chainId: chainId.toString(),\n      worldAddress: world.address,\n    },\n  });\n  console.log(\"syncTablesFromMode\", response);\n\n  const numRowsTotal = Object.values(response.worldTables).reduce((sum, table) => sum + table.rows.length, 0);\n  let numRowsProcessed = 0;\n\n  const blockNumber = getBlockNumberFromModeTable(response.chainTables[\"block_number\"]);\n  const registrationPromises: Promise<unknown>[] = [];\n\n  for (const [fullTableName, { rows, cols, types }] of Object.entries(response.worldTables)) {\n    const [tableNamespace, tableName] = fullTableName.split(\"__\");\n    const tableId = new TableId(tableNamespace, tableName);\n\n    const component = tableId.toString();\n\n    // TODO: separate keys and values/fields in MODE, but we'll infer for now\n    const keyLength = cols.findIndex((col) => !col.startsWith(\"key_\"));\n    const keyAbiTypes = types.slice(0, keyLength);\n    const keySchemaTypes = keyAbiTypes.map((abiType) => AbiTypeToSchemaType[abiType]);\n    const keySchemaHex = arrayToHex(encodeSchema(keySchemaTypes));\n\n    const fieldNames = cols.slice(keyLength);\n    // TODO: remove this hack once MODE is fixed (https://github.com/latticexyz/mud/issues/444)\n    const fieldAbiTypes = types.slice(keyLength).map((modeType) => modeType.match(/tuple\\((.*)\\[]\\)/)?.[1] ?? modeType);\n    const fieldSchemaTypes = fieldAbiTypes.map((abiType) => AbiTypeToSchemaType[abiType]);\n    const fieldSchemaHex = arrayToHex(encodeSchema(fieldSchemaTypes));\n\n    const rawSchema = fieldSchemaHex + keySchemaHex.substring(2);\n    // TODO: refactor registerSchema/registerMetadata to take chain+world address rather than Contract\n    registrationPromises.push(registerSchema(world, tableId, rawSchema));\n    registrationPromises.push(registerMetadata(world, tableId, { tableName, fieldNames }));\n\n    for (const row of rows) {\n      console.log(tableName, keyAbiTypes, fieldAbiTypes, row.values);\n      const keyTuple = row.values\n        .slice(0, keyLength)\n        .map((bytes, i) => decodeAbiParameters([{ type: keyAbiTypes[i] }], arrayToHex(bytes))[0]);\n      const values = row.values\n        .slice(keyLength)\n        .map((bytes, i) => decodeAbiParameters([{ type: fieldAbiTypes[i] }], arrayToHex(bytes))[0]);\n\n      const key = keyTuple.reduce<Record<number, unknown>>((acc, curr, i) => ({ ...acc, [i]: curr }), {});\n      const entity = keyTupleToEntityID(keyTuple);\n      const value = Object.fromEntries(values.map((value, i) => [fieldNames[i], value])) as ComponentValue;\n\n      storeEvent(cacheStore, {\n        type: NetworkEvents.NetworkComponentUpdate,\n        component,\n        entity,\n        key,\n        value,\n        blockNumber,\n        namespace: tableId.namespace,\n        table: tableId.name,\n      });\n\n      numRowsProcessed++;\n      // Update progress every 100 rows\n      if (numRowsProcessed % 100 === 0 && setPercentage) {\n        setPercentage(Math.floor(numRowsProcessed / numRowsTotal));\n      }\n    }\n    console.log(\"done syncing from mode table\", tableName);\n  }\n  console.log(\"done syncing from mode\", numRowsProcessed, \"rows processed\");\n\n  // make sure all schemas/metadata are registered before returning to avoid downstream lookup issues\n  await Promise.all(registrationPromises);\n\n  return cacheStore;\n}\n","import { TableData } from \"@latticexyz/services/mode\";\nimport { SchemaType } from \"@latticexyz/schema-type/deprecated\";\nimport { decodeValue } from \"../schemas/decodeValue\";\n\nexport function getBlockNumberFromModeTable(tableData: TableData): number {\n  // First column is the chain followed by the block number.\n  if (tableData.cols[1] !== \"block_number\") throw new Error(\"Table does not contain block_number column\");\n  return Number(decodeValue(SchemaType.UINT256, tableData.rows[0].values[1]));\n}\n","import { SchemaType, SchemaTypeToPrimitiveType } from \"@latticexyz/schema-type/deprecated\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\nimport { decodeStaticField } from \"./decodeStaticField\";\n\nexport function decodeValueJSON(bytes: Uint8Array): any {\n  return JSON.parse(new TextDecoder().decode(bytes));\n}\n\nexport function decodeValue<T extends SchemaType, P extends SchemaTypeToPrimitiveType<T>>(\n  schemaType: T,\n  bytes: Uint8Array\n): P {\n  switch (schemaType) {\n    case SchemaType.BOOL:\n    case SchemaType.UINT8:\n    case SchemaType.UINT16:\n    case SchemaType.UINT24:\n    case SchemaType.UINT32:\n    case SchemaType.UINT40:\n    case SchemaType.UINT48:\n    case SchemaType.UINT56:\n    case SchemaType.UINT64:\n    case SchemaType.UINT72:\n    case SchemaType.UINT80:\n    case SchemaType.UINT88:\n    case SchemaType.UINT96:\n    case SchemaType.UINT104:\n    case SchemaType.UINT112:\n    case SchemaType.UINT120:\n    case SchemaType.UINT128:\n    case SchemaType.UINT136:\n    case SchemaType.UINT144:\n    case SchemaType.UINT152:\n    case SchemaType.UINT160:\n    case SchemaType.UINT168:\n    case SchemaType.UINT176:\n    case SchemaType.UINT184:\n    case SchemaType.UINT192:\n    case SchemaType.UINT200:\n    case SchemaType.UINT208:\n    case SchemaType.UINT216:\n    case SchemaType.UINT224:\n    case SchemaType.UINT232:\n    case SchemaType.UINT240:\n    case SchemaType.UINT248:\n    case SchemaType.UINT256:\n    case SchemaType.INT8:\n    case SchemaType.INT16:\n    case SchemaType.INT24:\n    case SchemaType.INT32:\n    case SchemaType.INT40:\n    case SchemaType.INT48:\n    case SchemaType.INT56:\n    case SchemaType.INT64:\n    case SchemaType.INT72:\n    case SchemaType.INT80:\n    case SchemaType.INT88:\n    case SchemaType.INT96:\n    case SchemaType.INT104:\n    case SchemaType.INT112:\n    case SchemaType.INT120:\n    case SchemaType.INT128:\n    case SchemaType.INT136:\n    case SchemaType.INT144:\n    case SchemaType.INT152:\n    case SchemaType.INT160:\n    case SchemaType.INT168:\n    case SchemaType.INT176:\n    case SchemaType.INT184:\n    case SchemaType.INT192:\n    case SchemaType.INT200:\n    case SchemaType.INT208:\n    case SchemaType.INT216:\n    case SchemaType.INT224:\n    case SchemaType.INT232:\n    case SchemaType.INT240:\n    case SchemaType.INT248:\n    case SchemaType.INT256:\n    case SchemaType.BYTES1:\n    case SchemaType.BYTES2:\n    case SchemaType.BYTES3:\n    case SchemaType.BYTES4:\n    case SchemaType.BYTES5:\n    case SchemaType.BYTES6:\n    case SchemaType.BYTES7:\n    case SchemaType.BYTES8:\n    case SchemaType.BYTES9:\n    case SchemaType.BYTES10:\n    case SchemaType.BYTES11:\n    case SchemaType.BYTES12:\n    case SchemaType.BYTES13:\n    case SchemaType.BYTES14:\n    case SchemaType.BYTES15:\n    case SchemaType.BYTES16:\n    case SchemaType.BYTES17:\n    case SchemaType.BYTES18:\n    case SchemaType.BYTES19:\n    case SchemaType.BYTES20:\n    case SchemaType.BYTES21:\n    case SchemaType.BYTES22:\n    case SchemaType.BYTES23:\n    case SchemaType.BYTES24:\n    case SchemaType.BYTES25:\n    case SchemaType.BYTES26:\n    case SchemaType.BYTES27:\n    case SchemaType.BYTES28:\n    case SchemaType.BYTES29:\n    case SchemaType.BYTES30:\n    case SchemaType.BYTES31:\n    case SchemaType.BYTES32:\n    case SchemaType.ADDRESS:\n      return decodeStaticField(schemaType, bytes, 0) as P;\n    default:\n      return decodeDynamicField(schemaType, bytes) as P;\n  }\n}\n","import { QueryLayerClient } from \"@latticexyz/services/mode\";\nimport { getBlockNumberFromModeTable } from \"./getBlockNumberFromModeTable\";\n\nexport async function getModeBlockNumber(client: QueryLayerClient, chainId: number): Promise<number> {\n  try {\n    const response = await client.getPartialState({\n      table: \"block_number\",\n      namespace: {\n        chainId: chainId.toString(),\n      },\n    });\n    const blockNumber = getBlockNumberFromModeTable(response.chainTables[\"block_number\"]);\n    return blockNumber;\n  } catch (e) {\n    console.error(\"MODE Error: \", e);\n    return -1;\n  }\n}\n","import { Entity } from \"@latticexyz/recs\";\nimport { NetworkEvents, RawTableRecord } from \"../types\";\nimport { decodeStoreSetRecord } from \"./decodeStoreSetRecord\";\nimport { Contract } from \"ethers\";\nimport { keyTupleToEntityID } from \"./keyTupleToEntityID\";\nimport { NetworkComponentUpdate } from \"../types\";\n\nexport async function transformTableRecordsIntoEvents(\n  storeContract: Contract,\n  records: RawTableRecord[],\n  blockNumber: number\n): Promise<NetworkComponentUpdate[]> {\n  const events = [] as NetworkComponentUpdate[];\n\n  for (const record of records) {\n    const { tableId, keyTuple, value } = record;\n    const { indexedValues, namedValues, indexedKey, namedKey } = await decodeStoreSetRecord(\n      storeContract,\n      tableId,\n      keyTuple,\n      value\n    );\n    const key = { ...indexedKey, ...namedKey };\n    const component = tableId.toString();\n    const entityId = keyTupleToEntityID(keyTuple);\n\n    const ecsEvent = {\n      type: NetworkEvents.NetworkComponentUpdate,\n      component,\n      entity: entityId as Entity,\n      key,\n      value: { ...indexedValues, ...namedValues },\n      lastEventInTx: false,\n      txHash: \"cache\",\n      blockNumber,\n      namespace: tableId.namespace,\n      table: tableId.name,\n    } satisfies NetworkComponentUpdate;\n\n    events.push(ecsEvent);\n  }\n\n  return events;\n}\n","import { Observable, concatMap, map, of } from \"rxjs\";\nimport { fetchStoreEvents } from \"./fetchStoreEvents\";\nimport { NetworkComponentUpdate, NetworkEvent } from \"../types\";\nimport { orderBy } from \"lodash\";\nimport debug from \"debug\";\nimport { awaitPromise, range } from \"@latticexyz/utils\";\n\n/**\n * Create a RxJS stream of {@link NetworkComponentUpdate}s by listening to new\n * blocks from the blockNumber$ stream and fetching the corresponding block\n * from the connected RPC.\n *\n * @dev Only use if {@link createLatestEventStreamService} is not available.\n *\n * @param blockNumber$ Block number stream\n * @param fetchWorldEvents Function to fetch World events in a block range ({@link createFetchWorldEventsInBlockRange}).\n * @returns Stream of {@link NetworkComponentUpdate}s.\n */\nexport function createLatestEventStreamRPC(\n  blockNumber$: Observable<number>,\n  boundFetchStoreEvents: (fromBlock: number, toBlock: number) => ReturnType<typeof fetchStoreEvents>\n): Observable<NetworkEvent> {\n  let lastSyncedBlockNumber: number | undefined;\n\n  return blockNumber$.pipe(\n    map(async (blockNumber) => {\n      const from =\n        lastSyncedBlockNumber == null || lastSyncedBlockNumber >= blockNumber ? blockNumber : lastSyncedBlockNumber + 1;\n      const to = blockNumber;\n      lastSyncedBlockNumber = to;\n      const storeEvents = await boundFetchStoreEvents(from, to);\n\n      const events = orderBy(storeEvents, [\"blockNumber\", \"logIndex\"]);\n      debug(`fetched ${events.length} events from block range ${from} -> ${to}`);\n\n      return events;\n    }),\n    awaitPromise(),\n    concatMap((v) => of(...v))\n  );\n}\n\n/**\n * Fetch ECS events from contracts in the given block range.\n *\n * @param fetchWorldEvents Function to fetch World events in a block range ({@link createFetchWorldEventsInBlockRange}).\n * @param fromBlockNumber Start of block range (inclusive).\n * @param toBlockNumber End of block range (inclusive).\n * @param interval Chunk fetching the blocks in intervals to avoid overwhelming the client.\n * @returns Promise resolving with array containing the contract ECS events in the given block range.\n */\nexport async function fetchEventsInBlockRangeChunked(\n  boundFetchStoreEvents: (fromBlock: number, toBlock: number) => ReturnType<typeof fetchStoreEvents>,\n  fromBlockNumber: number,\n  toBlockNumber: number,\n  interval = 50,\n  setPercentage?: (percentage: number) => void\n): Promise<NetworkComponentUpdate[]> {\n  let events: NetworkComponentUpdate[] = [];\n  const delta = toBlockNumber - fromBlockNumber;\n  const numSteps = Math.ceil(delta / interval);\n  const steps = [...range(numSteps, interval, fromBlockNumber)];\n\n  for (let i = 0; i < steps.length; i++) {\n    const from = steps[i];\n    const to = i === steps.length - 1 ? toBlockNumber : steps[i + 1] - 1;\n    const storeEvents = await boundFetchStoreEvents(from, to);\n\n    if (setPercentage) setPercentage(((i * interval) / delta) * 100);\n    debug(`initial sync fetched ${events.length} events from block range ${from} -> ${to}`);\n\n    events = events.concat(orderBy(storeEvents, [\"blockNumber\", \"logIndex\"]));\n  }\n\n  return events;\n}\n"],"mappings":"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","names":["NetworkEvents","isSystemCallEvent","isNetworkComponentUpdateEvent","ContractSchemaValue","ContractSchemaValueId","ContractSchemaValueArrayToElement","Formatter","callWithRetry","extractEncodedArguments","range","sleep","BigNumber","Contract","resolveProperties","abi","ensureNetworkIsUp","provider","wssProvider","fetchBlock","requireMinimumBlockNumber","_","block","rawBlock","fetchLogs","topics","startBlockNumber","endBlockNumber","contracts","getLogPromise","contractAddress","params","logs","log","blockPromise","_blockNumber","getLogPromises","logPromises","k","c","topicsForContract","t","call","blockNumber","fetchEventsInBlockRange","supportsBatchQueries","a","b","addressToContractKey","contractKey","contractEvents","i","address","contract","logDescription","lastEventInTx","e","getRevertReason","txHash","tx","encodedRevertReason","Web3Provider","WebSocketProvider","callWithRetry","observableToComputed","timeoutAfter","observable","reaction","runInAction","JsonRpcBatchProvider","JsonRpcProvider","MUDJsonRpcProvider","url","network","MUDJsonRpcBatchProvider","createProvider","chainId","jsonRpcUrl","wsRpcUrl","externalProvider","options","network","providers","Web3Provider","MUDJsonRpcBatchProvider","MUDJsonRpcProvider","WebSocketProvider","ConnectionState","createReconnectingProvider","config","connected","observable","disposers","initProviders","runInAction","prevProviders","conf","callWithRetry","newProviders","ensureNetworkIsUp","reaction","currentProviders","keepAliveInterval","timeoutAfter","observableToComputed","disposer","stretch","reaction","concat","concatMap","EMPTY","endWith","filter","map","range","ReplaySubject","take","createBlockNumberStream","providers","options","blockNumberEvent$","initialSync$","blockNr","blocksToSync","i","dispose","currProviders","provider","streamEmpty","blockNumber","BehaviorSubject","Subject","storeEvent$","transactionHash$","publicClient$","walletClient$","cacheStore$","worldAddress$","packTuple","transformIterator","unpackTuple","arrayToIterator","deferred","mergeIterators","transformIterator","indexedDB","VERSION","initStore","db","storeId","initDb","dbId","stores","version","idb","resolve","reject","promise","request","store","error","initCache","id","openStore","set","key","value","ignoreResult","get","item","remove","keys","rawKeys","stringKeys","k","values","entries","keyIterator","valueIterator","createDebug","debug","debug","Subject","debug","getCacheId","namespace","chainId","worldAddress","createCacheStore","components","componentToIndex","entities","entityToIndex","blockNumber","state","componentUpdate$","storeEvent","cacheStore","component","entity","value","partialValue","initialValue","key","table","keys","tables","componentIndex","entityIndex","cacheKey","packTuple","currentValue","storeEvents","events","event","getCacheStoreEntries","transformIterator","unpackTuple","mergeCacheStores","stores","result","sortedStores","a","b","store","updateEvent","saveCacheStoreToIndexDb","cache","loadIndexDbCacheStore","i","getIndexDBCacheStoreBlockNumber","getIndexDbECSCache","version","idb","initCache","pad","SyncState","SingletonID","GodID","awaitStreamValue","filterNullish","keccak256","streamToDefinedComputed","bufferTime","concat","concatMap","filter","ignoreElements","map","of","Subject","take","computed","orderBy","isDefined","TableId","schemaTableId","metadataTableId","storeEvents","ephemeralEvents","TableId","TableId","utils","getStaticByteLength","SchemaTypeToAbiType","hexToArray","decodeSchema","rawSchema","isEmpty","buffer","valueSchemaBytes","keySchemaBytes","valueSchema","decodeSchemaBytes","keySchema","schemaBytes","staticDataLength","numStaticFields","numDynamicFields","staticFields","dynamicFields","i","actualStaticDataLength","acc","fieldType","abi","type","schemaCache","registerSchema","world","table","rawSchema","cacheKey","existingSchema","schemaCache","schema","decodeSchema","store","rawKeySchemaPromise","rawValueSchemaPromise","rawKeySchema","rawValueSchema","decodedSchema","utils","getStaticByteLength","SchemaType","hexToArray","getStaticByteLength","SchemaType","toHex","pad","unsupportedStaticField","fieldType","decodeStaticField","bytes","offset","staticLength","slice","hex","numberHex","max","num","SchemaType","SchemaTypeArrayToElement","getStaticByteLength","toHex","bytesToString","unsupportedDynamicField","fieldType","SchemaType","decodeDynamicField","bytes","toHex","bytesToString","staticType","SchemaTypeArrayToElement","fieldLength","getStaticByteLength","arrayLength","_","i","decodeStaticField","decodeData","schema","hexData","data","bytes","hexToArray","bytesOffset","fieldType","i","value","decodeStaticField","getStaticByteLength","actualStaticDataLength","dynamicDataLayout","packedCounterAccumulatorType","SchemaType","packedCounterCounterType","dynamicDataLength","dataLength","decodeDynamicField","actualDynamicDataLength","metadataCache","registerMetadata","world","table","metadata","cacheKey","cachedMetadataPromise","metadataCache","cachedMetadata","metadataPromise","schemaTableId","metadataTableId","registerSchema","valueSchema","metadataRecord","decoded","decodeData","tableName","fieldNames","utils","SchemaTypeToAbiType","decodeAbiParameters","decodeKeyTuple","keySchema","keyTuple","abiTypes","schemaType","key","index","acc","curr","i","decodeStoreSetRecord","contract","table","keyTuple","data","schemaTableId","tableForSchema","otherKeys","registerSchema","TableId","keySchema","valueSchema","indexedValues","decodeData","indexedKey","decodeKeyTuple","metadataTableId","tableForMetadata","tableName","fieldNames","utils","registerMetadata","metadata","namedValues","index","fieldName","hexToArray","decodeField","schema","schemaIndex","hexData","data","bytes","hexToArray","fieldType","index","decodeStaticField","i","decodeDynamicField","decodeStoreSetField","contract","table","keyTuple","schemaIndex","data","schema","registerSchema","valueSchema","keySchema","indexedValues","decodeField","indexedKey","decodeKeyTuple","defaultValues","fieldType","decodeStaticField","decodeDynamicField","indexedInitialValues","value","index","metadata","registerMetadata","tableName","fieldNames","namedInitialValues","fieldValue","toHex","pad","isHex","keyTupleToEntityID","keyTuple","SingletonID","key","isHex","pad","toHex","ecsEventFromLog","chainId","contract","log","parsedLog","lastEventInTx","blockNumber","transactionHash","logIndex","args","name","tableId","TableId","component","entity","keyTupleToEntityID","ecsEvent","indexedValues","namedValues","indexedKey","namedKey","decodeStoreSetRecord","storeEvent$","indexedInitialValues","namedInitialValues","decodeStoreSetField","keySchema","registerSchema","decodeKeyTuple","fetchStoreEvents","store","fromBlock","toBlock","chainId","topicSets","storeEvents","ephemeralEvents","eventName","isDefined","logSets","topics","logs","orderBy","log","lastLogForTx","unsortedEvents","parsedLog","transactionHash","logIndex","ecsEventFromLog","events","event","IStoreAbi","Contract","QueryLayerDefinition","createChannel","createClient","createModeClient","url","AbiTypeToSchemaType","encodeSchema","arrayToHex","TableId","SchemaType","SchemaType","decodeValue","schemaType","bytes","SchemaType","decodeStaticField","decodeDynamicField","getBlockNumberFromModeTable","tableData","decodeValue","SchemaType","decodeAbiParameters","syncTablesFromMode","client","chainId","world","setPercentage","cacheStore","createCacheStore","response","numRowsTotal","sum","table","numRowsProcessed","blockNumber","getBlockNumberFromModeTable","registrationPromises","fullTableName","rows","cols","types","tableNamespace","tableName","tableId","TableId","component","keyLength","col","keyAbiTypes","keySchemaTypes","abiType","AbiTypeToSchemaType","keySchemaHex","arrayToHex","encodeSchema","fieldNames","fieldAbiTypes","modeType","fieldSchemaTypes","rawSchema","registerSchema","registerMetadata","row","keyTuple","bytes","i","values","key","acc","curr","entity","keyTupleToEntityID","value","storeEvent","getModeBlockNumber","client","chainId","response","getBlockNumberFromModeTable","e","transformTableRecordsIntoEvents","storeContract","records","blockNumber","events","record","tableId","keyTuple","value","indexedValues","namedValues","indexedKey","namedKey","decodeStoreSetRecord","key","component","entityId","keyTupleToEntityID","ecsEvent","getEventSelector","concatMap","map","of","orderBy","debug","awaitPromise","range","createLatestEventStreamRPC","blockNumber$","boundFetchStoreEvents","lastSyncedBlockNumber","blockNumber","from","to","storeEvents","events","v","fetchEventsInBlockRangeChunked","fromBlockNumber","toBlockNumber","interval","setPercentage","delta","numSteps","steps","i","debug","VERSION","InputType","ack","SyncWorker","Subject","loadingState","blockNumber","newLoadingState","update","keccak256","SingletonID","computedConfig","streamToDefinedComputed","map","e","filterNullish","config","modeUrl","chainId","worldContract","disableCache","initialRecords","worldAddress$","cacheAgeThreshold","cacheInterval","providers","createReconnectingProvider","computed","provider","modeClient","createModeClient","indexDbCache","getIndexDbECSCache","passLiveEventsToOutput","cacheStore","createCacheStore","cacheStore$","blockNumber$","createBlockNumberStream","storeContract","Contract","IStoreAbi","boundFetchStoreEvents","fromBlock","toBlock","fetchStoreEvents","latestEvent$","createLatestEventStreamRPC","initialLiveEvents","event","isNetworkComponentUpdateEvent","storeEvent","saveCacheStoreToIndexDb","networkEvent","streamStartBlockNumberPromise","awaitStreamValue","cacheBlockNumber","getIndexDBCacheStoreBlockNumber","modeBlockNumber","getModeBlockNumber","initialBlockNumber","worldDeployLogs","getEventSelector","initialState","events","transformTableRecordsIntoEvents","storeEvents","syncFromMode","syncTablesFromMode","percentage","loadIndexDbCacheStore","streamStartBlockNumber","gapStateEvents","fetchEventsInBlockRangeChunked","i","getCacheStoreEntries","input$","throttledOutput$","bufferTime","filter","updates","concatMap","concat","of","take","ignoreElements"]}